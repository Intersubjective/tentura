// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'schema.schema.gql.dart';

// **************************************************************************
// BuiltValueGenerator
// **************************************************************************

const Gbeacon_constraint _$gbeaconConstraintbeacon_pkey =
    const Gbeacon_constraint._('beacon_pkey');
const Gbeacon_constraint _$gbeaconConstraintgUnknownEnumValue =
    const Gbeacon_constraint._('gUnknownEnumValue');

Gbeacon_constraint _$gbeaconConstraintValueOf(String name) {
  switch (name) {
    case 'beacon_pkey':
      return _$gbeaconConstraintbeacon_pkey;
    case 'gUnknownEnumValue':
      return _$gbeaconConstraintgUnknownEnumValue;
    default:
      return _$gbeaconConstraintgUnknownEnumValue;
  }
}

final BuiltSet<Gbeacon_constraint> _$gbeaconConstraintValues =
    new BuiltSet<Gbeacon_constraint>(const <Gbeacon_constraint>[
  _$gbeaconConstraintbeacon_pkey,
  _$gbeaconConstraintgUnknownEnumValue,
]);

const Gbeacon_select_column _$gbeaconSelectColumncomments_count =
    const Gbeacon_select_column._('comments_count');
const Gbeacon_select_column _$gbeaconSelectColumncreated_at =
    const Gbeacon_select_column._('created_at');
const Gbeacon_select_column _$gbeaconSelectColumndescription =
    const Gbeacon_select_column._('description');
const Gbeacon_select_column _$gbeaconSelectColumnenabled =
    const Gbeacon_select_column._('enabled');
const Gbeacon_select_column _$gbeaconSelectColumnhas_picture =
    const Gbeacon_select_column._('has_picture');
const Gbeacon_select_column _$gbeaconSelectColumnid =
    const Gbeacon_select_column._('id');
const Gbeacon_select_column _$gbeaconSelectColumnplace =
    const Gbeacon_select_column._('place');
const Gbeacon_select_column _$gbeaconSelectColumntimerange =
    const Gbeacon_select_column._('timerange');
const Gbeacon_select_column _$gbeaconSelectColumntitle =
    const Gbeacon_select_column._('title');
const Gbeacon_select_column _$gbeaconSelectColumnupdated_at =
    const Gbeacon_select_column._('updated_at');
const Gbeacon_select_column _$gbeaconSelectColumnuser_id =
    const Gbeacon_select_column._('user_id');
const Gbeacon_select_column _$gbeaconSelectColumngUnknownEnumValue =
    const Gbeacon_select_column._('gUnknownEnumValue');

Gbeacon_select_column _$gbeaconSelectColumnValueOf(String name) {
  switch (name) {
    case 'comments_count':
      return _$gbeaconSelectColumncomments_count;
    case 'created_at':
      return _$gbeaconSelectColumncreated_at;
    case 'description':
      return _$gbeaconSelectColumndescription;
    case 'enabled':
      return _$gbeaconSelectColumnenabled;
    case 'has_picture':
      return _$gbeaconSelectColumnhas_picture;
    case 'id':
      return _$gbeaconSelectColumnid;
    case 'place':
      return _$gbeaconSelectColumnplace;
    case 'timerange':
      return _$gbeaconSelectColumntimerange;
    case 'title':
      return _$gbeaconSelectColumntitle;
    case 'updated_at':
      return _$gbeaconSelectColumnupdated_at;
    case 'user_id':
      return _$gbeaconSelectColumnuser_id;
    case 'gUnknownEnumValue':
      return _$gbeaconSelectColumngUnknownEnumValue;
    default:
      return _$gbeaconSelectColumngUnknownEnumValue;
  }
}

final BuiltSet<Gbeacon_select_column> _$gbeaconSelectColumnValues =
    new BuiltSet<Gbeacon_select_column>(const <Gbeacon_select_column>[
  _$gbeaconSelectColumncomments_count,
  _$gbeaconSelectColumncreated_at,
  _$gbeaconSelectColumndescription,
  _$gbeaconSelectColumnenabled,
  _$gbeaconSelectColumnhas_picture,
  _$gbeaconSelectColumnid,
  _$gbeaconSelectColumnplace,
  _$gbeaconSelectColumntimerange,
  _$gbeaconSelectColumntitle,
  _$gbeaconSelectColumnupdated_at,
  _$gbeaconSelectColumnuser_id,
  _$gbeaconSelectColumngUnknownEnumValue,
]);

const Gbeacon_update_column _$gbeaconUpdateColumncomments_count =
    const Gbeacon_update_column._('comments_count');
const Gbeacon_update_column _$gbeaconUpdateColumncreated_at =
    const Gbeacon_update_column._('created_at');
const Gbeacon_update_column _$gbeaconUpdateColumndescription =
    const Gbeacon_update_column._('description');
const Gbeacon_update_column _$gbeaconUpdateColumnenabled =
    const Gbeacon_update_column._('enabled');
const Gbeacon_update_column _$gbeaconUpdateColumnhas_picture =
    const Gbeacon_update_column._('has_picture');
const Gbeacon_update_column _$gbeaconUpdateColumnid =
    const Gbeacon_update_column._('id');
const Gbeacon_update_column _$gbeaconUpdateColumnplace =
    const Gbeacon_update_column._('place');
const Gbeacon_update_column _$gbeaconUpdateColumntimerange =
    const Gbeacon_update_column._('timerange');
const Gbeacon_update_column _$gbeaconUpdateColumntitle =
    const Gbeacon_update_column._('title');
const Gbeacon_update_column _$gbeaconUpdateColumnupdated_at =
    const Gbeacon_update_column._('updated_at');
const Gbeacon_update_column _$gbeaconUpdateColumnuser_id =
    const Gbeacon_update_column._('user_id');
const Gbeacon_update_column _$gbeaconUpdateColumngUnknownEnumValue =
    const Gbeacon_update_column._('gUnknownEnumValue');

Gbeacon_update_column _$gbeaconUpdateColumnValueOf(String name) {
  switch (name) {
    case 'comments_count':
      return _$gbeaconUpdateColumncomments_count;
    case 'created_at':
      return _$gbeaconUpdateColumncreated_at;
    case 'description':
      return _$gbeaconUpdateColumndescription;
    case 'enabled':
      return _$gbeaconUpdateColumnenabled;
    case 'has_picture':
      return _$gbeaconUpdateColumnhas_picture;
    case 'id':
      return _$gbeaconUpdateColumnid;
    case 'place':
      return _$gbeaconUpdateColumnplace;
    case 'timerange':
      return _$gbeaconUpdateColumntimerange;
    case 'title':
      return _$gbeaconUpdateColumntitle;
    case 'updated_at':
      return _$gbeaconUpdateColumnupdated_at;
    case 'user_id':
      return _$gbeaconUpdateColumnuser_id;
    case 'gUnknownEnumValue':
      return _$gbeaconUpdateColumngUnknownEnumValue;
    default:
      return _$gbeaconUpdateColumngUnknownEnumValue;
  }
}

final BuiltSet<Gbeacon_update_column> _$gbeaconUpdateColumnValues =
    new BuiltSet<Gbeacon_update_column>(const <Gbeacon_update_column>[
  _$gbeaconUpdateColumncomments_count,
  _$gbeaconUpdateColumncreated_at,
  _$gbeaconUpdateColumndescription,
  _$gbeaconUpdateColumnenabled,
  _$gbeaconUpdateColumnhas_picture,
  _$gbeaconUpdateColumnid,
  _$gbeaconUpdateColumnplace,
  _$gbeaconUpdateColumntimerange,
  _$gbeaconUpdateColumntitle,
  _$gbeaconUpdateColumnupdated_at,
  _$gbeaconUpdateColumnuser_id,
  _$gbeaconUpdateColumngUnknownEnumValue,
]);

const Gcomment_constraint _$gcommentConstraintcomment_pkey =
    const Gcomment_constraint._('comment_pkey');
const Gcomment_constraint _$gcommentConstraintgUnknownEnumValue =
    const Gcomment_constraint._('gUnknownEnumValue');

Gcomment_constraint _$gcommentConstraintValueOf(String name) {
  switch (name) {
    case 'comment_pkey':
      return _$gcommentConstraintcomment_pkey;
    case 'gUnknownEnumValue':
      return _$gcommentConstraintgUnknownEnumValue;
    default:
      return _$gcommentConstraintgUnknownEnumValue;
  }
}

final BuiltSet<Gcomment_constraint> _$gcommentConstraintValues =
    new BuiltSet<Gcomment_constraint>(const <Gcomment_constraint>[
  _$gcommentConstraintcomment_pkey,
  _$gcommentConstraintgUnknownEnumValue,
]);

const Gcomment_select_column _$gcommentSelectColumnbeacon_id =
    const Gcomment_select_column._('beacon_id');
const Gcomment_select_column _$gcommentSelectColumncontent =
    const Gcomment_select_column._('content');
const Gcomment_select_column _$gcommentSelectColumncreated_at =
    const Gcomment_select_column._('created_at');
const Gcomment_select_column _$gcommentSelectColumnid =
    const Gcomment_select_column._('id');
const Gcomment_select_column _$gcommentSelectColumnuser_id =
    const Gcomment_select_column._('user_id');
const Gcomment_select_column _$gcommentSelectColumngUnknownEnumValue =
    const Gcomment_select_column._('gUnknownEnumValue');

Gcomment_select_column _$gcommentSelectColumnValueOf(String name) {
  switch (name) {
    case 'beacon_id':
      return _$gcommentSelectColumnbeacon_id;
    case 'content':
      return _$gcommentSelectColumncontent;
    case 'created_at':
      return _$gcommentSelectColumncreated_at;
    case 'id':
      return _$gcommentSelectColumnid;
    case 'user_id':
      return _$gcommentSelectColumnuser_id;
    case 'gUnknownEnumValue':
      return _$gcommentSelectColumngUnknownEnumValue;
    default:
      return _$gcommentSelectColumngUnknownEnumValue;
  }
}

final BuiltSet<Gcomment_select_column> _$gcommentSelectColumnValues =
    new BuiltSet<Gcomment_select_column>(const <Gcomment_select_column>[
  _$gcommentSelectColumnbeacon_id,
  _$gcommentSelectColumncontent,
  _$gcommentSelectColumncreated_at,
  _$gcommentSelectColumnid,
  _$gcommentSelectColumnuser_id,
  _$gcommentSelectColumngUnknownEnumValue,
]);

const Gcomment_update_column _$gcommentUpdateColumnbeacon_id =
    const Gcomment_update_column._('beacon_id');
const Gcomment_update_column _$gcommentUpdateColumncontent =
    const Gcomment_update_column._('content');
const Gcomment_update_column _$gcommentUpdateColumncreated_at =
    const Gcomment_update_column._('created_at');
const Gcomment_update_column _$gcommentUpdateColumnid =
    const Gcomment_update_column._('id');
const Gcomment_update_column _$gcommentUpdateColumnuser_id =
    const Gcomment_update_column._('user_id');
const Gcomment_update_column _$gcommentUpdateColumngUnknownEnumValue =
    const Gcomment_update_column._('gUnknownEnumValue');

Gcomment_update_column _$gcommentUpdateColumnValueOf(String name) {
  switch (name) {
    case 'beacon_id':
      return _$gcommentUpdateColumnbeacon_id;
    case 'content':
      return _$gcommentUpdateColumncontent;
    case 'created_at':
      return _$gcommentUpdateColumncreated_at;
    case 'id':
      return _$gcommentUpdateColumnid;
    case 'user_id':
      return _$gcommentUpdateColumnuser_id;
    case 'gUnknownEnumValue':
      return _$gcommentUpdateColumngUnknownEnumValue;
    default:
      return _$gcommentUpdateColumngUnknownEnumValue;
  }
}

final BuiltSet<Gcomment_update_column> _$gcommentUpdateColumnValues =
    new BuiltSet<Gcomment_update_column>(const <Gcomment_update_column>[
  _$gcommentUpdateColumnbeacon_id,
  _$gcommentUpdateColumncontent,
  _$gcommentUpdateColumncreated_at,
  _$gcommentUpdateColumnid,
  _$gcommentUpdateColumnuser_id,
  _$gcommentUpdateColumngUnknownEnumValue,
]);

const Gcursor_ordering _$gcursorOrderingASC = const Gcursor_ordering._('ASC');
const Gcursor_ordering _$gcursorOrderingDESC = const Gcursor_ordering._('DESC');
const Gcursor_ordering _$gcursorOrderinggUnknownEnumValue =
    const Gcursor_ordering._('gUnknownEnumValue');

Gcursor_ordering _$gcursorOrderingValueOf(String name) {
  switch (name) {
    case 'ASC':
      return _$gcursorOrderingASC;
    case 'DESC':
      return _$gcursorOrderingDESC;
    case 'gUnknownEnumValue':
      return _$gcursorOrderinggUnknownEnumValue;
    default:
      return _$gcursorOrderinggUnknownEnumValue;
  }
}

final BuiltSet<Gcursor_ordering> _$gcursorOrderingValues =
    new BuiltSet<Gcursor_ordering>(const <Gcursor_ordering>[
  _$gcursorOrderingASC,
  _$gcursorOrderingDESC,
  _$gcursorOrderinggUnknownEnumValue,
]);

const Gorder_by _$gorderByasc = const Gorder_by._('asc');
const Gorder_by _$gorderByasc_nulls_first =
    const Gorder_by._('asc_nulls_first');
const Gorder_by _$gorderByasc_nulls_last = const Gorder_by._('asc_nulls_last');
const Gorder_by _$gorderBydesc = const Gorder_by._('desc');
const Gorder_by _$gorderBydesc_nulls_first =
    const Gorder_by._('desc_nulls_first');
const Gorder_by _$gorderBydesc_nulls_last =
    const Gorder_by._('desc_nulls_last');
const Gorder_by _$gorderBygUnknownEnumValue =
    const Gorder_by._('gUnknownEnumValue');

Gorder_by _$gorderByValueOf(String name) {
  switch (name) {
    case 'asc':
      return _$gorderByasc;
    case 'asc_nulls_first':
      return _$gorderByasc_nulls_first;
    case 'asc_nulls_last':
      return _$gorderByasc_nulls_last;
    case 'desc':
      return _$gorderBydesc;
    case 'desc_nulls_first':
      return _$gorderBydesc_nulls_first;
    case 'desc_nulls_last':
      return _$gorderBydesc_nulls_last;
    case 'gUnknownEnumValue':
      return _$gorderBygUnknownEnumValue;
    default:
      return _$gorderBygUnknownEnumValue;
  }
}

final BuiltSet<Gorder_by> _$gorderByValues =
    new BuiltSet<Gorder_by>(const <Gorder_by>[
  _$gorderByasc,
  _$gorderByasc_nulls_first,
  _$gorderByasc_nulls_last,
  _$gorderBydesc,
  _$gorderBydesc_nulls_first,
  _$gorderBydesc_nulls_last,
  _$gorderBygUnknownEnumValue,
]);

const Guser_constraint _$guserConstraintuser_pkey =
    const Guser_constraint._('user_pkey');
const Guser_constraint _$guserConstraintgUnknownEnumValue =
    const Guser_constraint._('gUnknownEnumValue');

Guser_constraint _$guserConstraintValueOf(String name) {
  switch (name) {
    case 'user_pkey':
      return _$guserConstraintuser_pkey;
    case 'gUnknownEnumValue':
      return _$guserConstraintgUnknownEnumValue;
    default:
      return _$guserConstraintgUnknownEnumValue;
  }
}

final BuiltSet<Guser_constraint> _$guserConstraintValues =
    new BuiltSet<Guser_constraint>(const <Guser_constraint>[
  _$guserConstraintuser_pkey,
  _$guserConstraintgUnknownEnumValue,
]);

const Guser_select_column _$guserSelectColumncreated_at =
    const Guser_select_column._('created_at');
const Guser_select_column _$guserSelectColumndescription =
    const Guser_select_column._('description');
const Guser_select_column _$guserSelectColumnhas_picture =
    const Guser_select_column._('has_picture');
const Guser_select_column _$guserSelectColumnid =
    const Guser_select_column._('id');
const Guser_select_column _$guserSelectColumntitle =
    const Guser_select_column._('title');
const Guser_select_column _$guserSelectColumnupdated_at =
    const Guser_select_column._('updated_at');
const Guser_select_column _$guserSelectColumngUnknownEnumValue =
    const Guser_select_column._('gUnknownEnumValue');

Guser_select_column _$guserSelectColumnValueOf(String name) {
  switch (name) {
    case 'created_at':
      return _$guserSelectColumncreated_at;
    case 'description':
      return _$guserSelectColumndescription;
    case 'has_picture':
      return _$guserSelectColumnhas_picture;
    case 'id':
      return _$guserSelectColumnid;
    case 'title':
      return _$guserSelectColumntitle;
    case 'updated_at':
      return _$guserSelectColumnupdated_at;
    case 'gUnknownEnumValue':
      return _$guserSelectColumngUnknownEnumValue;
    default:
      return _$guserSelectColumngUnknownEnumValue;
  }
}

final BuiltSet<Guser_select_column> _$guserSelectColumnValues =
    new BuiltSet<Guser_select_column>(const <Guser_select_column>[
  _$guserSelectColumncreated_at,
  _$guserSelectColumndescription,
  _$guserSelectColumnhas_picture,
  _$guserSelectColumnid,
  _$guserSelectColumntitle,
  _$guserSelectColumnupdated_at,
  _$guserSelectColumngUnknownEnumValue,
]);

const Guser_update_column _$guserUpdateColumncreated_at =
    const Guser_update_column._('created_at');
const Guser_update_column _$guserUpdateColumndescription =
    const Guser_update_column._('description');
const Guser_update_column _$guserUpdateColumnhas_picture =
    const Guser_update_column._('has_picture');
const Guser_update_column _$guserUpdateColumnid =
    const Guser_update_column._('id');
const Guser_update_column _$guserUpdateColumntitle =
    const Guser_update_column._('title');
const Guser_update_column _$guserUpdateColumnupdated_at =
    const Guser_update_column._('updated_at');
const Guser_update_column _$guserUpdateColumngUnknownEnumValue =
    const Guser_update_column._('gUnknownEnumValue');

Guser_update_column _$guserUpdateColumnValueOf(String name) {
  switch (name) {
    case 'created_at':
      return _$guserUpdateColumncreated_at;
    case 'description':
      return _$guserUpdateColumndescription;
    case 'has_picture':
      return _$guserUpdateColumnhas_picture;
    case 'id':
      return _$guserUpdateColumnid;
    case 'title':
      return _$guserUpdateColumntitle;
    case 'updated_at':
      return _$guserUpdateColumnupdated_at;
    case 'gUnknownEnumValue':
      return _$guserUpdateColumngUnknownEnumValue;
    default:
      return _$guserUpdateColumngUnknownEnumValue;
  }
}

final BuiltSet<Guser_update_column> _$guserUpdateColumnValues =
    new BuiltSet<Guser_update_column>(const <Guser_update_column>[
  _$guserUpdateColumncreated_at,
  _$guserUpdateColumndescription,
  _$guserUpdateColumnhas_picture,
  _$guserUpdateColumnid,
  _$guserUpdateColumntitle,
  _$guserUpdateColumnupdated_at,
  _$guserUpdateColumngUnknownEnumValue,
]);

const Gvote_beacon_constraint _$gvoteBeaconConstraintvote_beacon_pkey =
    const Gvote_beacon_constraint._('vote_beacon_pkey');
const Gvote_beacon_constraint _$gvoteBeaconConstraintgUnknownEnumValue =
    const Gvote_beacon_constraint._('gUnknownEnumValue');

Gvote_beacon_constraint _$gvoteBeaconConstraintValueOf(String name) {
  switch (name) {
    case 'vote_beacon_pkey':
      return _$gvoteBeaconConstraintvote_beacon_pkey;
    case 'gUnknownEnumValue':
      return _$gvoteBeaconConstraintgUnknownEnumValue;
    default:
      return _$gvoteBeaconConstraintgUnknownEnumValue;
  }
}

final BuiltSet<Gvote_beacon_constraint> _$gvoteBeaconConstraintValues =
    new BuiltSet<Gvote_beacon_constraint>(const <Gvote_beacon_constraint>[
  _$gvoteBeaconConstraintvote_beacon_pkey,
  _$gvoteBeaconConstraintgUnknownEnumValue,
]);

const Gvote_beacon_select_column _$gvoteBeaconSelectColumnamount =
    const Gvote_beacon_select_column._('amount');
const Gvote_beacon_select_column _$gvoteBeaconSelectColumncreated_at =
    const Gvote_beacon_select_column._('created_at');
const Gvote_beacon_select_column _$gvoteBeaconSelectColumnobject =
    const Gvote_beacon_select_column._('object');
const Gvote_beacon_select_column _$gvoteBeaconSelectColumnsubject =
    const Gvote_beacon_select_column._('subject');
const Gvote_beacon_select_column _$gvoteBeaconSelectColumnupdated_at =
    const Gvote_beacon_select_column._('updated_at');
const Gvote_beacon_select_column _$gvoteBeaconSelectColumngUnknownEnumValue =
    const Gvote_beacon_select_column._('gUnknownEnumValue');

Gvote_beacon_select_column _$gvoteBeaconSelectColumnValueOf(String name) {
  switch (name) {
    case 'amount':
      return _$gvoteBeaconSelectColumnamount;
    case 'created_at':
      return _$gvoteBeaconSelectColumncreated_at;
    case 'object':
      return _$gvoteBeaconSelectColumnobject;
    case 'subject':
      return _$gvoteBeaconSelectColumnsubject;
    case 'updated_at':
      return _$gvoteBeaconSelectColumnupdated_at;
    case 'gUnknownEnumValue':
      return _$gvoteBeaconSelectColumngUnknownEnumValue;
    default:
      return _$gvoteBeaconSelectColumngUnknownEnumValue;
  }
}

final BuiltSet<Gvote_beacon_select_column> _$gvoteBeaconSelectColumnValues =
    new BuiltSet<Gvote_beacon_select_column>(const <Gvote_beacon_select_column>[
  _$gvoteBeaconSelectColumnamount,
  _$gvoteBeaconSelectColumncreated_at,
  _$gvoteBeaconSelectColumnobject,
  _$gvoteBeaconSelectColumnsubject,
  _$gvoteBeaconSelectColumnupdated_at,
  _$gvoteBeaconSelectColumngUnknownEnumValue,
]);

const Gvote_beacon_update_column _$gvoteBeaconUpdateColumnamount =
    const Gvote_beacon_update_column._('amount');
const Gvote_beacon_update_column _$gvoteBeaconUpdateColumncreated_at =
    const Gvote_beacon_update_column._('created_at');
const Gvote_beacon_update_column _$gvoteBeaconUpdateColumnobject =
    const Gvote_beacon_update_column._('object');
const Gvote_beacon_update_column _$gvoteBeaconUpdateColumnsubject =
    const Gvote_beacon_update_column._('subject');
const Gvote_beacon_update_column _$gvoteBeaconUpdateColumnupdated_at =
    const Gvote_beacon_update_column._('updated_at');
const Gvote_beacon_update_column _$gvoteBeaconUpdateColumngUnknownEnumValue =
    const Gvote_beacon_update_column._('gUnknownEnumValue');

Gvote_beacon_update_column _$gvoteBeaconUpdateColumnValueOf(String name) {
  switch (name) {
    case 'amount':
      return _$gvoteBeaconUpdateColumnamount;
    case 'created_at':
      return _$gvoteBeaconUpdateColumncreated_at;
    case 'object':
      return _$gvoteBeaconUpdateColumnobject;
    case 'subject':
      return _$gvoteBeaconUpdateColumnsubject;
    case 'updated_at':
      return _$gvoteBeaconUpdateColumnupdated_at;
    case 'gUnknownEnumValue':
      return _$gvoteBeaconUpdateColumngUnknownEnumValue;
    default:
      return _$gvoteBeaconUpdateColumngUnknownEnumValue;
  }
}

final BuiltSet<Gvote_beacon_update_column> _$gvoteBeaconUpdateColumnValues =
    new BuiltSet<Gvote_beacon_update_column>(const <Gvote_beacon_update_column>[
  _$gvoteBeaconUpdateColumnamount,
  _$gvoteBeaconUpdateColumncreated_at,
  _$gvoteBeaconUpdateColumnobject,
  _$gvoteBeaconUpdateColumnsubject,
  _$gvoteBeaconUpdateColumnupdated_at,
  _$gvoteBeaconUpdateColumngUnknownEnumValue,
]);

const Gvote_comment_constraint _$gvoteCommentConstraintvote_comment_pkey =
    const Gvote_comment_constraint._('vote_comment_pkey');
const Gvote_comment_constraint _$gvoteCommentConstraintgUnknownEnumValue =
    const Gvote_comment_constraint._('gUnknownEnumValue');

Gvote_comment_constraint _$gvoteCommentConstraintValueOf(String name) {
  switch (name) {
    case 'vote_comment_pkey':
      return _$gvoteCommentConstraintvote_comment_pkey;
    case 'gUnknownEnumValue':
      return _$gvoteCommentConstraintgUnknownEnumValue;
    default:
      return _$gvoteCommentConstraintgUnknownEnumValue;
  }
}

final BuiltSet<Gvote_comment_constraint> _$gvoteCommentConstraintValues =
    new BuiltSet<Gvote_comment_constraint>(const <Gvote_comment_constraint>[
  _$gvoteCommentConstraintvote_comment_pkey,
  _$gvoteCommentConstraintgUnknownEnumValue,
]);

const Gvote_comment_select_column _$gvoteCommentSelectColumnamount =
    const Gvote_comment_select_column._('amount');
const Gvote_comment_select_column _$gvoteCommentSelectColumncreated_at =
    const Gvote_comment_select_column._('created_at');
const Gvote_comment_select_column _$gvoteCommentSelectColumnobject =
    const Gvote_comment_select_column._('object');
const Gvote_comment_select_column _$gvoteCommentSelectColumnsubject =
    const Gvote_comment_select_column._('subject');
const Gvote_comment_select_column _$gvoteCommentSelectColumnupdated_at =
    const Gvote_comment_select_column._('updated_at');
const Gvote_comment_select_column _$gvoteCommentSelectColumngUnknownEnumValue =
    const Gvote_comment_select_column._('gUnknownEnumValue');

Gvote_comment_select_column _$gvoteCommentSelectColumnValueOf(String name) {
  switch (name) {
    case 'amount':
      return _$gvoteCommentSelectColumnamount;
    case 'created_at':
      return _$gvoteCommentSelectColumncreated_at;
    case 'object':
      return _$gvoteCommentSelectColumnobject;
    case 'subject':
      return _$gvoteCommentSelectColumnsubject;
    case 'updated_at':
      return _$gvoteCommentSelectColumnupdated_at;
    case 'gUnknownEnumValue':
      return _$gvoteCommentSelectColumngUnknownEnumValue;
    default:
      return _$gvoteCommentSelectColumngUnknownEnumValue;
  }
}

final BuiltSet<Gvote_comment_select_column> _$gvoteCommentSelectColumnValues =
    new BuiltSet<
        Gvote_comment_select_column>(const <Gvote_comment_select_column>[
  _$gvoteCommentSelectColumnamount,
  _$gvoteCommentSelectColumncreated_at,
  _$gvoteCommentSelectColumnobject,
  _$gvoteCommentSelectColumnsubject,
  _$gvoteCommentSelectColumnupdated_at,
  _$gvoteCommentSelectColumngUnknownEnumValue,
]);

const Gvote_comment_update_column _$gvoteCommentUpdateColumnamount =
    const Gvote_comment_update_column._('amount');
const Gvote_comment_update_column _$gvoteCommentUpdateColumncreated_at =
    const Gvote_comment_update_column._('created_at');
const Gvote_comment_update_column _$gvoteCommentUpdateColumnobject =
    const Gvote_comment_update_column._('object');
const Gvote_comment_update_column _$gvoteCommentUpdateColumnsubject =
    const Gvote_comment_update_column._('subject');
const Gvote_comment_update_column _$gvoteCommentUpdateColumnupdated_at =
    const Gvote_comment_update_column._('updated_at');
const Gvote_comment_update_column _$gvoteCommentUpdateColumngUnknownEnumValue =
    const Gvote_comment_update_column._('gUnknownEnumValue');

Gvote_comment_update_column _$gvoteCommentUpdateColumnValueOf(String name) {
  switch (name) {
    case 'amount':
      return _$gvoteCommentUpdateColumnamount;
    case 'created_at':
      return _$gvoteCommentUpdateColumncreated_at;
    case 'object':
      return _$gvoteCommentUpdateColumnobject;
    case 'subject':
      return _$gvoteCommentUpdateColumnsubject;
    case 'updated_at':
      return _$gvoteCommentUpdateColumnupdated_at;
    case 'gUnknownEnumValue':
      return _$gvoteCommentUpdateColumngUnknownEnumValue;
    default:
      return _$gvoteCommentUpdateColumngUnknownEnumValue;
  }
}

final BuiltSet<Gvote_comment_update_column> _$gvoteCommentUpdateColumnValues =
    new BuiltSet<
        Gvote_comment_update_column>(const <Gvote_comment_update_column>[
  _$gvoteCommentUpdateColumnamount,
  _$gvoteCommentUpdateColumncreated_at,
  _$gvoteCommentUpdateColumnobject,
  _$gvoteCommentUpdateColumnsubject,
  _$gvoteCommentUpdateColumnupdated_at,
  _$gvoteCommentUpdateColumngUnknownEnumValue,
]);

const Gvote_user_constraint _$gvoteUserConstraintvote_user_pkey =
    const Gvote_user_constraint._('vote_user_pkey');
const Gvote_user_constraint _$gvoteUserConstraintgUnknownEnumValue =
    const Gvote_user_constraint._('gUnknownEnumValue');

Gvote_user_constraint _$gvoteUserConstraintValueOf(String name) {
  switch (name) {
    case 'vote_user_pkey':
      return _$gvoteUserConstraintvote_user_pkey;
    case 'gUnknownEnumValue':
      return _$gvoteUserConstraintgUnknownEnumValue;
    default:
      return _$gvoteUserConstraintgUnknownEnumValue;
  }
}

final BuiltSet<Gvote_user_constraint> _$gvoteUserConstraintValues =
    new BuiltSet<Gvote_user_constraint>(const <Gvote_user_constraint>[
  _$gvoteUserConstraintvote_user_pkey,
  _$gvoteUserConstraintgUnknownEnumValue,
]);

const Gvote_user_select_column _$gvoteUserSelectColumnamount =
    const Gvote_user_select_column._('amount');
const Gvote_user_select_column _$gvoteUserSelectColumncreated_at =
    const Gvote_user_select_column._('created_at');
const Gvote_user_select_column _$gvoteUserSelectColumnobject =
    const Gvote_user_select_column._('object');
const Gvote_user_select_column _$gvoteUserSelectColumnsubject =
    const Gvote_user_select_column._('subject');
const Gvote_user_select_column _$gvoteUserSelectColumnupdated_at =
    const Gvote_user_select_column._('updated_at');
const Gvote_user_select_column _$gvoteUserSelectColumngUnknownEnumValue =
    const Gvote_user_select_column._('gUnknownEnumValue');

Gvote_user_select_column _$gvoteUserSelectColumnValueOf(String name) {
  switch (name) {
    case 'amount':
      return _$gvoteUserSelectColumnamount;
    case 'created_at':
      return _$gvoteUserSelectColumncreated_at;
    case 'object':
      return _$gvoteUserSelectColumnobject;
    case 'subject':
      return _$gvoteUserSelectColumnsubject;
    case 'updated_at':
      return _$gvoteUserSelectColumnupdated_at;
    case 'gUnknownEnumValue':
      return _$gvoteUserSelectColumngUnknownEnumValue;
    default:
      return _$gvoteUserSelectColumngUnknownEnumValue;
  }
}

final BuiltSet<Gvote_user_select_column> _$gvoteUserSelectColumnValues =
    new BuiltSet<Gvote_user_select_column>(const <Gvote_user_select_column>[
  _$gvoteUserSelectColumnamount,
  _$gvoteUserSelectColumncreated_at,
  _$gvoteUserSelectColumnobject,
  _$gvoteUserSelectColumnsubject,
  _$gvoteUserSelectColumnupdated_at,
  _$gvoteUserSelectColumngUnknownEnumValue,
]);

const Gvote_user_update_column _$gvoteUserUpdateColumnamount =
    const Gvote_user_update_column._('amount');
const Gvote_user_update_column _$gvoteUserUpdateColumncreated_at =
    const Gvote_user_update_column._('created_at');
const Gvote_user_update_column _$gvoteUserUpdateColumnobject =
    const Gvote_user_update_column._('object');
const Gvote_user_update_column _$gvoteUserUpdateColumnsubject =
    const Gvote_user_update_column._('subject');
const Gvote_user_update_column _$gvoteUserUpdateColumnupdated_at =
    const Gvote_user_update_column._('updated_at');
const Gvote_user_update_column _$gvoteUserUpdateColumngUnknownEnumValue =
    const Gvote_user_update_column._('gUnknownEnumValue');

Gvote_user_update_column _$gvoteUserUpdateColumnValueOf(String name) {
  switch (name) {
    case 'amount':
      return _$gvoteUserUpdateColumnamount;
    case 'created_at':
      return _$gvoteUserUpdateColumncreated_at;
    case 'object':
      return _$gvoteUserUpdateColumnobject;
    case 'subject':
      return _$gvoteUserUpdateColumnsubject;
    case 'updated_at':
      return _$gvoteUserUpdateColumnupdated_at;
    case 'gUnknownEnumValue':
      return _$gvoteUserUpdateColumngUnknownEnumValue;
    default:
      return _$gvoteUserUpdateColumngUnknownEnumValue;
  }
}

final BuiltSet<Gvote_user_update_column> _$gvoteUserUpdateColumnValues =
    new BuiltSet<Gvote_user_update_column>(const <Gvote_user_update_column>[
  _$gvoteUserUpdateColumnamount,
  _$gvoteUserUpdateColumncreated_at,
  _$gvoteUserUpdateColumnobject,
  _$gvoteUserUpdateColumnsubject,
  _$gvoteUserUpdateColumnupdated_at,
  _$gvoteUserUpdateColumngUnknownEnumValue,
]);

Serializer<Gbeacon_bool_exp> _$gbeaconBoolExpSerializer =
    new _$Gbeacon_bool_expSerializer();
Serializer<Gbeacon_constraint> _$gbeaconConstraintSerializer =
    new _$Gbeacon_constraintSerializer();
Serializer<Gbeacon_inc_input> _$gbeaconIncInputSerializer =
    new _$Gbeacon_inc_inputSerializer();
Serializer<Gbeacon_insert_input> _$gbeaconInsertInputSerializer =
    new _$Gbeacon_insert_inputSerializer();
Serializer<Gbeacon_on_conflict> _$gbeaconOnConflictSerializer =
    new _$Gbeacon_on_conflictSerializer();
Serializer<Gbeacon_order_by> _$gbeaconOrderBySerializer =
    new _$Gbeacon_order_bySerializer();
Serializer<Gbeacon_pk_columns_input> _$gbeaconPkColumnsInputSerializer =
    new _$Gbeacon_pk_columns_inputSerializer();
Serializer<Gbeacon_select_column> _$gbeaconSelectColumnSerializer =
    new _$Gbeacon_select_columnSerializer();
Serializer<Gbeacon_set_input> _$gbeaconSetInputSerializer =
    new _$Gbeacon_set_inputSerializer();
Serializer<Gbeacon_stream_cursor_input> _$gbeaconStreamCursorInputSerializer =
    new _$Gbeacon_stream_cursor_inputSerializer();
Serializer<Gbeacon_stream_cursor_value_input>
    _$gbeaconStreamCursorValueInputSerializer =
    new _$Gbeacon_stream_cursor_value_inputSerializer();
Serializer<Gbeacon_update_column> _$gbeaconUpdateColumnSerializer =
    new _$Gbeacon_update_columnSerializer();
Serializer<Gbeacon_updates> _$gbeaconUpdatesSerializer =
    new _$Gbeacon_updatesSerializer();
Serializer<GBoolean_comparison_exp> _$gBooleanComparisonExpSerializer =
    new _$GBoolean_comparison_expSerializer();
Serializer<Gcomment_aggregate_bool_exp> _$gcommentAggregateBoolExpSerializer =
    new _$Gcomment_aggregate_bool_expSerializer();
Serializer<Gcomment_aggregate_bool_exp_count>
    _$gcommentAggregateBoolExpCountSerializer =
    new _$Gcomment_aggregate_bool_exp_countSerializer();
Serializer<Gcomment_aggregate_order_by> _$gcommentAggregateOrderBySerializer =
    new _$Gcomment_aggregate_order_bySerializer();
Serializer<Gcomment_arr_rel_insert_input>
    _$gcommentArrRelInsertInputSerializer =
    new _$Gcomment_arr_rel_insert_inputSerializer();
Serializer<Gcomment_bool_exp> _$gcommentBoolExpSerializer =
    new _$Gcomment_bool_expSerializer();
Serializer<Gcomment_constraint> _$gcommentConstraintSerializer =
    new _$Gcomment_constraintSerializer();
Serializer<Gcomment_insert_input> _$gcommentInsertInputSerializer =
    new _$Gcomment_insert_inputSerializer();
Serializer<Gcomment_max_order_by> _$gcommentMaxOrderBySerializer =
    new _$Gcomment_max_order_bySerializer();
Serializer<Gcomment_min_order_by> _$gcommentMinOrderBySerializer =
    new _$Gcomment_min_order_bySerializer();
Serializer<Gcomment_on_conflict> _$gcommentOnConflictSerializer =
    new _$Gcomment_on_conflictSerializer();
Serializer<Gcomment_order_by> _$gcommentOrderBySerializer =
    new _$Gcomment_order_bySerializer();
Serializer<Gcomment_pk_columns_input> _$gcommentPkColumnsInputSerializer =
    new _$Gcomment_pk_columns_inputSerializer();
Serializer<Gcomment_select_column> _$gcommentSelectColumnSerializer =
    new _$Gcomment_select_columnSerializer();
Serializer<Gcomment_set_input> _$gcommentSetInputSerializer =
    new _$Gcomment_set_inputSerializer();
Serializer<Gcomment_stream_cursor_input> _$gcommentStreamCursorInputSerializer =
    new _$Gcomment_stream_cursor_inputSerializer();
Serializer<Gcomment_stream_cursor_value_input>
    _$gcommentStreamCursorValueInputSerializer =
    new _$Gcomment_stream_cursor_value_inputSerializer();
Serializer<Gcomment_update_column> _$gcommentUpdateColumnSerializer =
    new _$Gcomment_update_columnSerializer();
Serializer<Gcomment_updates> _$gcommentUpdatesSerializer =
    new _$Gcomment_updatesSerializer();
Serializer<Gcursor_ordering> _$gcursorOrderingSerializer =
    new _$Gcursor_orderingSerializer();
Serializer<Ggeography_cast_exp> _$ggeographyCastExpSerializer =
    new _$Ggeography_cast_expSerializer();
Serializer<Ggeography_comparison_exp> _$ggeographyComparisonExpSerializer =
    new _$Ggeography_comparison_expSerializer();
Serializer<Ggeometry_cast_exp> _$ggeometryCastExpSerializer =
    new _$Ggeometry_cast_expSerializer();
Serializer<Ggeometry_comparison_exp> _$ggeometryComparisonExpSerializer =
    new _$Ggeometry_comparison_expSerializer();
Serializer<GInt_comparison_exp> _$gIntComparisonExpSerializer =
    new _$GInt_comparison_expSerializer();
Serializer<Gorder_by> _$gorderBySerializer = new _$Gorder_bySerializer();
Serializer<Gst_d_within_geography_input> _$gstDWithinGeographyInputSerializer =
    new _$Gst_d_within_geography_inputSerializer();
Serializer<Gst_d_within_input> _$gstDWithinInputSerializer =
    new _$Gst_d_within_inputSerializer();
Serializer<GString_comparison_exp> _$gStringComparisonExpSerializer =
    new _$GString_comparison_expSerializer();
Serializer<Gtimestamptz_comparison_exp> _$gtimestamptzComparisonExpSerializer =
    new _$Gtimestamptz_comparison_expSerializer();
Serializer<Gtstzrange_comparison_exp> _$gtstzrangeComparisonExpSerializer =
    new _$Gtstzrange_comparison_expSerializer();
Serializer<Guser_bool_exp> _$guserBoolExpSerializer =
    new _$Guser_bool_expSerializer();
Serializer<Guser_constraint> _$guserConstraintSerializer =
    new _$Guser_constraintSerializer();
Serializer<Guser_insert_input> _$guserInsertInputSerializer =
    new _$Guser_insert_inputSerializer();
Serializer<Guser_obj_rel_insert_input> _$guserObjRelInsertInputSerializer =
    new _$Guser_obj_rel_insert_inputSerializer();
Serializer<Guser_on_conflict> _$guserOnConflictSerializer =
    new _$Guser_on_conflictSerializer();
Serializer<Guser_order_by> _$guserOrderBySerializer =
    new _$Guser_order_bySerializer();
Serializer<Guser_pk_columns_input> _$guserPkColumnsInputSerializer =
    new _$Guser_pk_columns_inputSerializer();
Serializer<Guser_select_column> _$guserSelectColumnSerializer =
    new _$Guser_select_columnSerializer();
Serializer<Guser_set_input> _$guserSetInputSerializer =
    new _$Guser_set_inputSerializer();
Serializer<Guser_stream_cursor_input> _$guserStreamCursorInputSerializer =
    new _$Guser_stream_cursor_inputSerializer();
Serializer<Guser_stream_cursor_value_input>
    _$guserStreamCursorValueInputSerializer =
    new _$Guser_stream_cursor_value_inputSerializer();
Serializer<Guser_update_column> _$guserUpdateColumnSerializer =
    new _$Guser_update_columnSerializer();
Serializer<Guser_updates> _$guserUpdatesSerializer =
    new _$Guser_updatesSerializer();
Serializer<Gvote_beacon_bool_exp> _$gvoteBeaconBoolExpSerializer =
    new _$Gvote_beacon_bool_expSerializer();
Serializer<Gvote_beacon_constraint> _$gvoteBeaconConstraintSerializer =
    new _$Gvote_beacon_constraintSerializer();
Serializer<Gvote_beacon_inc_input> _$gvoteBeaconIncInputSerializer =
    new _$Gvote_beacon_inc_inputSerializer();
Serializer<Gvote_beacon_insert_input> _$gvoteBeaconInsertInputSerializer =
    new _$Gvote_beacon_insert_inputSerializer();
Serializer<Gvote_beacon_on_conflict> _$gvoteBeaconOnConflictSerializer =
    new _$Gvote_beacon_on_conflictSerializer();
Serializer<Gvote_beacon_order_by> _$gvoteBeaconOrderBySerializer =
    new _$Gvote_beacon_order_bySerializer();
Serializer<Gvote_beacon_pk_columns_input>
    _$gvoteBeaconPkColumnsInputSerializer =
    new _$Gvote_beacon_pk_columns_inputSerializer();
Serializer<Gvote_beacon_select_column> _$gvoteBeaconSelectColumnSerializer =
    new _$Gvote_beacon_select_columnSerializer();
Serializer<Gvote_beacon_set_input> _$gvoteBeaconSetInputSerializer =
    new _$Gvote_beacon_set_inputSerializer();
Serializer<Gvote_beacon_stream_cursor_input>
    _$gvoteBeaconStreamCursorInputSerializer =
    new _$Gvote_beacon_stream_cursor_inputSerializer();
Serializer<Gvote_beacon_stream_cursor_value_input>
    _$gvoteBeaconStreamCursorValueInputSerializer =
    new _$Gvote_beacon_stream_cursor_value_inputSerializer();
Serializer<Gvote_beacon_update_column> _$gvoteBeaconUpdateColumnSerializer =
    new _$Gvote_beacon_update_columnSerializer();
Serializer<Gvote_beacon_updates> _$gvoteBeaconUpdatesSerializer =
    new _$Gvote_beacon_updatesSerializer();
Serializer<Gvote_comment_bool_exp> _$gvoteCommentBoolExpSerializer =
    new _$Gvote_comment_bool_expSerializer();
Serializer<Gvote_comment_constraint> _$gvoteCommentConstraintSerializer =
    new _$Gvote_comment_constraintSerializer();
Serializer<Gvote_comment_inc_input> _$gvoteCommentIncInputSerializer =
    new _$Gvote_comment_inc_inputSerializer();
Serializer<Gvote_comment_insert_input> _$gvoteCommentInsertInputSerializer =
    new _$Gvote_comment_insert_inputSerializer();
Serializer<Gvote_comment_on_conflict> _$gvoteCommentOnConflictSerializer =
    new _$Gvote_comment_on_conflictSerializer();
Serializer<Gvote_comment_order_by> _$gvoteCommentOrderBySerializer =
    new _$Gvote_comment_order_bySerializer();
Serializer<Gvote_comment_pk_columns_input>
    _$gvoteCommentPkColumnsInputSerializer =
    new _$Gvote_comment_pk_columns_inputSerializer();
Serializer<Gvote_comment_select_column> _$gvoteCommentSelectColumnSerializer =
    new _$Gvote_comment_select_columnSerializer();
Serializer<Gvote_comment_set_input> _$gvoteCommentSetInputSerializer =
    new _$Gvote_comment_set_inputSerializer();
Serializer<Gvote_comment_stream_cursor_input>
    _$gvoteCommentStreamCursorInputSerializer =
    new _$Gvote_comment_stream_cursor_inputSerializer();
Serializer<Gvote_comment_stream_cursor_value_input>
    _$gvoteCommentStreamCursorValueInputSerializer =
    new _$Gvote_comment_stream_cursor_value_inputSerializer();
Serializer<Gvote_comment_update_column> _$gvoteCommentUpdateColumnSerializer =
    new _$Gvote_comment_update_columnSerializer();
Serializer<Gvote_comment_updates> _$gvoteCommentUpdatesSerializer =
    new _$Gvote_comment_updatesSerializer();
Serializer<Gvote_user_bool_exp> _$gvoteUserBoolExpSerializer =
    new _$Gvote_user_bool_expSerializer();
Serializer<Gvote_user_constraint> _$gvoteUserConstraintSerializer =
    new _$Gvote_user_constraintSerializer();
Serializer<Gvote_user_inc_input> _$gvoteUserIncInputSerializer =
    new _$Gvote_user_inc_inputSerializer();
Serializer<Gvote_user_insert_input> _$gvoteUserInsertInputSerializer =
    new _$Gvote_user_insert_inputSerializer();
Serializer<Gvote_user_on_conflict> _$gvoteUserOnConflictSerializer =
    new _$Gvote_user_on_conflictSerializer();
Serializer<Gvote_user_order_by> _$gvoteUserOrderBySerializer =
    new _$Gvote_user_order_bySerializer();
Serializer<Gvote_user_pk_columns_input> _$gvoteUserPkColumnsInputSerializer =
    new _$Gvote_user_pk_columns_inputSerializer();
Serializer<Gvote_user_select_column> _$gvoteUserSelectColumnSerializer =
    new _$Gvote_user_select_columnSerializer();
Serializer<Gvote_user_set_input> _$gvoteUserSetInputSerializer =
    new _$Gvote_user_set_inputSerializer();
Serializer<Gvote_user_stream_cursor_input>
    _$gvoteUserStreamCursorInputSerializer =
    new _$Gvote_user_stream_cursor_inputSerializer();
Serializer<Gvote_user_stream_cursor_value_input>
    _$gvoteUserStreamCursorValueInputSerializer =
    new _$Gvote_user_stream_cursor_value_inputSerializer();
Serializer<Gvote_user_update_column> _$gvoteUserUpdateColumnSerializer =
    new _$Gvote_user_update_columnSerializer();
Serializer<Gvote_user_updates> _$gvoteUserUpdatesSerializer =
    new _$Gvote_user_updatesSerializer();

class _$Gbeacon_bool_expSerializer
    implements StructuredSerializer<Gbeacon_bool_exp> {
  @override
  final Iterable<Type> types = const [Gbeacon_bool_exp, _$Gbeacon_bool_exp];
  @override
  final String wireName = 'Gbeacon_bool_exp';

  @override
  Iterable<Object?> serialize(Serializers serializers, Gbeacon_bool_exp object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.G_and;
    if (value != null) {
      result
        ..add('_and')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(Gbeacon_bool_exp)])));
    }
    value = object.G_not;
    if (value != null) {
      result
        ..add('_not')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gbeacon_bool_exp)));
    }
    value = object.G_or;
    if (value != null) {
      result
        ..add('_or')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(Gbeacon_bool_exp)])));
    }
    value = object.author;
    if (value != null) {
      result
        ..add('author')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Guser_bool_exp)));
    }
    value = object.comments;
    if (value != null) {
      result
        ..add('comments')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gcomment_bool_exp)));
    }
    value = object.comments_aggregate;
    if (value != null) {
      result
        ..add('comments_aggregate')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gcomment_aggregate_bool_exp)));
    }
    value = object.comments_count;
    if (value != null) {
      result
        ..add('comments_count')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GInt_comparison_exp)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gtimestamptz_comparison_exp)));
    }
    value = object.description;
    if (value != null) {
      result
        ..add('description')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GString_comparison_exp)));
    }
    value = object.enabled;
    if (value != null) {
      result
        ..add('enabled')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GBoolean_comparison_exp)));
    }
    value = object.has_picture;
    if (value != null) {
      result
        ..add('has_picture')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GBoolean_comparison_exp)));
    }
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GString_comparison_exp)));
    }
    value = object.place;
    if (value != null) {
      result
        ..add('place')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Ggeography_comparison_exp)));
    }
    value = object.timerange;
    if (value != null) {
      result
        ..add('timerange')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gtstzrange_comparison_exp)));
    }
    value = object.title;
    if (value != null) {
      result
        ..add('title')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GString_comparison_exp)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gtimestamptz_comparison_exp)));
    }
    value = object.user_id;
    if (value != null) {
      result
        ..add('user_id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GString_comparison_exp)));
    }
    return result;
  }

  @override
  Gbeacon_bool_exp deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gbeacon_bool_expBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case '_and':
          result.G_and.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(Gbeacon_bool_exp)]))!
              as BuiltList<Object?>);
          break;
        case '_not':
          result.G_not.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gbeacon_bool_exp))!
              as Gbeacon_bool_exp);
          break;
        case '_or':
          result.G_or.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(Gbeacon_bool_exp)]))!
              as BuiltList<Object?>);
          break;
        case 'author':
          result.author.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Guser_bool_exp))!
              as Guser_bool_exp);
          break;
        case 'comments':
          result.comments.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gcomment_bool_exp))!
              as Gcomment_bool_exp);
          break;
        case 'comments_aggregate':
          result.comments_aggregate.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gcomment_aggregate_bool_exp))!
              as Gcomment_aggregate_bool_exp);
          break;
        case 'comments_count':
          result.comments_count.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GInt_comparison_exp))!
              as GInt_comparison_exp);
          break;
        case 'created_at':
          result.created_at.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gtimestamptz_comparison_exp))!
              as Gtimestamptz_comparison_exp);
          break;
        case 'description':
          result.description.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GString_comparison_exp))!
              as GString_comparison_exp);
          break;
        case 'enabled':
          result.enabled.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GBoolean_comparison_exp))!
              as GBoolean_comparison_exp);
          break;
        case 'has_picture':
          result.has_picture.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GBoolean_comparison_exp))!
              as GBoolean_comparison_exp);
          break;
        case 'id':
          result.id.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GString_comparison_exp))!
              as GString_comparison_exp);
          break;
        case 'place':
          result.place.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Ggeography_comparison_exp))!
              as Ggeography_comparison_exp);
          break;
        case 'timerange':
          result.timerange.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gtstzrange_comparison_exp))!
              as Gtstzrange_comparison_exp);
          break;
        case 'title':
          result.title.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GString_comparison_exp))!
              as GString_comparison_exp);
          break;
        case 'updated_at':
          result.updated_at.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gtimestamptz_comparison_exp))!
              as Gtimestamptz_comparison_exp);
          break;
        case 'user_id':
          result.user_id.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GString_comparison_exp))!
              as GString_comparison_exp);
          break;
      }
    }

    return result.build();
  }
}

class _$Gbeacon_constraintSerializer
    implements PrimitiveSerializer<Gbeacon_constraint> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };

  @override
  final Iterable<Type> types = const <Type>[Gbeacon_constraint];
  @override
  final String wireName = 'Gbeacon_constraint';

  @override
  Object serialize(Serializers serializers, Gbeacon_constraint object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Gbeacon_constraint deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      Gbeacon_constraint.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$Gbeacon_inc_inputSerializer
    implements StructuredSerializer<Gbeacon_inc_input> {
  @override
  final Iterable<Type> types = const [Gbeacon_inc_input, _$Gbeacon_inc_input];
  @override
  final String wireName = 'Gbeacon_inc_input';

  @override
  Iterable<Object?> serialize(Serializers serializers, Gbeacon_inc_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.comments_count;
    if (value != null) {
      result
        ..add('comments_count')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    return result;
  }

  @override
  Gbeacon_inc_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gbeacon_inc_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'comments_count':
          result.comments_count = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gbeacon_insert_inputSerializer
    implements StructuredSerializer<Gbeacon_insert_input> {
  @override
  final Iterable<Type> types = const [
    Gbeacon_insert_input,
    _$Gbeacon_insert_input
  ];
  @override
  final String wireName = 'Gbeacon_insert_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gbeacon_insert_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.author;
    if (value != null) {
      result
        ..add('author')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Guser_obj_rel_insert_input)));
    }
    value = object.comments;
    if (value != null) {
      result
        ..add('comments')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gcomment_arr_rel_insert_input)));
    }
    value = object.comments_count;
    if (value != null) {
      result
        ..add('comments_count')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.description;
    if (value != null) {
      result
        ..add('description')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.enabled;
    if (value != null) {
      result
        ..add('enabled')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.has_picture;
    if (value != null) {
      result
        ..add('has_picture')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.place;
    if (value != null) {
      result
        ..add('place')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(_i2.LatLng)));
    }
    value = object.timerange;
    if (value != null) {
      result
        ..add('timerange')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(_i3.DateTimeRange)));
    }
    value = object.title;
    if (value != null) {
      result
        ..add('title')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.user_id;
    if (value != null) {
      result
        ..add('user_id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  Gbeacon_insert_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gbeacon_insert_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'author':
          result.author.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Guser_obj_rel_insert_input))!
              as Guser_obj_rel_insert_input);
          break;
        case 'comments':
          result.comments.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gcomment_arr_rel_insert_input))!
              as Gcomment_arr_rel_insert_input);
          break;
        case 'comments_count':
          result.comments_count = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case 'description':
          result.description = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'enabled':
          result.enabled = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'has_picture':
          result.has_picture = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'place':
          result.place = serializers.deserialize(value,
              specifiedType: const FullType(_i2.LatLng)) as _i2.LatLng?;
          break;
        case 'timerange':
          result.timerange = serializers.deserialize(value,
                  specifiedType: const FullType(_i3.DateTimeRange))
              as _i3.DateTimeRange?;
          break;
        case 'title':
          result.title = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'updated_at':
          result.updated_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case 'user_id':
          result.user_id = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gbeacon_on_conflictSerializer
    implements StructuredSerializer<Gbeacon_on_conflict> {
  @override
  final Iterable<Type> types = const [
    Gbeacon_on_conflict,
    _$Gbeacon_on_conflict
  ];
  @override
  final String wireName = 'Gbeacon_on_conflict';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gbeacon_on_conflict object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'constraint',
      serializers.serialize(object.constraint,
          specifiedType: const FullType(Gbeacon_constraint)),
      'update_columns',
      serializers.serialize(object.update_columns,
          specifiedType: const FullType(
              BuiltList, const [const FullType(Gbeacon_update_column)])),
    ];
    Object? value;
    value = object.where;
    if (value != null) {
      result
        ..add('where')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gbeacon_bool_exp)));
    }
    return result;
  }

  @override
  Gbeacon_on_conflict deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gbeacon_on_conflictBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'constraint':
          result.constraint = serializers.deserialize(value,
                  specifiedType: const FullType(Gbeacon_constraint))!
              as Gbeacon_constraint;
          break;
        case 'update_columns':
          result.update_columns.replace(serializers.deserialize(value,
              specifiedType: const FullType(BuiltList, const [
                const FullType(Gbeacon_update_column)
              ]))! as BuiltList<Object?>);
          break;
        case 'where':
          result.where.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gbeacon_bool_exp))!
              as Gbeacon_bool_exp);
          break;
      }
    }

    return result.build();
  }
}

class _$Gbeacon_order_bySerializer
    implements StructuredSerializer<Gbeacon_order_by> {
  @override
  final Iterable<Type> types = const [Gbeacon_order_by, _$Gbeacon_order_by];
  @override
  final String wireName = 'Gbeacon_order_by';

  @override
  Iterable<Object?> serialize(Serializers serializers, Gbeacon_order_by object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.author;
    if (value != null) {
      result
        ..add('author')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Guser_order_by)));
    }
    value = object.comments_aggregate;
    if (value != null) {
      result
        ..add('comments_aggregate')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gcomment_aggregate_order_by)));
    }
    value = object.comments_count;
    if (value != null) {
      result
        ..add('comments_count')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.description;
    if (value != null) {
      result
        ..add('description')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.enabled;
    if (value != null) {
      result
        ..add('enabled')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.has_picture;
    if (value != null) {
      result
        ..add('has_picture')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.place;
    if (value != null) {
      result
        ..add('place')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.timerange;
    if (value != null) {
      result
        ..add('timerange')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.title;
    if (value != null) {
      result
        ..add('title')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.user_id;
    if (value != null) {
      result
        ..add('user_id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    return result;
  }

  @override
  Gbeacon_order_by deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gbeacon_order_byBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'author':
          result.author.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Guser_order_by))!
              as Guser_order_by);
          break;
        case 'comments_aggregate':
          result.comments_aggregate.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gcomment_aggregate_order_by))!
              as Gcomment_aggregate_order_by);
          break;
        case 'comments_count':
          result.comments_count = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'description':
          result.description = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'enabled':
          result.enabled = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'has_picture':
          result.has_picture = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'place':
          result.place = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'timerange':
          result.timerange = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'title':
          result.title = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'updated_at':
          result.updated_at = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'user_id':
          result.user_id = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gbeacon_pk_columns_inputSerializer
    implements StructuredSerializer<Gbeacon_pk_columns_input> {
  @override
  final Iterable<Type> types = const [
    Gbeacon_pk_columns_input,
    _$Gbeacon_pk_columns_input
  ];
  @override
  final String wireName = 'Gbeacon_pk_columns_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gbeacon_pk_columns_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'id',
      serializers.serialize(object.id, specifiedType: const FullType(String)),
    ];

    return result;
  }

  @override
  Gbeacon_pk_columns_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gbeacon_pk_columns_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(String))! as String;
          break;
      }
    }

    return result.build();
  }
}

class _$Gbeacon_select_columnSerializer
    implements PrimitiveSerializer<Gbeacon_select_column> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };

  @override
  final Iterable<Type> types = const <Type>[Gbeacon_select_column];
  @override
  final String wireName = 'Gbeacon_select_column';

  @override
  Object serialize(Serializers serializers, Gbeacon_select_column object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Gbeacon_select_column deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      Gbeacon_select_column.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$Gbeacon_set_inputSerializer
    implements StructuredSerializer<Gbeacon_set_input> {
  @override
  final Iterable<Type> types = const [Gbeacon_set_input, _$Gbeacon_set_input];
  @override
  final String wireName = 'Gbeacon_set_input';

  @override
  Iterable<Object?> serialize(Serializers serializers, Gbeacon_set_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.comments_count;
    if (value != null) {
      result
        ..add('comments_count')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.description;
    if (value != null) {
      result
        ..add('description')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.enabled;
    if (value != null) {
      result
        ..add('enabled')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.has_picture;
    if (value != null) {
      result
        ..add('has_picture')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.place;
    if (value != null) {
      result
        ..add('place')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(_i2.LatLng)));
    }
    value = object.timerange;
    if (value != null) {
      result
        ..add('timerange')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(_i3.DateTimeRange)));
    }
    value = object.title;
    if (value != null) {
      result
        ..add('title')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.user_id;
    if (value != null) {
      result
        ..add('user_id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  Gbeacon_set_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gbeacon_set_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'comments_count':
          result.comments_count = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case 'description':
          result.description = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'enabled':
          result.enabled = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'has_picture':
          result.has_picture = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'place':
          result.place = serializers.deserialize(value,
              specifiedType: const FullType(_i2.LatLng)) as _i2.LatLng?;
          break;
        case 'timerange':
          result.timerange = serializers.deserialize(value,
                  specifiedType: const FullType(_i3.DateTimeRange))
              as _i3.DateTimeRange?;
          break;
        case 'title':
          result.title = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'updated_at':
          result.updated_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case 'user_id':
          result.user_id = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gbeacon_stream_cursor_inputSerializer
    implements StructuredSerializer<Gbeacon_stream_cursor_input> {
  @override
  final Iterable<Type> types = const [
    Gbeacon_stream_cursor_input,
    _$Gbeacon_stream_cursor_input
  ];
  @override
  final String wireName = 'Gbeacon_stream_cursor_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gbeacon_stream_cursor_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'initial_value',
      serializers.serialize(object.initial_value,
          specifiedType: const FullType(Gbeacon_stream_cursor_value_input)),
    ];
    Object? value;
    value = object.ordering;
    if (value != null) {
      result
        ..add('ordering')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gcursor_ordering)));
    }
    return result;
  }

  @override
  Gbeacon_stream_cursor_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gbeacon_stream_cursor_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'initial_value':
          result.initial_value.replace(serializers.deserialize(value,
                  specifiedType:
                      const FullType(Gbeacon_stream_cursor_value_input))!
              as Gbeacon_stream_cursor_value_input);
          break;
        case 'ordering':
          result.ordering = serializers.deserialize(value,
                  specifiedType: const FullType(Gcursor_ordering))
              as Gcursor_ordering?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gbeacon_stream_cursor_value_inputSerializer
    implements StructuredSerializer<Gbeacon_stream_cursor_value_input> {
  @override
  final Iterable<Type> types = const [
    Gbeacon_stream_cursor_value_input,
    _$Gbeacon_stream_cursor_value_input
  ];
  @override
  final String wireName = 'Gbeacon_stream_cursor_value_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gbeacon_stream_cursor_value_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.comments_count;
    if (value != null) {
      result
        ..add('comments_count')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.description;
    if (value != null) {
      result
        ..add('description')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.enabled;
    if (value != null) {
      result
        ..add('enabled')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.has_picture;
    if (value != null) {
      result
        ..add('has_picture')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.place;
    if (value != null) {
      result
        ..add('place')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(_i2.LatLng)));
    }
    value = object.timerange;
    if (value != null) {
      result
        ..add('timerange')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(_i3.DateTimeRange)));
    }
    value = object.title;
    if (value != null) {
      result
        ..add('title')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.user_id;
    if (value != null) {
      result
        ..add('user_id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  Gbeacon_stream_cursor_value_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gbeacon_stream_cursor_value_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'comments_count':
          result.comments_count = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case 'description':
          result.description = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'enabled':
          result.enabled = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'has_picture':
          result.has_picture = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'place':
          result.place = serializers.deserialize(value,
              specifiedType: const FullType(_i2.LatLng)) as _i2.LatLng?;
          break;
        case 'timerange':
          result.timerange = serializers.deserialize(value,
                  specifiedType: const FullType(_i3.DateTimeRange))
              as _i3.DateTimeRange?;
          break;
        case 'title':
          result.title = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'updated_at':
          result.updated_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case 'user_id':
          result.user_id = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gbeacon_update_columnSerializer
    implements PrimitiveSerializer<Gbeacon_update_column> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };

  @override
  final Iterable<Type> types = const <Type>[Gbeacon_update_column];
  @override
  final String wireName = 'Gbeacon_update_column';

  @override
  Object serialize(Serializers serializers, Gbeacon_update_column object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Gbeacon_update_column deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      Gbeacon_update_column.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$Gbeacon_updatesSerializer
    implements StructuredSerializer<Gbeacon_updates> {
  @override
  final Iterable<Type> types = const [Gbeacon_updates, _$Gbeacon_updates];
  @override
  final String wireName = 'Gbeacon_updates';

  @override
  Iterable<Object?> serialize(Serializers serializers, Gbeacon_updates object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'where',
      serializers.serialize(object.where,
          specifiedType: const FullType(Gbeacon_bool_exp)),
    ];
    Object? value;
    value = object.G_inc;
    if (value != null) {
      result
        ..add('_inc')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gbeacon_inc_input)));
    }
    value = object.G_set;
    if (value != null) {
      result
        ..add('_set')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gbeacon_set_input)));
    }
    return result;
  }

  @override
  Gbeacon_updates deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gbeacon_updatesBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case '_inc':
          result.G_inc.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gbeacon_inc_input))!
              as Gbeacon_inc_input);
          break;
        case '_set':
          result.G_set.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gbeacon_set_input))!
              as Gbeacon_set_input);
          break;
        case 'where':
          result.where.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gbeacon_bool_exp))!
              as Gbeacon_bool_exp);
          break;
      }
    }

    return result.build();
  }
}

class _$GBoolean_comparison_expSerializer
    implements StructuredSerializer<GBoolean_comparison_exp> {
  @override
  final Iterable<Type> types = const [
    GBoolean_comparison_exp,
    _$GBoolean_comparison_exp
  ];
  @override
  final String wireName = 'GBoolean_comparison_exp';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GBoolean_comparison_exp object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.G_eq;
    if (value != null) {
      result
        ..add('_eq')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.G_gt;
    if (value != null) {
      result
        ..add('_gt')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.G_gte;
    if (value != null) {
      result
        ..add('_gte')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.G_in;
    if (value != null) {
      result
        ..add('_in')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(bool)])));
    }
    value = object.G_is_null;
    if (value != null) {
      result
        ..add('_is_null')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.G_lt;
    if (value != null) {
      result
        ..add('_lt')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.G_lte;
    if (value != null) {
      result
        ..add('_lte')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.G_neq;
    if (value != null) {
      result
        ..add('_neq')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.G_nin;
    if (value != null) {
      result
        ..add('_nin')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(bool)])));
    }
    return result;
  }

  @override
  GBoolean_comparison_exp deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GBoolean_comparison_expBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case '_eq':
          result.G_eq = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case '_gt':
          result.G_gt = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case '_gte':
          result.G_gte = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case '_in':
          result.G_in.replace(serializers.deserialize(value,
                  specifiedType:
                      const FullType(BuiltList, const [const FullType(bool)]))!
              as BuiltList<Object?>);
          break;
        case '_is_null':
          result.G_is_null = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case '_lt':
          result.G_lt = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case '_lte':
          result.G_lte = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case '_neq':
          result.G_neq = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case '_nin':
          result.G_nin.replace(serializers.deserialize(value,
                  specifiedType:
                      const FullType(BuiltList, const [const FullType(bool)]))!
              as BuiltList<Object?>);
          break;
      }
    }

    return result.build();
  }
}

class _$Gcomment_aggregate_bool_expSerializer
    implements StructuredSerializer<Gcomment_aggregate_bool_exp> {
  @override
  final Iterable<Type> types = const [
    Gcomment_aggregate_bool_exp,
    _$Gcomment_aggregate_bool_exp
  ];
  @override
  final String wireName = 'Gcomment_aggregate_bool_exp';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gcomment_aggregate_bool_exp object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.count;
    if (value != null) {
      result
        ..add('count')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gcomment_aggregate_bool_exp_count)));
    }
    return result;
  }

  @override
  Gcomment_aggregate_bool_exp deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gcomment_aggregate_bool_expBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'count':
          result.count.replace(serializers.deserialize(value,
                  specifiedType:
                      const FullType(Gcomment_aggregate_bool_exp_count))!
              as Gcomment_aggregate_bool_exp_count);
          break;
      }
    }

    return result.build();
  }
}

class _$Gcomment_aggregate_bool_exp_countSerializer
    implements StructuredSerializer<Gcomment_aggregate_bool_exp_count> {
  @override
  final Iterable<Type> types = const [
    Gcomment_aggregate_bool_exp_count,
    _$Gcomment_aggregate_bool_exp_count
  ];
  @override
  final String wireName = 'Gcomment_aggregate_bool_exp_count';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gcomment_aggregate_bool_exp_count object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'predicate',
      serializers.serialize(object.predicate,
          specifiedType: const FullType(GInt_comparison_exp)),
    ];
    Object? value;
    value = object.arguments;
    if (value != null) {
      result
        ..add('arguments')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(Gcomment_select_column)])));
    }
    value = object.distinct;
    if (value != null) {
      result
        ..add('distinct')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.filter;
    if (value != null) {
      result
        ..add('filter')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gcomment_bool_exp)));
    }
    return result;
  }

  @override
  Gcomment_aggregate_bool_exp_count deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gcomment_aggregate_bool_exp_countBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'arguments':
          result.arguments.replace(serializers.deserialize(value,
              specifiedType: const FullType(BuiltList, const [
                const FullType(Gcomment_select_column)
              ]))! as BuiltList<Object?>);
          break;
        case 'distinct':
          result.distinct = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'filter':
          result.filter.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gcomment_bool_exp))!
              as Gcomment_bool_exp);
          break;
        case 'predicate':
          result.predicate.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GInt_comparison_exp))!
              as GInt_comparison_exp);
          break;
      }
    }

    return result.build();
  }
}

class _$Gcomment_aggregate_order_bySerializer
    implements StructuredSerializer<Gcomment_aggregate_order_by> {
  @override
  final Iterable<Type> types = const [
    Gcomment_aggregate_order_by,
    _$Gcomment_aggregate_order_by
  ];
  @override
  final String wireName = 'Gcomment_aggregate_order_by';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gcomment_aggregate_order_by object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.count;
    if (value != null) {
      result
        ..add('count')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.max;
    if (value != null) {
      result
        ..add('max')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gcomment_max_order_by)));
    }
    value = object.min;
    if (value != null) {
      result
        ..add('min')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gcomment_min_order_by)));
    }
    return result;
  }

  @override
  Gcomment_aggregate_order_by deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gcomment_aggregate_order_byBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'count':
          result.count = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'max':
          result.max.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gcomment_max_order_by))!
              as Gcomment_max_order_by);
          break;
        case 'min':
          result.min.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gcomment_min_order_by))!
              as Gcomment_min_order_by);
          break;
      }
    }

    return result.build();
  }
}

class _$Gcomment_arr_rel_insert_inputSerializer
    implements StructuredSerializer<Gcomment_arr_rel_insert_input> {
  @override
  final Iterable<Type> types = const [
    Gcomment_arr_rel_insert_input,
    _$Gcomment_arr_rel_insert_input
  ];
  @override
  final String wireName = 'Gcomment_arr_rel_insert_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gcomment_arr_rel_insert_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'data',
      serializers.serialize(object.data,
          specifiedType: const FullType(
              BuiltList, const [const FullType(Gcomment_insert_input)])),
    ];
    Object? value;
    value = object.on_conflict;
    if (value != null) {
      result
        ..add('on_conflict')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gcomment_on_conflict)));
    }
    return result;
  }

  @override
  Gcomment_arr_rel_insert_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gcomment_arr_rel_insert_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'data':
          result.data.replace(serializers.deserialize(value,
              specifiedType: const FullType(BuiltList, const [
                const FullType(Gcomment_insert_input)
              ]))! as BuiltList<Object?>);
          break;
        case 'on_conflict':
          result.on_conflict.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gcomment_on_conflict))!
              as Gcomment_on_conflict);
          break;
      }
    }

    return result.build();
  }
}

class _$Gcomment_bool_expSerializer
    implements StructuredSerializer<Gcomment_bool_exp> {
  @override
  final Iterable<Type> types = const [Gcomment_bool_exp, _$Gcomment_bool_exp];
  @override
  final String wireName = 'Gcomment_bool_exp';

  @override
  Iterable<Object?> serialize(Serializers serializers, Gcomment_bool_exp object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.G_and;
    if (value != null) {
      result
        ..add('_and')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(Gcomment_bool_exp)])));
    }
    value = object.G_not;
    if (value != null) {
      result
        ..add('_not')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gcomment_bool_exp)));
    }
    value = object.G_or;
    if (value != null) {
      result
        ..add('_or')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(Gcomment_bool_exp)])));
    }
    value = object.author;
    if (value != null) {
      result
        ..add('author')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Guser_bool_exp)));
    }
    value = object.beacon_id;
    if (value != null) {
      result
        ..add('beacon_id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GString_comparison_exp)));
    }
    value = object.content;
    if (value != null) {
      result
        ..add('content')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GString_comparison_exp)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gtimestamptz_comparison_exp)));
    }
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GString_comparison_exp)));
    }
    value = object.user_id;
    if (value != null) {
      result
        ..add('user_id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GString_comparison_exp)));
    }
    return result;
  }

  @override
  Gcomment_bool_exp deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gcomment_bool_expBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case '_and':
          result.G_and.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(Gcomment_bool_exp)]))!
              as BuiltList<Object?>);
          break;
        case '_not':
          result.G_not.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gcomment_bool_exp))!
              as Gcomment_bool_exp);
          break;
        case '_or':
          result.G_or.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(Gcomment_bool_exp)]))!
              as BuiltList<Object?>);
          break;
        case 'author':
          result.author.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Guser_bool_exp))!
              as Guser_bool_exp);
          break;
        case 'beacon_id':
          result.beacon_id.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GString_comparison_exp))!
              as GString_comparison_exp);
          break;
        case 'content':
          result.content.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GString_comparison_exp))!
              as GString_comparison_exp);
          break;
        case 'created_at':
          result.created_at.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gtimestamptz_comparison_exp))!
              as Gtimestamptz_comparison_exp);
          break;
        case 'id':
          result.id.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GString_comparison_exp))!
              as GString_comparison_exp);
          break;
        case 'user_id':
          result.user_id.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GString_comparison_exp))!
              as GString_comparison_exp);
          break;
      }
    }

    return result.build();
  }
}

class _$Gcomment_constraintSerializer
    implements PrimitiveSerializer<Gcomment_constraint> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };

  @override
  final Iterable<Type> types = const <Type>[Gcomment_constraint];
  @override
  final String wireName = 'Gcomment_constraint';

  @override
  Object serialize(Serializers serializers, Gcomment_constraint object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Gcomment_constraint deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      Gcomment_constraint.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$Gcomment_insert_inputSerializer
    implements StructuredSerializer<Gcomment_insert_input> {
  @override
  final Iterable<Type> types = const [
    Gcomment_insert_input,
    _$Gcomment_insert_input
  ];
  @override
  final String wireName = 'Gcomment_insert_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gcomment_insert_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.author;
    if (value != null) {
      result
        ..add('author')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Guser_obj_rel_insert_input)));
    }
    value = object.beacon_id;
    if (value != null) {
      result
        ..add('beacon_id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.content;
    if (value != null) {
      result
        ..add('content')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.user_id;
    if (value != null) {
      result
        ..add('user_id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  Gcomment_insert_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gcomment_insert_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'author':
          result.author.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Guser_obj_rel_insert_input))!
              as Guser_obj_rel_insert_input);
          break;
        case 'beacon_id':
          result.beacon_id = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'content':
          result.content = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'user_id':
          result.user_id = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gcomment_max_order_bySerializer
    implements StructuredSerializer<Gcomment_max_order_by> {
  @override
  final Iterable<Type> types = const [
    Gcomment_max_order_by,
    _$Gcomment_max_order_by
  ];
  @override
  final String wireName = 'Gcomment_max_order_by';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gcomment_max_order_by object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.beacon_id;
    if (value != null) {
      result
        ..add('beacon_id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.content;
    if (value != null) {
      result
        ..add('content')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.user_id;
    if (value != null) {
      result
        ..add('user_id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    return result;
  }

  @override
  Gcomment_max_order_by deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gcomment_max_order_byBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'beacon_id':
          result.beacon_id = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'content':
          result.content = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'user_id':
          result.user_id = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gcomment_min_order_bySerializer
    implements StructuredSerializer<Gcomment_min_order_by> {
  @override
  final Iterable<Type> types = const [
    Gcomment_min_order_by,
    _$Gcomment_min_order_by
  ];
  @override
  final String wireName = 'Gcomment_min_order_by';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gcomment_min_order_by object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.beacon_id;
    if (value != null) {
      result
        ..add('beacon_id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.content;
    if (value != null) {
      result
        ..add('content')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.user_id;
    if (value != null) {
      result
        ..add('user_id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    return result;
  }

  @override
  Gcomment_min_order_by deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gcomment_min_order_byBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'beacon_id':
          result.beacon_id = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'content':
          result.content = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'user_id':
          result.user_id = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gcomment_on_conflictSerializer
    implements StructuredSerializer<Gcomment_on_conflict> {
  @override
  final Iterable<Type> types = const [
    Gcomment_on_conflict,
    _$Gcomment_on_conflict
  ];
  @override
  final String wireName = 'Gcomment_on_conflict';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gcomment_on_conflict object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'constraint',
      serializers.serialize(object.constraint,
          specifiedType: const FullType(Gcomment_constraint)),
      'update_columns',
      serializers.serialize(object.update_columns,
          specifiedType: const FullType(
              BuiltList, const [const FullType(Gcomment_update_column)])),
    ];
    Object? value;
    value = object.where;
    if (value != null) {
      result
        ..add('where')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gcomment_bool_exp)));
    }
    return result;
  }

  @override
  Gcomment_on_conflict deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gcomment_on_conflictBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'constraint':
          result.constraint = serializers.deserialize(value,
                  specifiedType: const FullType(Gcomment_constraint))!
              as Gcomment_constraint;
          break;
        case 'update_columns':
          result.update_columns.replace(serializers.deserialize(value,
              specifiedType: const FullType(BuiltList, const [
                const FullType(Gcomment_update_column)
              ]))! as BuiltList<Object?>);
          break;
        case 'where':
          result.where.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gcomment_bool_exp))!
              as Gcomment_bool_exp);
          break;
      }
    }

    return result.build();
  }
}

class _$Gcomment_order_bySerializer
    implements StructuredSerializer<Gcomment_order_by> {
  @override
  final Iterable<Type> types = const [Gcomment_order_by, _$Gcomment_order_by];
  @override
  final String wireName = 'Gcomment_order_by';

  @override
  Iterable<Object?> serialize(Serializers serializers, Gcomment_order_by object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.author;
    if (value != null) {
      result
        ..add('author')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Guser_order_by)));
    }
    value = object.beacon_id;
    if (value != null) {
      result
        ..add('beacon_id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.content;
    if (value != null) {
      result
        ..add('content')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.user_id;
    if (value != null) {
      result
        ..add('user_id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    return result;
  }

  @override
  Gcomment_order_by deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gcomment_order_byBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'author':
          result.author.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Guser_order_by))!
              as Guser_order_by);
          break;
        case 'beacon_id':
          result.beacon_id = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'content':
          result.content = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'user_id':
          result.user_id = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gcomment_pk_columns_inputSerializer
    implements StructuredSerializer<Gcomment_pk_columns_input> {
  @override
  final Iterable<Type> types = const [
    Gcomment_pk_columns_input,
    _$Gcomment_pk_columns_input
  ];
  @override
  final String wireName = 'Gcomment_pk_columns_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gcomment_pk_columns_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'id',
      serializers.serialize(object.id, specifiedType: const FullType(String)),
    ];

    return result;
  }

  @override
  Gcomment_pk_columns_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gcomment_pk_columns_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(String))! as String;
          break;
      }
    }

    return result.build();
  }
}

class _$Gcomment_select_columnSerializer
    implements PrimitiveSerializer<Gcomment_select_column> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };

  @override
  final Iterable<Type> types = const <Type>[Gcomment_select_column];
  @override
  final String wireName = 'Gcomment_select_column';

  @override
  Object serialize(Serializers serializers, Gcomment_select_column object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Gcomment_select_column deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      Gcomment_select_column.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$Gcomment_set_inputSerializer
    implements StructuredSerializer<Gcomment_set_input> {
  @override
  final Iterable<Type> types = const [Gcomment_set_input, _$Gcomment_set_input];
  @override
  final String wireName = 'Gcomment_set_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gcomment_set_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.beacon_id;
    if (value != null) {
      result
        ..add('beacon_id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.content;
    if (value != null) {
      result
        ..add('content')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.user_id;
    if (value != null) {
      result
        ..add('user_id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  Gcomment_set_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gcomment_set_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'beacon_id':
          result.beacon_id = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'content':
          result.content = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'user_id':
          result.user_id = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gcomment_stream_cursor_inputSerializer
    implements StructuredSerializer<Gcomment_stream_cursor_input> {
  @override
  final Iterable<Type> types = const [
    Gcomment_stream_cursor_input,
    _$Gcomment_stream_cursor_input
  ];
  @override
  final String wireName = 'Gcomment_stream_cursor_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gcomment_stream_cursor_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'initial_value',
      serializers.serialize(object.initial_value,
          specifiedType: const FullType(Gcomment_stream_cursor_value_input)),
    ];
    Object? value;
    value = object.ordering;
    if (value != null) {
      result
        ..add('ordering')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gcursor_ordering)));
    }
    return result;
  }

  @override
  Gcomment_stream_cursor_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gcomment_stream_cursor_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'initial_value':
          result.initial_value.replace(serializers.deserialize(value,
                  specifiedType:
                      const FullType(Gcomment_stream_cursor_value_input))!
              as Gcomment_stream_cursor_value_input);
          break;
        case 'ordering':
          result.ordering = serializers.deserialize(value,
                  specifiedType: const FullType(Gcursor_ordering))
              as Gcursor_ordering?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gcomment_stream_cursor_value_inputSerializer
    implements StructuredSerializer<Gcomment_stream_cursor_value_input> {
  @override
  final Iterable<Type> types = const [
    Gcomment_stream_cursor_value_input,
    _$Gcomment_stream_cursor_value_input
  ];
  @override
  final String wireName = 'Gcomment_stream_cursor_value_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gcomment_stream_cursor_value_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.beacon_id;
    if (value != null) {
      result
        ..add('beacon_id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.content;
    if (value != null) {
      result
        ..add('content')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.user_id;
    if (value != null) {
      result
        ..add('user_id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  Gcomment_stream_cursor_value_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gcomment_stream_cursor_value_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'beacon_id':
          result.beacon_id = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'content':
          result.content = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'user_id':
          result.user_id = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gcomment_update_columnSerializer
    implements PrimitiveSerializer<Gcomment_update_column> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };

  @override
  final Iterable<Type> types = const <Type>[Gcomment_update_column];
  @override
  final String wireName = 'Gcomment_update_column';

  @override
  Object serialize(Serializers serializers, Gcomment_update_column object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Gcomment_update_column deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      Gcomment_update_column.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$Gcomment_updatesSerializer
    implements StructuredSerializer<Gcomment_updates> {
  @override
  final Iterable<Type> types = const [Gcomment_updates, _$Gcomment_updates];
  @override
  final String wireName = 'Gcomment_updates';

  @override
  Iterable<Object?> serialize(Serializers serializers, Gcomment_updates object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'where',
      serializers.serialize(object.where,
          specifiedType: const FullType(Gcomment_bool_exp)),
    ];
    Object? value;
    value = object.G_set;
    if (value != null) {
      result
        ..add('_set')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gcomment_set_input)));
    }
    return result;
  }

  @override
  Gcomment_updates deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gcomment_updatesBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case '_set':
          result.G_set.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gcomment_set_input))!
              as Gcomment_set_input);
          break;
        case 'where':
          result.where.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gcomment_bool_exp))!
              as Gcomment_bool_exp);
          break;
      }
    }

    return result.build();
  }
}

class _$Gcursor_orderingSerializer
    implements PrimitiveSerializer<Gcursor_ordering> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };

  @override
  final Iterable<Type> types = const <Type>[Gcursor_ordering];
  @override
  final String wireName = 'Gcursor_ordering';

  @override
  Object serialize(Serializers serializers, Gcursor_ordering object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Gcursor_ordering deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      Gcursor_ordering.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$Ggeography_cast_expSerializer
    implements StructuredSerializer<Ggeography_cast_exp> {
  @override
  final Iterable<Type> types = const [
    Ggeography_cast_exp,
    _$Ggeography_cast_exp
  ];
  @override
  final String wireName = 'Ggeography_cast_exp';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Ggeography_cast_exp object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.geometry;
    if (value != null) {
      result
        ..add('geometry')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Ggeometry_comparison_exp)));
    }
    return result;
  }

  @override
  Ggeography_cast_exp deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Ggeography_cast_expBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'geometry':
          result.geometry.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Ggeometry_comparison_exp))!
              as Ggeometry_comparison_exp);
          break;
      }
    }

    return result.build();
  }
}

class _$Ggeography_comparison_expSerializer
    implements StructuredSerializer<Ggeography_comparison_exp> {
  @override
  final Iterable<Type> types = const [
    Ggeography_comparison_exp,
    _$Ggeography_comparison_exp
  ];
  @override
  final String wireName = 'Ggeography_comparison_exp';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Ggeography_comparison_exp object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.G_cast;
    if (value != null) {
      result
        ..add('_cast')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Ggeography_cast_exp)));
    }
    value = object.G_eq;
    if (value != null) {
      result
        ..add('_eq')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(_i2.LatLng)));
    }
    value = object.G_gt;
    if (value != null) {
      result
        ..add('_gt')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(_i2.LatLng)));
    }
    value = object.G_gte;
    if (value != null) {
      result
        ..add('_gte')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(_i2.LatLng)));
    }
    value = object.G_in;
    if (value != null) {
      result
        ..add('_in')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(_i2.LatLng)])));
    }
    value = object.G_is_null;
    if (value != null) {
      result
        ..add('_is_null')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.G_lt;
    if (value != null) {
      result
        ..add('_lt')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(_i2.LatLng)));
    }
    value = object.G_lte;
    if (value != null) {
      result
        ..add('_lte')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(_i2.LatLng)));
    }
    value = object.G_neq;
    if (value != null) {
      result
        ..add('_neq')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(_i2.LatLng)));
    }
    value = object.G_nin;
    if (value != null) {
      result
        ..add('_nin')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(_i2.LatLng)])));
    }
    value = object.G_st_d_within;
    if (value != null) {
      result
        ..add('_st_d_within')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gst_d_within_geography_input)));
    }
    value = object.G_st_intersects;
    if (value != null) {
      result
        ..add('_st_intersects')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(_i2.LatLng)));
    }
    return result;
  }

  @override
  Ggeography_comparison_exp deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Ggeography_comparison_expBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case '_cast':
          result.G_cast.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Ggeography_cast_exp))!
              as Ggeography_cast_exp);
          break;
        case '_eq':
          result.G_eq = serializers.deserialize(value,
              specifiedType: const FullType(_i2.LatLng)) as _i2.LatLng?;
          break;
        case '_gt':
          result.G_gt = serializers.deserialize(value,
              specifiedType: const FullType(_i2.LatLng)) as _i2.LatLng?;
          break;
        case '_gte':
          result.G_gte = serializers.deserialize(value,
              specifiedType: const FullType(_i2.LatLng)) as _i2.LatLng?;
          break;
        case '_in':
          result.G_in.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(_i2.LatLng)]))!
              as BuiltList<Object?>);
          break;
        case '_is_null':
          result.G_is_null = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case '_lt':
          result.G_lt = serializers.deserialize(value,
              specifiedType: const FullType(_i2.LatLng)) as _i2.LatLng?;
          break;
        case '_lte':
          result.G_lte = serializers.deserialize(value,
              specifiedType: const FullType(_i2.LatLng)) as _i2.LatLng?;
          break;
        case '_neq':
          result.G_neq = serializers.deserialize(value,
              specifiedType: const FullType(_i2.LatLng)) as _i2.LatLng?;
          break;
        case '_nin':
          result.G_nin.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(_i2.LatLng)]))!
              as BuiltList<Object?>);
          break;
        case '_st_d_within':
          result.G_st_d_within.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gst_d_within_geography_input))!
              as Gst_d_within_geography_input);
          break;
        case '_st_intersects':
          result.G_st_intersects = serializers.deserialize(value,
              specifiedType: const FullType(_i2.LatLng)) as _i2.LatLng?;
          break;
      }
    }

    return result.build();
  }
}

class _$Ggeometry_cast_expSerializer
    implements StructuredSerializer<Ggeometry_cast_exp> {
  @override
  final Iterable<Type> types = const [Ggeometry_cast_exp, _$Ggeometry_cast_exp];
  @override
  final String wireName = 'Ggeometry_cast_exp';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Ggeometry_cast_exp object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.geography;
    if (value != null) {
      result
        ..add('geography')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Ggeography_comparison_exp)));
    }
    return result;
  }

  @override
  Ggeometry_cast_exp deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Ggeometry_cast_expBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'geography':
          result.geography.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Ggeography_comparison_exp))!
              as Ggeography_comparison_exp);
          break;
      }
    }

    return result.build();
  }
}

class _$Ggeometry_comparison_expSerializer
    implements StructuredSerializer<Ggeometry_comparison_exp> {
  @override
  final Iterable<Type> types = const [
    Ggeometry_comparison_exp,
    _$Ggeometry_comparison_exp
  ];
  @override
  final String wireName = 'Ggeometry_comparison_exp';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Ggeometry_comparison_exp object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.G_cast;
    if (value != null) {
      result
        ..add('_cast')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Ggeometry_cast_exp)));
    }
    value = object.G_eq;
    if (value != null) {
      result
        ..add('_eq')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Ggeometry)));
    }
    value = object.G_gt;
    if (value != null) {
      result
        ..add('_gt')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Ggeometry)));
    }
    value = object.G_gte;
    if (value != null) {
      result
        ..add('_gte')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Ggeometry)));
    }
    value = object.G_in;
    if (value != null) {
      result
        ..add('_in')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(Ggeometry)])));
    }
    value = object.G_is_null;
    if (value != null) {
      result
        ..add('_is_null')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.G_lt;
    if (value != null) {
      result
        ..add('_lt')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Ggeometry)));
    }
    value = object.G_lte;
    if (value != null) {
      result
        ..add('_lte')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Ggeometry)));
    }
    value = object.G_neq;
    if (value != null) {
      result
        ..add('_neq')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Ggeometry)));
    }
    value = object.G_nin;
    if (value != null) {
      result
        ..add('_nin')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(Ggeometry)])));
    }
    value = object.G_st_3d_d_within;
    if (value != null) {
      result
        ..add('_st_3d_d_within')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gst_d_within_input)));
    }
    value = object.G_st_3d_intersects;
    if (value != null) {
      result
        ..add('_st_3d_intersects')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Ggeometry)));
    }
    value = object.G_st_contains;
    if (value != null) {
      result
        ..add('_st_contains')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Ggeometry)));
    }
    value = object.G_st_crosses;
    if (value != null) {
      result
        ..add('_st_crosses')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Ggeometry)));
    }
    value = object.G_st_d_within;
    if (value != null) {
      result
        ..add('_st_d_within')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gst_d_within_input)));
    }
    value = object.G_st_equals;
    if (value != null) {
      result
        ..add('_st_equals')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Ggeometry)));
    }
    value = object.G_st_intersects;
    if (value != null) {
      result
        ..add('_st_intersects')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Ggeometry)));
    }
    value = object.G_st_overlaps;
    if (value != null) {
      result
        ..add('_st_overlaps')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Ggeometry)));
    }
    value = object.G_st_touches;
    if (value != null) {
      result
        ..add('_st_touches')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Ggeometry)));
    }
    value = object.G_st_within;
    if (value != null) {
      result
        ..add('_st_within')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Ggeometry)));
    }
    return result;
  }

  @override
  Ggeometry_comparison_exp deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Ggeometry_comparison_expBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case '_cast':
          result.G_cast.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Ggeometry_cast_exp))!
              as Ggeometry_cast_exp);
          break;
        case '_eq':
          result.G_eq.replace(serializers.deserialize(value,
              specifiedType: const FullType(Ggeometry))! as Ggeometry);
          break;
        case '_gt':
          result.G_gt.replace(serializers.deserialize(value,
              specifiedType: const FullType(Ggeometry))! as Ggeometry);
          break;
        case '_gte':
          result.G_gte.replace(serializers.deserialize(value,
              specifiedType: const FullType(Ggeometry))! as Ggeometry);
          break;
        case '_in':
          result.G_in.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(Ggeometry)]))!
              as BuiltList<Object?>);
          break;
        case '_is_null':
          result.G_is_null = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case '_lt':
          result.G_lt.replace(serializers.deserialize(value,
              specifiedType: const FullType(Ggeometry))! as Ggeometry);
          break;
        case '_lte':
          result.G_lte.replace(serializers.deserialize(value,
              specifiedType: const FullType(Ggeometry))! as Ggeometry);
          break;
        case '_neq':
          result.G_neq.replace(serializers.deserialize(value,
              specifiedType: const FullType(Ggeometry))! as Ggeometry);
          break;
        case '_nin':
          result.G_nin.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(Ggeometry)]))!
              as BuiltList<Object?>);
          break;
        case '_st_3d_d_within':
          result.G_st_3d_d_within.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gst_d_within_input))!
              as Gst_d_within_input);
          break;
        case '_st_3d_intersects':
          result.G_st_3d_intersects.replace(serializers.deserialize(value,
              specifiedType: const FullType(Ggeometry))! as Ggeometry);
          break;
        case '_st_contains':
          result.G_st_contains.replace(serializers.deserialize(value,
              specifiedType: const FullType(Ggeometry))! as Ggeometry);
          break;
        case '_st_crosses':
          result.G_st_crosses.replace(serializers.deserialize(value,
              specifiedType: const FullType(Ggeometry))! as Ggeometry);
          break;
        case '_st_d_within':
          result.G_st_d_within.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gst_d_within_input))!
              as Gst_d_within_input);
          break;
        case '_st_equals':
          result.G_st_equals.replace(serializers.deserialize(value,
              specifiedType: const FullType(Ggeometry))! as Ggeometry);
          break;
        case '_st_intersects':
          result.G_st_intersects.replace(serializers.deserialize(value,
              specifiedType: const FullType(Ggeometry))! as Ggeometry);
          break;
        case '_st_overlaps':
          result.G_st_overlaps.replace(serializers.deserialize(value,
              specifiedType: const FullType(Ggeometry))! as Ggeometry);
          break;
        case '_st_touches':
          result.G_st_touches.replace(serializers.deserialize(value,
              specifiedType: const FullType(Ggeometry))! as Ggeometry);
          break;
        case '_st_within':
          result.G_st_within.replace(serializers.deserialize(value,
              specifiedType: const FullType(Ggeometry))! as Ggeometry);
          break;
      }
    }

    return result.build();
  }
}

class _$GInt_comparison_expSerializer
    implements StructuredSerializer<GInt_comparison_exp> {
  @override
  final Iterable<Type> types = const [
    GInt_comparison_exp,
    _$GInt_comparison_exp
  ];
  @override
  final String wireName = 'GInt_comparison_exp';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GInt_comparison_exp object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.G_eq;
    if (value != null) {
      result
        ..add('_eq')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    value = object.G_gt;
    if (value != null) {
      result
        ..add('_gt')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    value = object.G_gte;
    if (value != null) {
      result
        ..add('_gte')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    value = object.G_in;
    if (value != null) {
      result
        ..add('_in')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(int)])));
    }
    value = object.G_is_null;
    if (value != null) {
      result
        ..add('_is_null')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.G_lt;
    if (value != null) {
      result
        ..add('_lt')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    value = object.G_lte;
    if (value != null) {
      result
        ..add('_lte')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    value = object.G_neq;
    if (value != null) {
      result
        ..add('_neq')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    value = object.G_nin;
    if (value != null) {
      result
        ..add('_nin')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(int)])));
    }
    return result;
  }

  @override
  GInt_comparison_exp deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GInt_comparison_expBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case '_eq':
          result.G_eq = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
        case '_gt':
          result.G_gt = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
        case '_gte':
          result.G_gte = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
        case '_in':
          result.G_in.replace(serializers.deserialize(value,
                  specifiedType:
                      const FullType(BuiltList, const [const FullType(int)]))!
              as BuiltList<Object?>);
          break;
        case '_is_null':
          result.G_is_null = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case '_lt':
          result.G_lt = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
        case '_lte':
          result.G_lte = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
        case '_neq':
          result.G_neq = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
        case '_nin':
          result.G_nin.replace(serializers.deserialize(value,
                  specifiedType:
                      const FullType(BuiltList, const [const FullType(int)]))!
              as BuiltList<Object?>);
          break;
      }
    }

    return result.build();
  }
}

class _$Gorder_bySerializer implements PrimitiveSerializer<Gorder_by> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };

  @override
  final Iterable<Type> types = const <Type>[Gorder_by];
  @override
  final String wireName = 'Gorder_by';

  @override
  Object serialize(Serializers serializers, Gorder_by object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Gorder_by deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      Gorder_by.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$Gst_d_within_geography_inputSerializer
    implements StructuredSerializer<Gst_d_within_geography_input> {
  @override
  final Iterable<Type> types = const [
    Gst_d_within_geography_input,
    _$Gst_d_within_geography_input
  ];
  @override
  final String wireName = 'Gst_d_within_geography_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gst_d_within_geography_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'distance',
      serializers.serialize(object.distance,
          specifiedType: const FullType(double)),
      'from',
      serializers.serialize(object.from,
          specifiedType: const FullType(_i2.LatLng)),
    ];
    Object? value;
    value = object.use_spheroid;
    if (value != null) {
      result
        ..add('use_spheroid')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    return result;
  }

  @override
  Gst_d_within_geography_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gst_d_within_geography_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'distance':
          result.distance = serializers.deserialize(value,
              specifiedType: const FullType(double))! as double;
          break;
        case 'from':
          result.from = serializers.deserialize(value,
              specifiedType: const FullType(_i2.LatLng))! as _i2.LatLng;
          break;
        case 'use_spheroid':
          result.use_spheroid = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gst_d_within_inputSerializer
    implements StructuredSerializer<Gst_d_within_input> {
  @override
  final Iterable<Type> types = const [Gst_d_within_input, _$Gst_d_within_input];
  @override
  final String wireName = 'Gst_d_within_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gst_d_within_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'distance',
      serializers.serialize(object.distance,
          specifiedType: const FullType(double)),
      'from',
      serializers.serialize(object.from,
          specifiedType: const FullType(Ggeometry)),
    ];

    return result;
  }

  @override
  Gst_d_within_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gst_d_within_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'distance':
          result.distance = serializers.deserialize(value,
              specifiedType: const FullType(double))! as double;
          break;
        case 'from':
          result.from.replace(serializers.deserialize(value,
              specifiedType: const FullType(Ggeometry))! as Ggeometry);
          break;
      }
    }

    return result.build();
  }
}

class _$GString_comparison_expSerializer
    implements StructuredSerializer<GString_comparison_exp> {
  @override
  final Iterable<Type> types = const [
    GString_comparison_exp,
    _$GString_comparison_exp
  ];
  @override
  final String wireName = 'GString_comparison_exp';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GString_comparison_exp object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.G_eq;
    if (value != null) {
      result
        ..add('_eq')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.G_gt;
    if (value != null) {
      result
        ..add('_gt')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.G_gte;
    if (value != null) {
      result
        ..add('_gte')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.G_ilike;
    if (value != null) {
      result
        ..add('_ilike')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.G_in;
    if (value != null) {
      result
        ..add('_in')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(String)])));
    }
    value = object.G_iregex;
    if (value != null) {
      result
        ..add('_iregex')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.G_is_null;
    if (value != null) {
      result
        ..add('_is_null')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.G_like;
    if (value != null) {
      result
        ..add('_like')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.G_lt;
    if (value != null) {
      result
        ..add('_lt')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.G_lte;
    if (value != null) {
      result
        ..add('_lte')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.G_neq;
    if (value != null) {
      result
        ..add('_neq')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.G_nilike;
    if (value != null) {
      result
        ..add('_nilike')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.G_nin;
    if (value != null) {
      result
        ..add('_nin')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(String)])));
    }
    value = object.G_niregex;
    if (value != null) {
      result
        ..add('_niregex')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.G_nlike;
    if (value != null) {
      result
        ..add('_nlike')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.G_nregex;
    if (value != null) {
      result
        ..add('_nregex')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.G_nsimilar;
    if (value != null) {
      result
        ..add('_nsimilar')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.G_regex;
    if (value != null) {
      result
        ..add('_regex')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.G_similar;
    if (value != null) {
      result
        ..add('_similar')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  GString_comparison_exp deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GString_comparison_expBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case '_eq':
          result.G_eq = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case '_gt':
          result.G_gt = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case '_gte':
          result.G_gte = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case '_ilike':
          result.G_ilike = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case '_in':
          result.G_in.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(String)]))!
              as BuiltList<Object?>);
          break;
        case '_iregex':
          result.G_iregex = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case '_is_null':
          result.G_is_null = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case '_like':
          result.G_like = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case '_lt':
          result.G_lt = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case '_lte':
          result.G_lte = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case '_neq':
          result.G_neq = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case '_nilike':
          result.G_nilike = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case '_nin':
          result.G_nin.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(String)]))!
              as BuiltList<Object?>);
          break;
        case '_niregex':
          result.G_niregex = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case '_nlike':
          result.G_nlike = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case '_nregex':
          result.G_nregex = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case '_nsimilar':
          result.G_nsimilar = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case '_regex':
          result.G_regex = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case '_similar':
          result.G_similar = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gtimestamptz_comparison_expSerializer
    implements StructuredSerializer<Gtimestamptz_comparison_exp> {
  @override
  final Iterable<Type> types = const [
    Gtimestamptz_comparison_exp,
    _$Gtimestamptz_comparison_exp
  ];
  @override
  final String wireName = 'Gtimestamptz_comparison_exp';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gtimestamptz_comparison_exp object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.G_eq;
    if (value != null) {
      result
        ..add('_eq')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.G_gt;
    if (value != null) {
      result
        ..add('_gt')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.G_gte;
    if (value != null) {
      result
        ..add('_gte')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.G_in;
    if (value != null) {
      result
        ..add('_in')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(DateTime)])));
    }
    value = object.G_is_null;
    if (value != null) {
      result
        ..add('_is_null')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.G_lt;
    if (value != null) {
      result
        ..add('_lt')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.G_lte;
    if (value != null) {
      result
        ..add('_lte')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.G_neq;
    if (value != null) {
      result
        ..add('_neq')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.G_nin;
    if (value != null) {
      result
        ..add('_nin')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(DateTime)])));
    }
    return result;
  }

  @override
  Gtimestamptz_comparison_exp deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gtimestamptz_comparison_expBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case '_eq':
          result.G_eq = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case '_gt':
          result.G_gt = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case '_gte':
          result.G_gte = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case '_in':
          result.G_in.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(DateTime)]))!
              as BuiltList<Object?>);
          break;
        case '_is_null':
          result.G_is_null = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case '_lt':
          result.G_lt = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case '_lte':
          result.G_lte = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case '_neq':
          result.G_neq = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case '_nin':
          result.G_nin.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(DateTime)]))!
              as BuiltList<Object?>);
          break;
      }
    }

    return result.build();
  }
}

class _$Gtstzrange_comparison_expSerializer
    implements StructuredSerializer<Gtstzrange_comparison_exp> {
  @override
  final Iterable<Type> types = const [
    Gtstzrange_comparison_exp,
    _$Gtstzrange_comparison_exp
  ];
  @override
  final String wireName = 'Gtstzrange_comparison_exp';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gtstzrange_comparison_exp object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.G_eq;
    if (value != null) {
      result
        ..add('_eq')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(_i3.DateTimeRange)));
    }
    value = object.G_gt;
    if (value != null) {
      result
        ..add('_gt')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(_i3.DateTimeRange)));
    }
    value = object.G_gte;
    if (value != null) {
      result
        ..add('_gte')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(_i3.DateTimeRange)));
    }
    value = object.G_in;
    if (value != null) {
      result
        ..add('_in')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(_i3.DateTimeRange)])));
    }
    value = object.G_is_null;
    if (value != null) {
      result
        ..add('_is_null')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.G_lt;
    if (value != null) {
      result
        ..add('_lt')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(_i3.DateTimeRange)));
    }
    value = object.G_lte;
    if (value != null) {
      result
        ..add('_lte')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(_i3.DateTimeRange)));
    }
    value = object.G_neq;
    if (value != null) {
      result
        ..add('_neq')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(_i3.DateTimeRange)));
    }
    value = object.G_nin;
    if (value != null) {
      result
        ..add('_nin')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(_i3.DateTimeRange)])));
    }
    return result;
  }

  @override
  Gtstzrange_comparison_exp deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gtstzrange_comparison_expBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case '_eq':
          result.G_eq = serializers.deserialize(value,
                  specifiedType: const FullType(_i3.DateTimeRange))
              as _i3.DateTimeRange?;
          break;
        case '_gt':
          result.G_gt = serializers.deserialize(value,
                  specifiedType: const FullType(_i3.DateTimeRange))
              as _i3.DateTimeRange?;
          break;
        case '_gte':
          result.G_gte = serializers.deserialize(value,
                  specifiedType: const FullType(_i3.DateTimeRange))
              as _i3.DateTimeRange?;
          break;
        case '_in':
          result.G_in.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(_i3.DateTimeRange)]))!
              as BuiltList<Object?>);
          break;
        case '_is_null':
          result.G_is_null = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case '_lt':
          result.G_lt = serializers.deserialize(value,
                  specifiedType: const FullType(_i3.DateTimeRange))
              as _i3.DateTimeRange?;
          break;
        case '_lte':
          result.G_lte = serializers.deserialize(value,
                  specifiedType: const FullType(_i3.DateTimeRange))
              as _i3.DateTimeRange?;
          break;
        case '_neq':
          result.G_neq = serializers.deserialize(value,
                  specifiedType: const FullType(_i3.DateTimeRange))
              as _i3.DateTimeRange?;
          break;
        case '_nin':
          result.G_nin.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(_i3.DateTimeRange)]))!
              as BuiltList<Object?>);
          break;
      }
    }

    return result.build();
  }
}

class _$Guser_bool_expSerializer
    implements StructuredSerializer<Guser_bool_exp> {
  @override
  final Iterable<Type> types = const [Guser_bool_exp, _$Guser_bool_exp];
  @override
  final String wireName = 'Guser_bool_exp';

  @override
  Iterable<Object?> serialize(Serializers serializers, Guser_bool_exp object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.G_and;
    if (value != null) {
      result
        ..add('_and')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(Guser_bool_exp)])));
    }
    value = object.G_not;
    if (value != null) {
      result
        ..add('_not')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Guser_bool_exp)));
    }
    value = object.G_or;
    if (value != null) {
      result
        ..add('_or')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(Guser_bool_exp)])));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gtimestamptz_comparison_exp)));
    }
    value = object.description;
    if (value != null) {
      result
        ..add('description')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GString_comparison_exp)));
    }
    value = object.has_picture;
    if (value != null) {
      result
        ..add('has_picture')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GBoolean_comparison_exp)));
    }
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GString_comparison_exp)));
    }
    value = object.title;
    if (value != null) {
      result
        ..add('title')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GString_comparison_exp)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gtimestamptz_comparison_exp)));
    }
    return result;
  }

  @override
  Guser_bool_exp deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Guser_bool_expBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case '_and':
          result.G_and.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(Guser_bool_exp)]))!
              as BuiltList<Object?>);
          break;
        case '_not':
          result.G_not.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Guser_bool_exp))!
              as Guser_bool_exp);
          break;
        case '_or':
          result.G_or.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(Guser_bool_exp)]))!
              as BuiltList<Object?>);
          break;
        case 'created_at':
          result.created_at.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gtimestamptz_comparison_exp))!
              as Gtimestamptz_comparison_exp);
          break;
        case 'description':
          result.description.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GString_comparison_exp))!
              as GString_comparison_exp);
          break;
        case 'has_picture':
          result.has_picture.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GBoolean_comparison_exp))!
              as GBoolean_comparison_exp);
          break;
        case 'id':
          result.id.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GString_comparison_exp))!
              as GString_comparison_exp);
          break;
        case 'title':
          result.title.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GString_comparison_exp))!
              as GString_comparison_exp);
          break;
        case 'updated_at':
          result.updated_at.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gtimestamptz_comparison_exp))!
              as Gtimestamptz_comparison_exp);
          break;
      }
    }

    return result.build();
  }
}

class _$Guser_constraintSerializer
    implements PrimitiveSerializer<Guser_constraint> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };

  @override
  final Iterable<Type> types = const <Type>[Guser_constraint];
  @override
  final String wireName = 'Guser_constraint';

  @override
  Object serialize(Serializers serializers, Guser_constraint object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Guser_constraint deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      Guser_constraint.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$Guser_insert_inputSerializer
    implements StructuredSerializer<Guser_insert_input> {
  @override
  final Iterable<Type> types = const [Guser_insert_input, _$Guser_insert_input];
  @override
  final String wireName = 'Guser_insert_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Guser_insert_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.description;
    if (value != null) {
      result
        ..add('description')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.has_picture;
    if (value != null) {
      result
        ..add('has_picture')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.title;
    if (value != null) {
      result
        ..add('title')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    return result;
  }

  @override
  Guser_insert_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Guser_insert_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case 'description':
          result.description = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'has_picture':
          result.has_picture = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'title':
          result.title = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'updated_at':
          result.updated_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
      }
    }

    return result.build();
  }
}

class _$Guser_obj_rel_insert_inputSerializer
    implements StructuredSerializer<Guser_obj_rel_insert_input> {
  @override
  final Iterable<Type> types = const [
    Guser_obj_rel_insert_input,
    _$Guser_obj_rel_insert_input
  ];
  @override
  final String wireName = 'Guser_obj_rel_insert_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Guser_obj_rel_insert_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'data',
      serializers.serialize(object.data,
          specifiedType: const FullType(Guser_insert_input)),
    ];
    Object? value;
    value = object.on_conflict;
    if (value != null) {
      result
        ..add('on_conflict')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Guser_on_conflict)));
    }
    return result;
  }

  @override
  Guser_obj_rel_insert_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Guser_obj_rel_insert_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'data':
          result.data.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Guser_insert_input))!
              as Guser_insert_input);
          break;
        case 'on_conflict':
          result.on_conflict.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Guser_on_conflict))!
              as Guser_on_conflict);
          break;
      }
    }

    return result.build();
  }
}

class _$Guser_on_conflictSerializer
    implements StructuredSerializer<Guser_on_conflict> {
  @override
  final Iterable<Type> types = const [Guser_on_conflict, _$Guser_on_conflict];
  @override
  final String wireName = 'Guser_on_conflict';

  @override
  Iterable<Object?> serialize(Serializers serializers, Guser_on_conflict object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'constraint',
      serializers.serialize(object.constraint,
          specifiedType: const FullType(Guser_constraint)),
      'update_columns',
      serializers.serialize(object.update_columns,
          specifiedType: const FullType(
              BuiltList, const [const FullType(Guser_update_column)])),
    ];
    Object? value;
    value = object.where;
    if (value != null) {
      result
        ..add('where')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Guser_bool_exp)));
    }
    return result;
  }

  @override
  Guser_on_conflict deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Guser_on_conflictBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'constraint':
          result.constraint = serializers.deserialize(value,
                  specifiedType: const FullType(Guser_constraint))!
              as Guser_constraint;
          break;
        case 'update_columns':
          result.update_columns.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(Guser_update_column)]))!
              as BuiltList<Object?>);
          break;
        case 'where':
          result.where.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Guser_bool_exp))!
              as Guser_bool_exp);
          break;
      }
    }

    return result.build();
  }
}

class _$Guser_order_bySerializer
    implements StructuredSerializer<Guser_order_by> {
  @override
  final Iterable<Type> types = const [Guser_order_by, _$Guser_order_by];
  @override
  final String wireName = 'Guser_order_by';

  @override
  Iterable<Object?> serialize(Serializers serializers, Guser_order_by object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.description;
    if (value != null) {
      result
        ..add('description')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.has_picture;
    if (value != null) {
      result
        ..add('has_picture')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.title;
    if (value != null) {
      result
        ..add('title')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    return result;
  }

  @override
  Guser_order_by deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Guser_order_byBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'description':
          result.description = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'has_picture':
          result.has_picture = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'title':
          result.title = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'updated_at':
          result.updated_at = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
      }
    }

    return result.build();
  }
}

class _$Guser_pk_columns_inputSerializer
    implements StructuredSerializer<Guser_pk_columns_input> {
  @override
  final Iterable<Type> types = const [
    Guser_pk_columns_input,
    _$Guser_pk_columns_input
  ];
  @override
  final String wireName = 'Guser_pk_columns_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Guser_pk_columns_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'id',
      serializers.serialize(object.id, specifiedType: const FullType(String)),
    ];

    return result;
  }

  @override
  Guser_pk_columns_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Guser_pk_columns_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(String))! as String;
          break;
      }
    }

    return result.build();
  }
}

class _$Guser_select_columnSerializer
    implements PrimitiveSerializer<Guser_select_column> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };

  @override
  final Iterable<Type> types = const <Type>[Guser_select_column];
  @override
  final String wireName = 'Guser_select_column';

  @override
  Object serialize(Serializers serializers, Guser_select_column object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Guser_select_column deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      Guser_select_column.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$Guser_set_inputSerializer
    implements StructuredSerializer<Guser_set_input> {
  @override
  final Iterable<Type> types = const [Guser_set_input, _$Guser_set_input];
  @override
  final String wireName = 'Guser_set_input';

  @override
  Iterable<Object?> serialize(Serializers serializers, Guser_set_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.description;
    if (value != null) {
      result
        ..add('description')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.has_picture;
    if (value != null) {
      result
        ..add('has_picture')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.title;
    if (value != null) {
      result
        ..add('title')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    return result;
  }

  @override
  Guser_set_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Guser_set_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case 'description':
          result.description = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'has_picture':
          result.has_picture = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'title':
          result.title = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'updated_at':
          result.updated_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
      }
    }

    return result.build();
  }
}

class _$Guser_stream_cursor_inputSerializer
    implements StructuredSerializer<Guser_stream_cursor_input> {
  @override
  final Iterable<Type> types = const [
    Guser_stream_cursor_input,
    _$Guser_stream_cursor_input
  ];
  @override
  final String wireName = 'Guser_stream_cursor_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Guser_stream_cursor_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'initial_value',
      serializers.serialize(object.initial_value,
          specifiedType: const FullType(Guser_stream_cursor_value_input)),
    ];
    Object? value;
    value = object.ordering;
    if (value != null) {
      result
        ..add('ordering')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gcursor_ordering)));
    }
    return result;
  }

  @override
  Guser_stream_cursor_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Guser_stream_cursor_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'initial_value':
          result.initial_value.replace(serializers.deserialize(value,
                  specifiedType:
                      const FullType(Guser_stream_cursor_value_input))!
              as Guser_stream_cursor_value_input);
          break;
        case 'ordering':
          result.ordering = serializers.deserialize(value,
                  specifiedType: const FullType(Gcursor_ordering))
              as Gcursor_ordering?;
          break;
      }
    }

    return result.build();
  }
}

class _$Guser_stream_cursor_value_inputSerializer
    implements StructuredSerializer<Guser_stream_cursor_value_input> {
  @override
  final Iterable<Type> types = const [
    Guser_stream_cursor_value_input,
    _$Guser_stream_cursor_value_input
  ];
  @override
  final String wireName = 'Guser_stream_cursor_value_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Guser_stream_cursor_value_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.description;
    if (value != null) {
      result
        ..add('description')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.has_picture;
    if (value != null) {
      result
        ..add('has_picture')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.title;
    if (value != null) {
      result
        ..add('title')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    return result;
  }

  @override
  Guser_stream_cursor_value_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Guser_stream_cursor_value_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case 'description':
          result.description = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'has_picture':
          result.has_picture = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'title':
          result.title = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'updated_at':
          result.updated_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
      }
    }

    return result.build();
  }
}

class _$Guser_update_columnSerializer
    implements PrimitiveSerializer<Guser_update_column> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };

  @override
  final Iterable<Type> types = const <Type>[Guser_update_column];
  @override
  final String wireName = 'Guser_update_column';

  @override
  Object serialize(Serializers serializers, Guser_update_column object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Guser_update_column deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      Guser_update_column.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$Guser_updatesSerializer implements StructuredSerializer<Guser_updates> {
  @override
  final Iterable<Type> types = const [Guser_updates, _$Guser_updates];
  @override
  final String wireName = 'Guser_updates';

  @override
  Iterable<Object?> serialize(Serializers serializers, Guser_updates object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'where',
      serializers.serialize(object.where,
          specifiedType: const FullType(Guser_bool_exp)),
    ];
    Object? value;
    value = object.G_set;
    if (value != null) {
      result
        ..add('_set')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Guser_set_input)));
    }
    return result;
  }

  @override
  Guser_updates deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Guser_updatesBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case '_set':
          result.G_set.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Guser_set_input))!
              as Guser_set_input);
          break;
        case 'where':
          result.where.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Guser_bool_exp))!
              as Guser_bool_exp);
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_beacon_bool_expSerializer
    implements StructuredSerializer<Gvote_beacon_bool_exp> {
  @override
  final Iterable<Type> types = const [
    Gvote_beacon_bool_exp,
    _$Gvote_beacon_bool_exp
  ];
  @override
  final String wireName = 'Gvote_beacon_bool_exp';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_beacon_bool_exp object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.G_and;
    if (value != null) {
      result
        ..add('_and')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(Gvote_beacon_bool_exp)])));
    }
    value = object.G_not;
    if (value != null) {
      result
        ..add('_not')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gvote_beacon_bool_exp)));
    }
    value = object.G_or;
    if (value != null) {
      result
        ..add('_or')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(Gvote_beacon_bool_exp)])));
    }
    value = object.amount;
    if (value != null) {
      result
        ..add('amount')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GInt_comparison_exp)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gtimestamptz_comparison_exp)));
    }
    value = object.object;
    if (value != null) {
      result
        ..add('object')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GString_comparison_exp)));
    }
    value = object.subject;
    if (value != null) {
      result
        ..add('subject')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GString_comparison_exp)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gtimestamptz_comparison_exp)));
    }
    return result;
  }

  @override
  Gvote_beacon_bool_exp deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_beacon_bool_expBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case '_and':
          result.G_and.replace(serializers.deserialize(value,
              specifiedType: const FullType(BuiltList, const [
                const FullType(Gvote_beacon_bool_exp)
              ]))! as BuiltList<Object?>);
          break;
        case '_not':
          result.G_not.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gvote_beacon_bool_exp))!
              as Gvote_beacon_bool_exp);
          break;
        case '_or':
          result.G_or.replace(serializers.deserialize(value,
              specifiedType: const FullType(BuiltList, const [
                const FullType(Gvote_beacon_bool_exp)
              ]))! as BuiltList<Object?>);
          break;
        case 'amount':
          result.amount.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GInt_comparison_exp))!
              as GInt_comparison_exp);
          break;
        case 'created_at':
          result.created_at.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gtimestamptz_comparison_exp))!
              as Gtimestamptz_comparison_exp);
          break;
        case 'object':
          result.object.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GString_comparison_exp))!
              as GString_comparison_exp);
          break;
        case 'subject':
          result.subject.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GString_comparison_exp))!
              as GString_comparison_exp);
          break;
        case 'updated_at':
          result.updated_at.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gtimestamptz_comparison_exp))!
              as Gtimestamptz_comparison_exp);
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_beacon_constraintSerializer
    implements PrimitiveSerializer<Gvote_beacon_constraint> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };

  @override
  final Iterable<Type> types = const <Type>[Gvote_beacon_constraint];
  @override
  final String wireName = 'Gvote_beacon_constraint';

  @override
  Object serialize(Serializers serializers, Gvote_beacon_constraint object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Gvote_beacon_constraint deserialize(
          Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      Gvote_beacon_constraint.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$Gvote_beacon_inc_inputSerializer
    implements StructuredSerializer<Gvote_beacon_inc_input> {
  @override
  final Iterable<Type> types = const [
    Gvote_beacon_inc_input,
    _$Gvote_beacon_inc_input
  ];
  @override
  final String wireName = 'Gvote_beacon_inc_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_beacon_inc_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.amount;
    if (value != null) {
      result
        ..add('amount')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    return result;
  }

  @override
  Gvote_beacon_inc_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_beacon_inc_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'amount':
          result.amount = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_beacon_insert_inputSerializer
    implements StructuredSerializer<Gvote_beacon_insert_input> {
  @override
  final Iterable<Type> types = const [
    Gvote_beacon_insert_input,
    _$Gvote_beacon_insert_input
  ];
  @override
  final String wireName = 'Gvote_beacon_insert_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_beacon_insert_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.amount;
    if (value != null) {
      result
        ..add('amount')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.object;
    if (value != null) {
      result
        ..add('object')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.subject;
    if (value != null) {
      result
        ..add('subject')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    return result;
  }

  @override
  Gvote_beacon_insert_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_beacon_insert_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'amount':
          result.amount = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case 'object':
          result.object = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'subject':
          result.subject = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'updated_at':
          result.updated_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_beacon_on_conflictSerializer
    implements StructuredSerializer<Gvote_beacon_on_conflict> {
  @override
  final Iterable<Type> types = const [
    Gvote_beacon_on_conflict,
    _$Gvote_beacon_on_conflict
  ];
  @override
  final String wireName = 'Gvote_beacon_on_conflict';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_beacon_on_conflict object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'constraint',
      serializers.serialize(object.constraint,
          specifiedType: const FullType(Gvote_beacon_constraint)),
      'update_columns',
      serializers.serialize(object.update_columns,
          specifiedType: const FullType(
              BuiltList, const [const FullType(Gvote_beacon_update_column)])),
    ];
    Object? value;
    value = object.where;
    if (value != null) {
      result
        ..add('where')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gvote_beacon_bool_exp)));
    }
    return result;
  }

  @override
  Gvote_beacon_on_conflict deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_beacon_on_conflictBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'constraint':
          result.constraint = serializers.deserialize(value,
                  specifiedType: const FullType(Gvote_beacon_constraint))!
              as Gvote_beacon_constraint;
          break;
        case 'update_columns':
          result.update_columns.replace(serializers.deserialize(value,
              specifiedType: const FullType(BuiltList, const [
                const FullType(Gvote_beacon_update_column)
              ]))! as BuiltList<Object?>);
          break;
        case 'where':
          result.where.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gvote_beacon_bool_exp))!
              as Gvote_beacon_bool_exp);
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_beacon_order_bySerializer
    implements StructuredSerializer<Gvote_beacon_order_by> {
  @override
  final Iterable<Type> types = const [
    Gvote_beacon_order_by,
    _$Gvote_beacon_order_by
  ];
  @override
  final String wireName = 'Gvote_beacon_order_by';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_beacon_order_by object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.amount;
    if (value != null) {
      result
        ..add('amount')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.object;
    if (value != null) {
      result
        ..add('object')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.subject;
    if (value != null) {
      result
        ..add('subject')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    return result;
  }

  @override
  Gvote_beacon_order_by deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_beacon_order_byBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'amount':
          result.amount = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'object':
          result.object = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'subject':
          result.subject = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'updated_at':
          result.updated_at = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_beacon_pk_columns_inputSerializer
    implements StructuredSerializer<Gvote_beacon_pk_columns_input> {
  @override
  final Iterable<Type> types = const [
    Gvote_beacon_pk_columns_input,
    _$Gvote_beacon_pk_columns_input
  ];
  @override
  final String wireName = 'Gvote_beacon_pk_columns_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_beacon_pk_columns_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'object',
      serializers.serialize(object.object,
          specifiedType: const FullType(String)),
      'subject',
      serializers.serialize(object.subject,
          specifiedType: const FullType(String)),
    ];

    return result;
  }

  @override
  Gvote_beacon_pk_columns_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_beacon_pk_columns_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'object':
          result.object = serializers.deserialize(value,
              specifiedType: const FullType(String))! as String;
          break;
        case 'subject':
          result.subject = serializers.deserialize(value,
              specifiedType: const FullType(String))! as String;
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_beacon_select_columnSerializer
    implements PrimitiveSerializer<Gvote_beacon_select_column> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };

  @override
  final Iterable<Type> types = const <Type>[Gvote_beacon_select_column];
  @override
  final String wireName = 'Gvote_beacon_select_column';

  @override
  Object serialize(Serializers serializers, Gvote_beacon_select_column object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Gvote_beacon_select_column deserialize(
          Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      Gvote_beacon_select_column.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$Gvote_beacon_set_inputSerializer
    implements StructuredSerializer<Gvote_beacon_set_input> {
  @override
  final Iterable<Type> types = const [
    Gvote_beacon_set_input,
    _$Gvote_beacon_set_input
  ];
  @override
  final String wireName = 'Gvote_beacon_set_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_beacon_set_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.amount;
    if (value != null) {
      result
        ..add('amount')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.object;
    if (value != null) {
      result
        ..add('object')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.subject;
    if (value != null) {
      result
        ..add('subject')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    return result;
  }

  @override
  Gvote_beacon_set_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_beacon_set_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'amount':
          result.amount = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case 'object':
          result.object = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'subject':
          result.subject = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'updated_at':
          result.updated_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_beacon_stream_cursor_inputSerializer
    implements StructuredSerializer<Gvote_beacon_stream_cursor_input> {
  @override
  final Iterable<Type> types = const [
    Gvote_beacon_stream_cursor_input,
    _$Gvote_beacon_stream_cursor_input
  ];
  @override
  final String wireName = 'Gvote_beacon_stream_cursor_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_beacon_stream_cursor_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'initial_value',
      serializers.serialize(object.initial_value,
          specifiedType:
              const FullType(Gvote_beacon_stream_cursor_value_input)),
    ];
    Object? value;
    value = object.ordering;
    if (value != null) {
      result
        ..add('ordering')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gcursor_ordering)));
    }
    return result;
  }

  @override
  Gvote_beacon_stream_cursor_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_beacon_stream_cursor_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'initial_value':
          result.initial_value.replace(serializers.deserialize(value,
                  specifiedType:
                      const FullType(Gvote_beacon_stream_cursor_value_input))!
              as Gvote_beacon_stream_cursor_value_input);
          break;
        case 'ordering':
          result.ordering = serializers.deserialize(value,
                  specifiedType: const FullType(Gcursor_ordering))
              as Gcursor_ordering?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_beacon_stream_cursor_value_inputSerializer
    implements StructuredSerializer<Gvote_beacon_stream_cursor_value_input> {
  @override
  final Iterable<Type> types = const [
    Gvote_beacon_stream_cursor_value_input,
    _$Gvote_beacon_stream_cursor_value_input
  ];
  @override
  final String wireName = 'Gvote_beacon_stream_cursor_value_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_beacon_stream_cursor_value_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.amount;
    if (value != null) {
      result
        ..add('amount')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.object;
    if (value != null) {
      result
        ..add('object')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.subject;
    if (value != null) {
      result
        ..add('subject')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    return result;
  }

  @override
  Gvote_beacon_stream_cursor_value_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_beacon_stream_cursor_value_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'amount':
          result.amount = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case 'object':
          result.object = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'subject':
          result.subject = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'updated_at':
          result.updated_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_beacon_update_columnSerializer
    implements PrimitiveSerializer<Gvote_beacon_update_column> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };

  @override
  final Iterable<Type> types = const <Type>[Gvote_beacon_update_column];
  @override
  final String wireName = 'Gvote_beacon_update_column';

  @override
  Object serialize(Serializers serializers, Gvote_beacon_update_column object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Gvote_beacon_update_column deserialize(
          Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      Gvote_beacon_update_column.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$Gvote_beacon_updatesSerializer
    implements StructuredSerializer<Gvote_beacon_updates> {
  @override
  final Iterable<Type> types = const [
    Gvote_beacon_updates,
    _$Gvote_beacon_updates
  ];
  @override
  final String wireName = 'Gvote_beacon_updates';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_beacon_updates object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'where',
      serializers.serialize(object.where,
          specifiedType: const FullType(Gvote_beacon_bool_exp)),
    ];
    Object? value;
    value = object.G_inc;
    if (value != null) {
      result
        ..add('_inc')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gvote_beacon_inc_input)));
    }
    value = object.G_set;
    if (value != null) {
      result
        ..add('_set')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gvote_beacon_set_input)));
    }
    return result;
  }

  @override
  Gvote_beacon_updates deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_beacon_updatesBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case '_inc':
          result.G_inc.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gvote_beacon_inc_input))!
              as Gvote_beacon_inc_input);
          break;
        case '_set':
          result.G_set.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gvote_beacon_set_input))!
              as Gvote_beacon_set_input);
          break;
        case 'where':
          result.where.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gvote_beacon_bool_exp))!
              as Gvote_beacon_bool_exp);
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_comment_bool_expSerializer
    implements StructuredSerializer<Gvote_comment_bool_exp> {
  @override
  final Iterable<Type> types = const [
    Gvote_comment_bool_exp,
    _$Gvote_comment_bool_exp
  ];
  @override
  final String wireName = 'Gvote_comment_bool_exp';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_comment_bool_exp object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.G_and;
    if (value != null) {
      result
        ..add('_and')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(Gvote_comment_bool_exp)])));
    }
    value = object.G_not;
    if (value != null) {
      result
        ..add('_not')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gvote_comment_bool_exp)));
    }
    value = object.G_or;
    if (value != null) {
      result
        ..add('_or')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(Gvote_comment_bool_exp)])));
    }
    value = object.amount;
    if (value != null) {
      result
        ..add('amount')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GInt_comparison_exp)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gtimestamptz_comparison_exp)));
    }
    value = object.object;
    if (value != null) {
      result
        ..add('object')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GString_comparison_exp)));
    }
    value = object.subject;
    if (value != null) {
      result
        ..add('subject')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GString_comparison_exp)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gtimestamptz_comparison_exp)));
    }
    return result;
  }

  @override
  Gvote_comment_bool_exp deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_comment_bool_expBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case '_and':
          result.G_and.replace(serializers.deserialize(value,
              specifiedType: const FullType(BuiltList, const [
                const FullType(Gvote_comment_bool_exp)
              ]))! as BuiltList<Object?>);
          break;
        case '_not':
          result.G_not.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gvote_comment_bool_exp))!
              as Gvote_comment_bool_exp);
          break;
        case '_or':
          result.G_or.replace(serializers.deserialize(value,
              specifiedType: const FullType(BuiltList, const [
                const FullType(Gvote_comment_bool_exp)
              ]))! as BuiltList<Object?>);
          break;
        case 'amount':
          result.amount.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GInt_comparison_exp))!
              as GInt_comparison_exp);
          break;
        case 'created_at':
          result.created_at.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gtimestamptz_comparison_exp))!
              as Gtimestamptz_comparison_exp);
          break;
        case 'object':
          result.object.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GString_comparison_exp))!
              as GString_comparison_exp);
          break;
        case 'subject':
          result.subject.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GString_comparison_exp))!
              as GString_comparison_exp);
          break;
        case 'updated_at':
          result.updated_at.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gtimestamptz_comparison_exp))!
              as Gtimestamptz_comparison_exp);
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_comment_constraintSerializer
    implements PrimitiveSerializer<Gvote_comment_constraint> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };

  @override
  final Iterable<Type> types = const <Type>[Gvote_comment_constraint];
  @override
  final String wireName = 'Gvote_comment_constraint';

  @override
  Object serialize(Serializers serializers, Gvote_comment_constraint object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Gvote_comment_constraint deserialize(
          Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      Gvote_comment_constraint.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$Gvote_comment_inc_inputSerializer
    implements StructuredSerializer<Gvote_comment_inc_input> {
  @override
  final Iterable<Type> types = const [
    Gvote_comment_inc_input,
    _$Gvote_comment_inc_input
  ];
  @override
  final String wireName = 'Gvote_comment_inc_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_comment_inc_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.amount;
    if (value != null) {
      result
        ..add('amount')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    return result;
  }

  @override
  Gvote_comment_inc_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_comment_inc_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'amount':
          result.amount = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_comment_insert_inputSerializer
    implements StructuredSerializer<Gvote_comment_insert_input> {
  @override
  final Iterable<Type> types = const [
    Gvote_comment_insert_input,
    _$Gvote_comment_insert_input
  ];
  @override
  final String wireName = 'Gvote_comment_insert_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_comment_insert_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.amount;
    if (value != null) {
      result
        ..add('amount')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.object;
    if (value != null) {
      result
        ..add('object')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.subject;
    if (value != null) {
      result
        ..add('subject')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    return result;
  }

  @override
  Gvote_comment_insert_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_comment_insert_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'amount':
          result.amount = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case 'object':
          result.object = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'subject':
          result.subject = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'updated_at':
          result.updated_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_comment_on_conflictSerializer
    implements StructuredSerializer<Gvote_comment_on_conflict> {
  @override
  final Iterable<Type> types = const [
    Gvote_comment_on_conflict,
    _$Gvote_comment_on_conflict
  ];
  @override
  final String wireName = 'Gvote_comment_on_conflict';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_comment_on_conflict object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'constraint',
      serializers.serialize(object.constraint,
          specifiedType: const FullType(Gvote_comment_constraint)),
      'update_columns',
      serializers.serialize(object.update_columns,
          specifiedType: const FullType(
              BuiltList, const [const FullType(Gvote_comment_update_column)])),
    ];
    Object? value;
    value = object.where;
    if (value != null) {
      result
        ..add('where')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gvote_comment_bool_exp)));
    }
    return result;
  }

  @override
  Gvote_comment_on_conflict deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_comment_on_conflictBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'constraint':
          result.constraint = serializers.deserialize(value,
                  specifiedType: const FullType(Gvote_comment_constraint))!
              as Gvote_comment_constraint;
          break;
        case 'update_columns':
          result.update_columns.replace(serializers.deserialize(value,
              specifiedType: const FullType(BuiltList, const [
                const FullType(Gvote_comment_update_column)
              ]))! as BuiltList<Object?>);
          break;
        case 'where':
          result.where.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gvote_comment_bool_exp))!
              as Gvote_comment_bool_exp);
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_comment_order_bySerializer
    implements StructuredSerializer<Gvote_comment_order_by> {
  @override
  final Iterable<Type> types = const [
    Gvote_comment_order_by,
    _$Gvote_comment_order_by
  ];
  @override
  final String wireName = 'Gvote_comment_order_by';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_comment_order_by object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.amount;
    if (value != null) {
      result
        ..add('amount')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.object;
    if (value != null) {
      result
        ..add('object')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.subject;
    if (value != null) {
      result
        ..add('subject')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    return result;
  }

  @override
  Gvote_comment_order_by deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_comment_order_byBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'amount':
          result.amount = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'object':
          result.object = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'subject':
          result.subject = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'updated_at':
          result.updated_at = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_comment_pk_columns_inputSerializer
    implements StructuredSerializer<Gvote_comment_pk_columns_input> {
  @override
  final Iterable<Type> types = const [
    Gvote_comment_pk_columns_input,
    _$Gvote_comment_pk_columns_input
  ];
  @override
  final String wireName = 'Gvote_comment_pk_columns_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_comment_pk_columns_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'object',
      serializers.serialize(object.object,
          specifiedType: const FullType(String)),
      'subject',
      serializers.serialize(object.subject,
          specifiedType: const FullType(String)),
    ];

    return result;
  }

  @override
  Gvote_comment_pk_columns_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_comment_pk_columns_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'object':
          result.object = serializers.deserialize(value,
              specifiedType: const FullType(String))! as String;
          break;
        case 'subject':
          result.subject = serializers.deserialize(value,
              specifiedType: const FullType(String))! as String;
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_comment_select_columnSerializer
    implements PrimitiveSerializer<Gvote_comment_select_column> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };

  @override
  final Iterable<Type> types = const <Type>[Gvote_comment_select_column];
  @override
  final String wireName = 'Gvote_comment_select_column';

  @override
  Object serialize(Serializers serializers, Gvote_comment_select_column object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Gvote_comment_select_column deserialize(
          Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      Gvote_comment_select_column.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$Gvote_comment_set_inputSerializer
    implements StructuredSerializer<Gvote_comment_set_input> {
  @override
  final Iterable<Type> types = const [
    Gvote_comment_set_input,
    _$Gvote_comment_set_input
  ];
  @override
  final String wireName = 'Gvote_comment_set_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_comment_set_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.amount;
    if (value != null) {
      result
        ..add('amount')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.object;
    if (value != null) {
      result
        ..add('object')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.subject;
    if (value != null) {
      result
        ..add('subject')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    return result;
  }

  @override
  Gvote_comment_set_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_comment_set_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'amount':
          result.amount = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case 'object':
          result.object = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'subject':
          result.subject = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'updated_at':
          result.updated_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_comment_stream_cursor_inputSerializer
    implements StructuredSerializer<Gvote_comment_stream_cursor_input> {
  @override
  final Iterable<Type> types = const [
    Gvote_comment_stream_cursor_input,
    _$Gvote_comment_stream_cursor_input
  ];
  @override
  final String wireName = 'Gvote_comment_stream_cursor_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_comment_stream_cursor_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'initial_value',
      serializers.serialize(object.initial_value,
          specifiedType:
              const FullType(Gvote_comment_stream_cursor_value_input)),
    ];
    Object? value;
    value = object.ordering;
    if (value != null) {
      result
        ..add('ordering')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gcursor_ordering)));
    }
    return result;
  }

  @override
  Gvote_comment_stream_cursor_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_comment_stream_cursor_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'initial_value':
          result.initial_value.replace(serializers.deserialize(value,
                  specifiedType:
                      const FullType(Gvote_comment_stream_cursor_value_input))!
              as Gvote_comment_stream_cursor_value_input);
          break;
        case 'ordering':
          result.ordering = serializers.deserialize(value,
                  specifiedType: const FullType(Gcursor_ordering))
              as Gcursor_ordering?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_comment_stream_cursor_value_inputSerializer
    implements StructuredSerializer<Gvote_comment_stream_cursor_value_input> {
  @override
  final Iterable<Type> types = const [
    Gvote_comment_stream_cursor_value_input,
    _$Gvote_comment_stream_cursor_value_input
  ];
  @override
  final String wireName = 'Gvote_comment_stream_cursor_value_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_comment_stream_cursor_value_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.amount;
    if (value != null) {
      result
        ..add('amount')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.object;
    if (value != null) {
      result
        ..add('object')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.subject;
    if (value != null) {
      result
        ..add('subject')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    return result;
  }

  @override
  Gvote_comment_stream_cursor_value_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_comment_stream_cursor_value_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'amount':
          result.amount = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case 'object':
          result.object = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'subject':
          result.subject = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'updated_at':
          result.updated_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_comment_update_columnSerializer
    implements PrimitiveSerializer<Gvote_comment_update_column> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };

  @override
  final Iterable<Type> types = const <Type>[Gvote_comment_update_column];
  @override
  final String wireName = 'Gvote_comment_update_column';

  @override
  Object serialize(Serializers serializers, Gvote_comment_update_column object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Gvote_comment_update_column deserialize(
          Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      Gvote_comment_update_column.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$Gvote_comment_updatesSerializer
    implements StructuredSerializer<Gvote_comment_updates> {
  @override
  final Iterable<Type> types = const [
    Gvote_comment_updates,
    _$Gvote_comment_updates
  ];
  @override
  final String wireName = 'Gvote_comment_updates';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_comment_updates object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'where',
      serializers.serialize(object.where,
          specifiedType: const FullType(Gvote_comment_bool_exp)),
    ];
    Object? value;
    value = object.G_inc;
    if (value != null) {
      result
        ..add('_inc')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gvote_comment_inc_input)));
    }
    value = object.G_set;
    if (value != null) {
      result
        ..add('_set')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gvote_comment_set_input)));
    }
    return result;
  }

  @override
  Gvote_comment_updates deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_comment_updatesBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case '_inc':
          result.G_inc.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gvote_comment_inc_input))!
              as Gvote_comment_inc_input);
          break;
        case '_set':
          result.G_set.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gvote_comment_set_input))!
              as Gvote_comment_set_input);
          break;
        case 'where':
          result.where.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gvote_comment_bool_exp))!
              as Gvote_comment_bool_exp);
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_user_bool_expSerializer
    implements StructuredSerializer<Gvote_user_bool_exp> {
  @override
  final Iterable<Type> types = const [
    Gvote_user_bool_exp,
    _$Gvote_user_bool_exp
  ];
  @override
  final String wireName = 'Gvote_user_bool_exp';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_user_bool_exp object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.G_and;
    if (value != null) {
      result
        ..add('_and')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(Gvote_user_bool_exp)])));
    }
    value = object.G_not;
    if (value != null) {
      result
        ..add('_not')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gvote_user_bool_exp)));
    }
    value = object.G_or;
    if (value != null) {
      result
        ..add('_or')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(Gvote_user_bool_exp)])));
    }
    value = object.amount;
    if (value != null) {
      result
        ..add('amount')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GInt_comparison_exp)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gtimestamptz_comparison_exp)));
    }
    value = object.object;
    if (value != null) {
      result
        ..add('object')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GString_comparison_exp)));
    }
    value = object.subject;
    if (value != null) {
      result
        ..add('subject')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GString_comparison_exp)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gtimestamptz_comparison_exp)));
    }
    return result;
  }

  @override
  Gvote_user_bool_exp deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_user_bool_expBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case '_and':
          result.G_and.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(Gvote_user_bool_exp)]))!
              as BuiltList<Object?>);
          break;
        case '_not':
          result.G_not.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gvote_user_bool_exp))!
              as Gvote_user_bool_exp);
          break;
        case '_or':
          result.G_or.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(Gvote_user_bool_exp)]))!
              as BuiltList<Object?>);
          break;
        case 'amount':
          result.amount.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GInt_comparison_exp))!
              as GInt_comparison_exp);
          break;
        case 'created_at':
          result.created_at.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gtimestamptz_comparison_exp))!
              as Gtimestamptz_comparison_exp);
          break;
        case 'object':
          result.object.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GString_comparison_exp))!
              as GString_comparison_exp);
          break;
        case 'subject':
          result.subject.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GString_comparison_exp))!
              as GString_comparison_exp);
          break;
        case 'updated_at':
          result.updated_at.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gtimestamptz_comparison_exp))!
              as Gtimestamptz_comparison_exp);
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_user_constraintSerializer
    implements PrimitiveSerializer<Gvote_user_constraint> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };

  @override
  final Iterable<Type> types = const <Type>[Gvote_user_constraint];
  @override
  final String wireName = 'Gvote_user_constraint';

  @override
  Object serialize(Serializers serializers, Gvote_user_constraint object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Gvote_user_constraint deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      Gvote_user_constraint.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$Gvote_user_inc_inputSerializer
    implements StructuredSerializer<Gvote_user_inc_input> {
  @override
  final Iterable<Type> types = const [
    Gvote_user_inc_input,
    _$Gvote_user_inc_input
  ];
  @override
  final String wireName = 'Gvote_user_inc_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_user_inc_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.amount;
    if (value != null) {
      result
        ..add('amount')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    return result;
  }

  @override
  Gvote_user_inc_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_user_inc_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'amount':
          result.amount = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_user_insert_inputSerializer
    implements StructuredSerializer<Gvote_user_insert_input> {
  @override
  final Iterable<Type> types = const [
    Gvote_user_insert_input,
    _$Gvote_user_insert_input
  ];
  @override
  final String wireName = 'Gvote_user_insert_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_user_insert_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.amount;
    if (value != null) {
      result
        ..add('amount')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.object;
    if (value != null) {
      result
        ..add('object')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.subject;
    if (value != null) {
      result
        ..add('subject')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    return result;
  }

  @override
  Gvote_user_insert_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_user_insert_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'amount':
          result.amount = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case 'object':
          result.object = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'subject':
          result.subject = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'updated_at':
          result.updated_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_user_on_conflictSerializer
    implements StructuredSerializer<Gvote_user_on_conflict> {
  @override
  final Iterable<Type> types = const [
    Gvote_user_on_conflict,
    _$Gvote_user_on_conflict
  ];
  @override
  final String wireName = 'Gvote_user_on_conflict';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_user_on_conflict object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'constraint',
      serializers.serialize(object.constraint,
          specifiedType: const FullType(Gvote_user_constraint)),
      'update_columns',
      serializers.serialize(object.update_columns,
          specifiedType: const FullType(
              BuiltList, const [const FullType(Gvote_user_update_column)])),
    ];
    Object? value;
    value = object.where;
    if (value != null) {
      result
        ..add('where')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gvote_user_bool_exp)));
    }
    return result;
  }

  @override
  Gvote_user_on_conflict deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_user_on_conflictBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'constraint':
          result.constraint = serializers.deserialize(value,
                  specifiedType: const FullType(Gvote_user_constraint))!
              as Gvote_user_constraint;
          break;
        case 'update_columns':
          result.update_columns.replace(serializers.deserialize(value,
              specifiedType: const FullType(BuiltList, const [
                const FullType(Gvote_user_update_column)
              ]))! as BuiltList<Object?>);
          break;
        case 'where':
          result.where.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gvote_user_bool_exp))!
              as Gvote_user_bool_exp);
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_user_order_bySerializer
    implements StructuredSerializer<Gvote_user_order_by> {
  @override
  final Iterable<Type> types = const [
    Gvote_user_order_by,
    _$Gvote_user_order_by
  ];
  @override
  final String wireName = 'Gvote_user_order_by';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_user_order_by object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.amount;
    if (value != null) {
      result
        ..add('amount')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.object;
    if (value != null) {
      result
        ..add('object')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.subject;
    if (value != null) {
      result
        ..add('subject')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gorder_by)));
    }
    return result;
  }

  @override
  Gvote_user_order_by deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_user_order_byBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'amount':
          result.amount = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'object':
          result.object = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'subject':
          result.subject = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
        case 'updated_at':
          result.updated_at = serializers.deserialize(value,
              specifiedType: const FullType(Gorder_by)) as Gorder_by?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_user_pk_columns_inputSerializer
    implements StructuredSerializer<Gvote_user_pk_columns_input> {
  @override
  final Iterable<Type> types = const [
    Gvote_user_pk_columns_input,
    _$Gvote_user_pk_columns_input
  ];
  @override
  final String wireName = 'Gvote_user_pk_columns_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_user_pk_columns_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'object',
      serializers.serialize(object.object,
          specifiedType: const FullType(String)),
      'subject',
      serializers.serialize(object.subject,
          specifiedType: const FullType(String)),
    ];

    return result;
  }

  @override
  Gvote_user_pk_columns_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_user_pk_columns_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'object':
          result.object = serializers.deserialize(value,
              specifiedType: const FullType(String))! as String;
          break;
        case 'subject':
          result.subject = serializers.deserialize(value,
              specifiedType: const FullType(String))! as String;
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_user_select_columnSerializer
    implements PrimitiveSerializer<Gvote_user_select_column> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };

  @override
  final Iterable<Type> types = const <Type>[Gvote_user_select_column];
  @override
  final String wireName = 'Gvote_user_select_column';

  @override
  Object serialize(Serializers serializers, Gvote_user_select_column object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Gvote_user_select_column deserialize(
          Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      Gvote_user_select_column.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$Gvote_user_set_inputSerializer
    implements StructuredSerializer<Gvote_user_set_input> {
  @override
  final Iterable<Type> types = const [
    Gvote_user_set_input,
    _$Gvote_user_set_input
  ];
  @override
  final String wireName = 'Gvote_user_set_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_user_set_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.amount;
    if (value != null) {
      result
        ..add('amount')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.object;
    if (value != null) {
      result
        ..add('object')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.subject;
    if (value != null) {
      result
        ..add('subject')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    return result;
  }

  @override
  Gvote_user_set_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_user_set_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'amount':
          result.amount = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case 'object':
          result.object = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'subject':
          result.subject = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'updated_at':
          result.updated_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_user_stream_cursor_inputSerializer
    implements StructuredSerializer<Gvote_user_stream_cursor_input> {
  @override
  final Iterable<Type> types = const [
    Gvote_user_stream_cursor_input,
    _$Gvote_user_stream_cursor_input
  ];
  @override
  final String wireName = 'Gvote_user_stream_cursor_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_user_stream_cursor_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'initial_value',
      serializers.serialize(object.initial_value,
          specifiedType: const FullType(Gvote_user_stream_cursor_value_input)),
    ];
    Object? value;
    value = object.ordering;
    if (value != null) {
      result
        ..add('ordering')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gcursor_ordering)));
    }
    return result;
  }

  @override
  Gvote_user_stream_cursor_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_user_stream_cursor_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'initial_value':
          result.initial_value.replace(serializers.deserialize(value,
                  specifiedType:
                      const FullType(Gvote_user_stream_cursor_value_input))!
              as Gvote_user_stream_cursor_value_input);
          break;
        case 'ordering':
          result.ordering = serializers.deserialize(value,
                  specifiedType: const FullType(Gcursor_ordering))
              as Gcursor_ordering?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_user_stream_cursor_value_inputSerializer
    implements StructuredSerializer<Gvote_user_stream_cursor_value_input> {
  @override
  final Iterable<Type> types = const [
    Gvote_user_stream_cursor_value_input,
    _$Gvote_user_stream_cursor_value_input
  ];
  @override
  final String wireName = 'Gvote_user_stream_cursor_value_input';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_user_stream_cursor_value_input object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.amount;
    if (value != null) {
      result
        ..add('amount')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    value = object.created_at;
    if (value != null) {
      result
        ..add('created_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    value = object.object;
    if (value != null) {
      result
        ..add('object')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.subject;
    if (value != null) {
      result
        ..add('subject')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.updated_at;
    if (value != null) {
      result
        ..add('updated_at')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DateTime)));
    }
    return result;
  }

  @override
  Gvote_user_stream_cursor_value_input deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_user_stream_cursor_value_inputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'amount':
          result.amount = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
        case 'created_at':
          result.created_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
        case 'object':
          result.object = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'subject':
          result.subject = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'updated_at':
          result.updated_at = serializers.deserialize(value,
              specifiedType: const FullType(DateTime)) as DateTime?;
          break;
      }
    }

    return result.build();
  }
}

class _$Gvote_user_update_columnSerializer
    implements PrimitiveSerializer<Gvote_user_update_column> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'gUnknownEnumValue': 'gUnknownEnumValue',
  };

  @override
  final Iterable<Type> types = const <Type>[Gvote_user_update_column];
  @override
  final String wireName = 'Gvote_user_update_column';

  @override
  Object serialize(Serializers serializers, Gvote_user_update_column object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Gvote_user_update_column deserialize(
          Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      Gvote_user_update_column.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$Gvote_user_updatesSerializer
    implements StructuredSerializer<Gvote_user_updates> {
  @override
  final Iterable<Type> types = const [Gvote_user_updates, _$Gvote_user_updates];
  @override
  final String wireName = 'Gvote_user_updates';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, Gvote_user_updates object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'where',
      serializers.serialize(object.where,
          specifiedType: const FullType(Gvote_user_bool_exp)),
    ];
    Object? value;
    value = object.G_inc;
    if (value != null) {
      result
        ..add('_inc')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gvote_user_inc_input)));
    }
    value = object.G_set;
    if (value != null) {
      result
        ..add('_set')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Gvote_user_set_input)));
    }
    return result;
  }

  @override
  Gvote_user_updates deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new Gvote_user_updatesBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current! as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case '_inc':
          result.G_inc.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gvote_user_inc_input))!
              as Gvote_user_inc_input);
          break;
        case '_set':
          result.G_set.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gvote_user_set_input))!
              as Gvote_user_set_input);
          break;
        case 'where':
          result.where.replace(serializers.deserialize(value,
                  specifiedType: const FullType(Gvote_user_bool_exp))!
              as Gvote_user_bool_exp);
          break;
      }
    }

    return result.build();
  }
}

class _$Gbeacon_bool_exp extends Gbeacon_bool_exp {
  @override
  final BuiltList<Gbeacon_bool_exp>? G_and;
  @override
  final Gbeacon_bool_exp? G_not;
  @override
  final BuiltList<Gbeacon_bool_exp>? G_or;
  @override
  final Guser_bool_exp? author;
  @override
  final Gcomment_bool_exp? comments;
  @override
  final Gcomment_aggregate_bool_exp? comments_aggregate;
  @override
  final GInt_comparison_exp? comments_count;
  @override
  final Gtimestamptz_comparison_exp? created_at;
  @override
  final GString_comparison_exp? description;
  @override
  final GBoolean_comparison_exp? enabled;
  @override
  final GBoolean_comparison_exp? has_picture;
  @override
  final GString_comparison_exp? id;
  @override
  final Ggeography_comparison_exp? place;
  @override
  final Gtstzrange_comparison_exp? timerange;
  @override
  final GString_comparison_exp? title;
  @override
  final Gtimestamptz_comparison_exp? updated_at;
  @override
  final GString_comparison_exp? user_id;

  factory _$Gbeacon_bool_exp(
          [void Function(Gbeacon_bool_expBuilder)? updates]) =>
      (new Gbeacon_bool_expBuilder()..update(updates))._build();

  _$Gbeacon_bool_exp._(
      {this.G_and,
      this.G_not,
      this.G_or,
      this.author,
      this.comments,
      this.comments_aggregate,
      this.comments_count,
      this.created_at,
      this.description,
      this.enabled,
      this.has_picture,
      this.id,
      this.place,
      this.timerange,
      this.title,
      this.updated_at,
      this.user_id})
      : super._();

  @override
  Gbeacon_bool_exp rebuild(void Function(Gbeacon_bool_expBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gbeacon_bool_expBuilder toBuilder() =>
      new Gbeacon_bool_expBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gbeacon_bool_exp &&
        G_and == other.G_and &&
        G_not == other.G_not &&
        G_or == other.G_or &&
        author == other.author &&
        comments == other.comments &&
        comments_aggregate == other.comments_aggregate &&
        comments_count == other.comments_count &&
        created_at == other.created_at &&
        description == other.description &&
        enabled == other.enabled &&
        has_picture == other.has_picture &&
        id == other.id &&
        place == other.place &&
        timerange == other.timerange &&
        title == other.title &&
        updated_at == other.updated_at &&
        user_id == other.user_id;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, G_and.hashCode);
    _$hash = $jc(_$hash, G_not.hashCode);
    _$hash = $jc(_$hash, G_or.hashCode);
    _$hash = $jc(_$hash, author.hashCode);
    _$hash = $jc(_$hash, comments.hashCode);
    _$hash = $jc(_$hash, comments_aggregate.hashCode);
    _$hash = $jc(_$hash, comments_count.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, description.hashCode);
    _$hash = $jc(_$hash, enabled.hashCode);
    _$hash = $jc(_$hash, has_picture.hashCode);
    _$hash = $jc(_$hash, id.hashCode);
    _$hash = $jc(_$hash, place.hashCode);
    _$hash = $jc(_$hash, timerange.hashCode);
    _$hash = $jc(_$hash, title.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jc(_$hash, user_id.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gbeacon_bool_exp')
          ..add('G_and', G_and)
          ..add('G_not', G_not)
          ..add('G_or', G_or)
          ..add('author', author)
          ..add('comments', comments)
          ..add('comments_aggregate', comments_aggregate)
          ..add('comments_count', comments_count)
          ..add('created_at', created_at)
          ..add('description', description)
          ..add('enabled', enabled)
          ..add('has_picture', has_picture)
          ..add('id', id)
          ..add('place', place)
          ..add('timerange', timerange)
          ..add('title', title)
          ..add('updated_at', updated_at)
          ..add('user_id', user_id))
        .toString();
  }
}

class Gbeacon_bool_expBuilder
    implements Builder<Gbeacon_bool_exp, Gbeacon_bool_expBuilder> {
  _$Gbeacon_bool_exp? _$v;

  ListBuilder<Gbeacon_bool_exp>? _G_and;
  ListBuilder<Gbeacon_bool_exp> get G_and =>
      _$this._G_and ??= new ListBuilder<Gbeacon_bool_exp>();
  set G_and(ListBuilder<Gbeacon_bool_exp>? G_and) => _$this._G_and = G_and;

  Gbeacon_bool_expBuilder? _G_not;
  Gbeacon_bool_expBuilder get G_not =>
      _$this._G_not ??= new Gbeacon_bool_expBuilder();
  set G_not(Gbeacon_bool_expBuilder? G_not) => _$this._G_not = G_not;

  ListBuilder<Gbeacon_bool_exp>? _G_or;
  ListBuilder<Gbeacon_bool_exp> get G_or =>
      _$this._G_or ??= new ListBuilder<Gbeacon_bool_exp>();
  set G_or(ListBuilder<Gbeacon_bool_exp>? G_or) => _$this._G_or = G_or;

  Guser_bool_expBuilder? _author;
  Guser_bool_expBuilder get author =>
      _$this._author ??= new Guser_bool_expBuilder();
  set author(Guser_bool_expBuilder? author) => _$this._author = author;

  Gcomment_bool_expBuilder? _comments;
  Gcomment_bool_expBuilder get comments =>
      _$this._comments ??= new Gcomment_bool_expBuilder();
  set comments(Gcomment_bool_expBuilder? comments) =>
      _$this._comments = comments;

  Gcomment_aggregate_bool_expBuilder? _comments_aggregate;
  Gcomment_aggregate_bool_expBuilder get comments_aggregate =>
      _$this._comments_aggregate ??= new Gcomment_aggregate_bool_expBuilder();
  set comments_aggregate(
          Gcomment_aggregate_bool_expBuilder? comments_aggregate) =>
      _$this._comments_aggregate = comments_aggregate;

  GInt_comparison_expBuilder? _comments_count;
  GInt_comparison_expBuilder get comments_count =>
      _$this._comments_count ??= new GInt_comparison_expBuilder();
  set comments_count(GInt_comparison_expBuilder? comments_count) =>
      _$this._comments_count = comments_count;

  Gtimestamptz_comparison_expBuilder? _created_at;
  Gtimestamptz_comparison_expBuilder get created_at =>
      _$this._created_at ??= new Gtimestamptz_comparison_expBuilder();
  set created_at(Gtimestamptz_comparison_expBuilder? created_at) =>
      _$this._created_at = created_at;

  GString_comparison_expBuilder? _description;
  GString_comparison_expBuilder get description =>
      _$this._description ??= new GString_comparison_expBuilder();
  set description(GString_comparison_expBuilder? description) =>
      _$this._description = description;

  GBoolean_comparison_expBuilder? _enabled;
  GBoolean_comparison_expBuilder get enabled =>
      _$this._enabled ??= new GBoolean_comparison_expBuilder();
  set enabled(GBoolean_comparison_expBuilder? enabled) =>
      _$this._enabled = enabled;

  GBoolean_comparison_expBuilder? _has_picture;
  GBoolean_comparison_expBuilder get has_picture =>
      _$this._has_picture ??= new GBoolean_comparison_expBuilder();
  set has_picture(GBoolean_comparison_expBuilder? has_picture) =>
      _$this._has_picture = has_picture;

  GString_comparison_expBuilder? _id;
  GString_comparison_expBuilder get id =>
      _$this._id ??= new GString_comparison_expBuilder();
  set id(GString_comparison_expBuilder? id) => _$this._id = id;

  Ggeography_comparison_expBuilder? _place;
  Ggeography_comparison_expBuilder get place =>
      _$this._place ??= new Ggeography_comparison_expBuilder();
  set place(Ggeography_comparison_expBuilder? place) => _$this._place = place;

  Gtstzrange_comparison_expBuilder? _timerange;
  Gtstzrange_comparison_expBuilder get timerange =>
      _$this._timerange ??= new Gtstzrange_comparison_expBuilder();
  set timerange(Gtstzrange_comparison_expBuilder? timerange) =>
      _$this._timerange = timerange;

  GString_comparison_expBuilder? _title;
  GString_comparison_expBuilder get title =>
      _$this._title ??= new GString_comparison_expBuilder();
  set title(GString_comparison_expBuilder? title) => _$this._title = title;

  Gtimestamptz_comparison_expBuilder? _updated_at;
  Gtimestamptz_comparison_expBuilder get updated_at =>
      _$this._updated_at ??= new Gtimestamptz_comparison_expBuilder();
  set updated_at(Gtimestamptz_comparison_expBuilder? updated_at) =>
      _$this._updated_at = updated_at;

  GString_comparison_expBuilder? _user_id;
  GString_comparison_expBuilder get user_id =>
      _$this._user_id ??= new GString_comparison_expBuilder();
  set user_id(GString_comparison_expBuilder? user_id) =>
      _$this._user_id = user_id;

  Gbeacon_bool_expBuilder();

  Gbeacon_bool_expBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _G_and = $v.G_and?.toBuilder();
      _G_not = $v.G_not?.toBuilder();
      _G_or = $v.G_or?.toBuilder();
      _author = $v.author?.toBuilder();
      _comments = $v.comments?.toBuilder();
      _comments_aggregate = $v.comments_aggregate?.toBuilder();
      _comments_count = $v.comments_count?.toBuilder();
      _created_at = $v.created_at?.toBuilder();
      _description = $v.description?.toBuilder();
      _enabled = $v.enabled?.toBuilder();
      _has_picture = $v.has_picture?.toBuilder();
      _id = $v.id?.toBuilder();
      _place = $v.place?.toBuilder();
      _timerange = $v.timerange?.toBuilder();
      _title = $v.title?.toBuilder();
      _updated_at = $v.updated_at?.toBuilder();
      _user_id = $v.user_id?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gbeacon_bool_exp other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gbeacon_bool_exp;
  }

  @override
  void update(void Function(Gbeacon_bool_expBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gbeacon_bool_exp build() => _build();

  _$Gbeacon_bool_exp _build() {
    _$Gbeacon_bool_exp _$result;
    try {
      _$result = _$v ??
          new _$Gbeacon_bool_exp._(
              G_and: _G_and?.build(),
              G_not: _G_not?.build(),
              G_or: _G_or?.build(),
              author: _author?.build(),
              comments: _comments?.build(),
              comments_aggregate: _comments_aggregate?.build(),
              comments_count: _comments_count?.build(),
              created_at: _created_at?.build(),
              description: _description?.build(),
              enabled: _enabled?.build(),
              has_picture: _has_picture?.build(),
              id: _id?.build(),
              place: _place?.build(),
              timerange: _timerange?.build(),
              title: _title?.build(),
              updated_at: _updated_at?.build(),
              user_id: _user_id?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'G_and';
        _G_and?.build();
        _$failedField = 'G_not';
        _G_not?.build();
        _$failedField = 'G_or';
        _G_or?.build();
        _$failedField = 'author';
        _author?.build();
        _$failedField = 'comments';
        _comments?.build();
        _$failedField = 'comments_aggregate';
        _comments_aggregate?.build();
        _$failedField = 'comments_count';
        _comments_count?.build();
        _$failedField = 'created_at';
        _created_at?.build();
        _$failedField = 'description';
        _description?.build();
        _$failedField = 'enabled';
        _enabled?.build();
        _$failedField = 'has_picture';
        _has_picture?.build();
        _$failedField = 'id';
        _id?.build();
        _$failedField = 'place';
        _place?.build();
        _$failedField = 'timerange';
        _timerange?.build();
        _$failedField = 'title';
        _title?.build();
        _$failedField = 'updated_at';
        _updated_at?.build();
        _$failedField = 'user_id';
        _user_id?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gbeacon_bool_exp', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gbeacon_inc_input extends Gbeacon_inc_input {
  @override
  final int? comments_count;

  factory _$Gbeacon_inc_input(
          [void Function(Gbeacon_inc_inputBuilder)? updates]) =>
      (new Gbeacon_inc_inputBuilder()..update(updates))._build();

  _$Gbeacon_inc_input._({this.comments_count}) : super._();

  @override
  Gbeacon_inc_input rebuild(void Function(Gbeacon_inc_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gbeacon_inc_inputBuilder toBuilder() =>
      new Gbeacon_inc_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gbeacon_inc_input && comments_count == other.comments_count;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, comments_count.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gbeacon_inc_input')
          ..add('comments_count', comments_count))
        .toString();
  }
}

class Gbeacon_inc_inputBuilder
    implements Builder<Gbeacon_inc_input, Gbeacon_inc_inputBuilder> {
  _$Gbeacon_inc_input? _$v;

  int? _comments_count;
  int? get comments_count => _$this._comments_count;
  set comments_count(int? comments_count) =>
      _$this._comments_count = comments_count;

  Gbeacon_inc_inputBuilder();

  Gbeacon_inc_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _comments_count = $v.comments_count;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gbeacon_inc_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gbeacon_inc_input;
  }

  @override
  void update(void Function(Gbeacon_inc_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gbeacon_inc_input build() => _build();

  _$Gbeacon_inc_input _build() {
    final _$result =
        _$v ?? new _$Gbeacon_inc_input._(comments_count: comments_count);
    replace(_$result);
    return _$result;
  }
}

class _$Gbeacon_insert_input extends Gbeacon_insert_input {
  @override
  final Guser_obj_rel_insert_input? author;
  @override
  final Gcomment_arr_rel_insert_input? comments;
  @override
  final int? comments_count;
  @override
  final DateTime? created_at;
  @override
  final String? description;
  @override
  final bool? enabled;
  @override
  final bool? has_picture;
  @override
  final String? id;
  @override
  final _i2.LatLng? place;
  @override
  final _i3.DateTimeRange? timerange;
  @override
  final String? title;
  @override
  final DateTime? updated_at;
  @override
  final String? user_id;

  factory _$Gbeacon_insert_input(
          [void Function(Gbeacon_insert_inputBuilder)? updates]) =>
      (new Gbeacon_insert_inputBuilder()..update(updates))._build();

  _$Gbeacon_insert_input._(
      {this.author,
      this.comments,
      this.comments_count,
      this.created_at,
      this.description,
      this.enabled,
      this.has_picture,
      this.id,
      this.place,
      this.timerange,
      this.title,
      this.updated_at,
      this.user_id})
      : super._();

  @override
  Gbeacon_insert_input rebuild(
          void Function(Gbeacon_insert_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gbeacon_insert_inputBuilder toBuilder() =>
      new Gbeacon_insert_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gbeacon_insert_input &&
        author == other.author &&
        comments == other.comments &&
        comments_count == other.comments_count &&
        created_at == other.created_at &&
        description == other.description &&
        enabled == other.enabled &&
        has_picture == other.has_picture &&
        id == other.id &&
        place == other.place &&
        timerange == other.timerange &&
        title == other.title &&
        updated_at == other.updated_at &&
        user_id == other.user_id;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, author.hashCode);
    _$hash = $jc(_$hash, comments.hashCode);
    _$hash = $jc(_$hash, comments_count.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, description.hashCode);
    _$hash = $jc(_$hash, enabled.hashCode);
    _$hash = $jc(_$hash, has_picture.hashCode);
    _$hash = $jc(_$hash, id.hashCode);
    _$hash = $jc(_$hash, place.hashCode);
    _$hash = $jc(_$hash, timerange.hashCode);
    _$hash = $jc(_$hash, title.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jc(_$hash, user_id.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gbeacon_insert_input')
          ..add('author', author)
          ..add('comments', comments)
          ..add('comments_count', comments_count)
          ..add('created_at', created_at)
          ..add('description', description)
          ..add('enabled', enabled)
          ..add('has_picture', has_picture)
          ..add('id', id)
          ..add('place', place)
          ..add('timerange', timerange)
          ..add('title', title)
          ..add('updated_at', updated_at)
          ..add('user_id', user_id))
        .toString();
  }
}

class Gbeacon_insert_inputBuilder
    implements Builder<Gbeacon_insert_input, Gbeacon_insert_inputBuilder> {
  _$Gbeacon_insert_input? _$v;

  Guser_obj_rel_insert_inputBuilder? _author;
  Guser_obj_rel_insert_inputBuilder get author =>
      _$this._author ??= new Guser_obj_rel_insert_inputBuilder();
  set author(Guser_obj_rel_insert_inputBuilder? author) =>
      _$this._author = author;

  Gcomment_arr_rel_insert_inputBuilder? _comments;
  Gcomment_arr_rel_insert_inputBuilder get comments =>
      _$this._comments ??= new Gcomment_arr_rel_insert_inputBuilder();
  set comments(Gcomment_arr_rel_insert_inputBuilder? comments) =>
      _$this._comments = comments;

  int? _comments_count;
  int? get comments_count => _$this._comments_count;
  set comments_count(int? comments_count) =>
      _$this._comments_count = comments_count;

  DateTime? _created_at;
  DateTime? get created_at => _$this._created_at;
  set created_at(DateTime? created_at) => _$this._created_at = created_at;

  String? _description;
  String? get description => _$this._description;
  set description(String? description) => _$this._description = description;

  bool? _enabled;
  bool? get enabled => _$this._enabled;
  set enabled(bool? enabled) => _$this._enabled = enabled;

  bool? _has_picture;
  bool? get has_picture => _$this._has_picture;
  set has_picture(bool? has_picture) => _$this._has_picture = has_picture;

  String? _id;
  String? get id => _$this._id;
  set id(String? id) => _$this._id = id;

  _i2.LatLng? _place;
  _i2.LatLng? get place => _$this._place;
  set place(_i2.LatLng? place) => _$this._place = place;

  _i3.DateTimeRange? _timerange;
  _i3.DateTimeRange? get timerange => _$this._timerange;
  set timerange(_i3.DateTimeRange? timerange) => _$this._timerange = timerange;

  String? _title;
  String? get title => _$this._title;
  set title(String? title) => _$this._title = title;

  DateTime? _updated_at;
  DateTime? get updated_at => _$this._updated_at;
  set updated_at(DateTime? updated_at) => _$this._updated_at = updated_at;

  String? _user_id;
  String? get user_id => _$this._user_id;
  set user_id(String? user_id) => _$this._user_id = user_id;

  Gbeacon_insert_inputBuilder();

  Gbeacon_insert_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _author = $v.author?.toBuilder();
      _comments = $v.comments?.toBuilder();
      _comments_count = $v.comments_count;
      _created_at = $v.created_at;
      _description = $v.description;
      _enabled = $v.enabled;
      _has_picture = $v.has_picture;
      _id = $v.id;
      _place = $v.place;
      _timerange = $v.timerange;
      _title = $v.title;
      _updated_at = $v.updated_at;
      _user_id = $v.user_id;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gbeacon_insert_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gbeacon_insert_input;
  }

  @override
  void update(void Function(Gbeacon_insert_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gbeacon_insert_input build() => _build();

  _$Gbeacon_insert_input _build() {
    _$Gbeacon_insert_input _$result;
    try {
      _$result = _$v ??
          new _$Gbeacon_insert_input._(
              author: _author?.build(),
              comments: _comments?.build(),
              comments_count: comments_count,
              created_at: created_at,
              description: description,
              enabled: enabled,
              has_picture: has_picture,
              id: id,
              place: place,
              timerange: timerange,
              title: title,
              updated_at: updated_at,
              user_id: user_id);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'author';
        _author?.build();
        _$failedField = 'comments';
        _comments?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gbeacon_insert_input', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gbeacon_on_conflict extends Gbeacon_on_conflict {
  @override
  final Gbeacon_constraint constraint;
  @override
  final BuiltList<Gbeacon_update_column> update_columns;
  @override
  final Gbeacon_bool_exp? where;

  factory _$Gbeacon_on_conflict(
          [void Function(Gbeacon_on_conflictBuilder)? updates]) =>
      (new Gbeacon_on_conflictBuilder()..update(updates))._build();

  _$Gbeacon_on_conflict._(
      {required this.constraint, required this.update_columns, this.where})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        constraint, r'Gbeacon_on_conflict', 'constraint');
    BuiltValueNullFieldError.checkNotNull(
        update_columns, r'Gbeacon_on_conflict', 'update_columns');
  }

  @override
  Gbeacon_on_conflict rebuild(
          void Function(Gbeacon_on_conflictBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gbeacon_on_conflictBuilder toBuilder() =>
      new Gbeacon_on_conflictBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gbeacon_on_conflict &&
        constraint == other.constraint &&
        update_columns == other.update_columns &&
        where == other.where;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, constraint.hashCode);
    _$hash = $jc(_$hash, update_columns.hashCode);
    _$hash = $jc(_$hash, where.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gbeacon_on_conflict')
          ..add('constraint', constraint)
          ..add('update_columns', update_columns)
          ..add('where', where))
        .toString();
  }
}

class Gbeacon_on_conflictBuilder
    implements Builder<Gbeacon_on_conflict, Gbeacon_on_conflictBuilder> {
  _$Gbeacon_on_conflict? _$v;

  Gbeacon_constraint? _constraint;
  Gbeacon_constraint? get constraint => _$this._constraint;
  set constraint(Gbeacon_constraint? constraint) =>
      _$this._constraint = constraint;

  ListBuilder<Gbeacon_update_column>? _update_columns;
  ListBuilder<Gbeacon_update_column> get update_columns =>
      _$this._update_columns ??= new ListBuilder<Gbeacon_update_column>();
  set update_columns(ListBuilder<Gbeacon_update_column>? update_columns) =>
      _$this._update_columns = update_columns;

  Gbeacon_bool_expBuilder? _where;
  Gbeacon_bool_expBuilder get where =>
      _$this._where ??= new Gbeacon_bool_expBuilder();
  set where(Gbeacon_bool_expBuilder? where) => _$this._where = where;

  Gbeacon_on_conflictBuilder();

  Gbeacon_on_conflictBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _constraint = $v.constraint;
      _update_columns = $v.update_columns.toBuilder();
      _where = $v.where?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gbeacon_on_conflict other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gbeacon_on_conflict;
  }

  @override
  void update(void Function(Gbeacon_on_conflictBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gbeacon_on_conflict build() => _build();

  _$Gbeacon_on_conflict _build() {
    _$Gbeacon_on_conflict _$result;
    try {
      _$result = _$v ??
          new _$Gbeacon_on_conflict._(
              constraint: BuiltValueNullFieldError.checkNotNull(
                  constraint, r'Gbeacon_on_conflict', 'constraint'),
              update_columns: update_columns.build(),
              where: _where?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'update_columns';
        update_columns.build();
        _$failedField = 'where';
        _where?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gbeacon_on_conflict', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gbeacon_order_by extends Gbeacon_order_by {
  @override
  final Guser_order_by? author;
  @override
  final Gcomment_aggregate_order_by? comments_aggregate;
  @override
  final Gorder_by? comments_count;
  @override
  final Gorder_by? created_at;
  @override
  final Gorder_by? description;
  @override
  final Gorder_by? enabled;
  @override
  final Gorder_by? has_picture;
  @override
  final Gorder_by? id;
  @override
  final Gorder_by? place;
  @override
  final Gorder_by? timerange;
  @override
  final Gorder_by? title;
  @override
  final Gorder_by? updated_at;
  @override
  final Gorder_by? user_id;

  factory _$Gbeacon_order_by(
          [void Function(Gbeacon_order_byBuilder)? updates]) =>
      (new Gbeacon_order_byBuilder()..update(updates))._build();

  _$Gbeacon_order_by._(
      {this.author,
      this.comments_aggregate,
      this.comments_count,
      this.created_at,
      this.description,
      this.enabled,
      this.has_picture,
      this.id,
      this.place,
      this.timerange,
      this.title,
      this.updated_at,
      this.user_id})
      : super._();

  @override
  Gbeacon_order_by rebuild(void Function(Gbeacon_order_byBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gbeacon_order_byBuilder toBuilder() =>
      new Gbeacon_order_byBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gbeacon_order_by &&
        author == other.author &&
        comments_aggregate == other.comments_aggregate &&
        comments_count == other.comments_count &&
        created_at == other.created_at &&
        description == other.description &&
        enabled == other.enabled &&
        has_picture == other.has_picture &&
        id == other.id &&
        place == other.place &&
        timerange == other.timerange &&
        title == other.title &&
        updated_at == other.updated_at &&
        user_id == other.user_id;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, author.hashCode);
    _$hash = $jc(_$hash, comments_aggregate.hashCode);
    _$hash = $jc(_$hash, comments_count.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, description.hashCode);
    _$hash = $jc(_$hash, enabled.hashCode);
    _$hash = $jc(_$hash, has_picture.hashCode);
    _$hash = $jc(_$hash, id.hashCode);
    _$hash = $jc(_$hash, place.hashCode);
    _$hash = $jc(_$hash, timerange.hashCode);
    _$hash = $jc(_$hash, title.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jc(_$hash, user_id.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gbeacon_order_by')
          ..add('author', author)
          ..add('comments_aggregate', comments_aggregate)
          ..add('comments_count', comments_count)
          ..add('created_at', created_at)
          ..add('description', description)
          ..add('enabled', enabled)
          ..add('has_picture', has_picture)
          ..add('id', id)
          ..add('place', place)
          ..add('timerange', timerange)
          ..add('title', title)
          ..add('updated_at', updated_at)
          ..add('user_id', user_id))
        .toString();
  }
}

class Gbeacon_order_byBuilder
    implements Builder<Gbeacon_order_by, Gbeacon_order_byBuilder> {
  _$Gbeacon_order_by? _$v;

  Guser_order_byBuilder? _author;
  Guser_order_byBuilder get author =>
      _$this._author ??= new Guser_order_byBuilder();
  set author(Guser_order_byBuilder? author) => _$this._author = author;

  Gcomment_aggregate_order_byBuilder? _comments_aggregate;
  Gcomment_aggregate_order_byBuilder get comments_aggregate =>
      _$this._comments_aggregate ??= new Gcomment_aggregate_order_byBuilder();
  set comments_aggregate(
          Gcomment_aggregate_order_byBuilder? comments_aggregate) =>
      _$this._comments_aggregate = comments_aggregate;

  Gorder_by? _comments_count;
  Gorder_by? get comments_count => _$this._comments_count;
  set comments_count(Gorder_by? comments_count) =>
      _$this._comments_count = comments_count;

  Gorder_by? _created_at;
  Gorder_by? get created_at => _$this._created_at;
  set created_at(Gorder_by? created_at) => _$this._created_at = created_at;

  Gorder_by? _description;
  Gorder_by? get description => _$this._description;
  set description(Gorder_by? description) => _$this._description = description;

  Gorder_by? _enabled;
  Gorder_by? get enabled => _$this._enabled;
  set enabled(Gorder_by? enabled) => _$this._enabled = enabled;

  Gorder_by? _has_picture;
  Gorder_by? get has_picture => _$this._has_picture;
  set has_picture(Gorder_by? has_picture) => _$this._has_picture = has_picture;

  Gorder_by? _id;
  Gorder_by? get id => _$this._id;
  set id(Gorder_by? id) => _$this._id = id;

  Gorder_by? _place;
  Gorder_by? get place => _$this._place;
  set place(Gorder_by? place) => _$this._place = place;

  Gorder_by? _timerange;
  Gorder_by? get timerange => _$this._timerange;
  set timerange(Gorder_by? timerange) => _$this._timerange = timerange;

  Gorder_by? _title;
  Gorder_by? get title => _$this._title;
  set title(Gorder_by? title) => _$this._title = title;

  Gorder_by? _updated_at;
  Gorder_by? get updated_at => _$this._updated_at;
  set updated_at(Gorder_by? updated_at) => _$this._updated_at = updated_at;

  Gorder_by? _user_id;
  Gorder_by? get user_id => _$this._user_id;
  set user_id(Gorder_by? user_id) => _$this._user_id = user_id;

  Gbeacon_order_byBuilder();

  Gbeacon_order_byBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _author = $v.author?.toBuilder();
      _comments_aggregate = $v.comments_aggregate?.toBuilder();
      _comments_count = $v.comments_count;
      _created_at = $v.created_at;
      _description = $v.description;
      _enabled = $v.enabled;
      _has_picture = $v.has_picture;
      _id = $v.id;
      _place = $v.place;
      _timerange = $v.timerange;
      _title = $v.title;
      _updated_at = $v.updated_at;
      _user_id = $v.user_id;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gbeacon_order_by other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gbeacon_order_by;
  }

  @override
  void update(void Function(Gbeacon_order_byBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gbeacon_order_by build() => _build();

  _$Gbeacon_order_by _build() {
    _$Gbeacon_order_by _$result;
    try {
      _$result = _$v ??
          new _$Gbeacon_order_by._(
              author: _author?.build(),
              comments_aggregate: _comments_aggregate?.build(),
              comments_count: comments_count,
              created_at: created_at,
              description: description,
              enabled: enabled,
              has_picture: has_picture,
              id: id,
              place: place,
              timerange: timerange,
              title: title,
              updated_at: updated_at,
              user_id: user_id);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'author';
        _author?.build();
        _$failedField = 'comments_aggregate';
        _comments_aggregate?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gbeacon_order_by', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gbeacon_pk_columns_input extends Gbeacon_pk_columns_input {
  @override
  final String id;

  factory _$Gbeacon_pk_columns_input(
          [void Function(Gbeacon_pk_columns_inputBuilder)? updates]) =>
      (new Gbeacon_pk_columns_inputBuilder()..update(updates))._build();

  _$Gbeacon_pk_columns_input._({required this.id}) : super._() {
    BuiltValueNullFieldError.checkNotNull(
        id, r'Gbeacon_pk_columns_input', 'id');
  }

  @override
  Gbeacon_pk_columns_input rebuild(
          void Function(Gbeacon_pk_columns_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gbeacon_pk_columns_inputBuilder toBuilder() =>
      new Gbeacon_pk_columns_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gbeacon_pk_columns_input && id == other.id;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, id.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gbeacon_pk_columns_input')
          ..add('id', id))
        .toString();
  }
}

class Gbeacon_pk_columns_inputBuilder
    implements
        Builder<Gbeacon_pk_columns_input, Gbeacon_pk_columns_inputBuilder> {
  _$Gbeacon_pk_columns_input? _$v;

  String? _id;
  String? get id => _$this._id;
  set id(String? id) => _$this._id = id;

  Gbeacon_pk_columns_inputBuilder();

  Gbeacon_pk_columns_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _id = $v.id;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gbeacon_pk_columns_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gbeacon_pk_columns_input;
  }

  @override
  void update(void Function(Gbeacon_pk_columns_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gbeacon_pk_columns_input build() => _build();

  _$Gbeacon_pk_columns_input _build() {
    final _$result = _$v ??
        new _$Gbeacon_pk_columns_input._(
            id: BuiltValueNullFieldError.checkNotNull(
                id, r'Gbeacon_pk_columns_input', 'id'));
    replace(_$result);
    return _$result;
  }
}

class _$Gbeacon_set_input extends Gbeacon_set_input {
  @override
  final int? comments_count;
  @override
  final DateTime? created_at;
  @override
  final String? description;
  @override
  final bool? enabled;
  @override
  final bool? has_picture;
  @override
  final String? id;
  @override
  final _i2.LatLng? place;
  @override
  final _i3.DateTimeRange? timerange;
  @override
  final String? title;
  @override
  final DateTime? updated_at;
  @override
  final String? user_id;

  factory _$Gbeacon_set_input(
          [void Function(Gbeacon_set_inputBuilder)? updates]) =>
      (new Gbeacon_set_inputBuilder()..update(updates))._build();

  _$Gbeacon_set_input._(
      {this.comments_count,
      this.created_at,
      this.description,
      this.enabled,
      this.has_picture,
      this.id,
      this.place,
      this.timerange,
      this.title,
      this.updated_at,
      this.user_id})
      : super._();

  @override
  Gbeacon_set_input rebuild(void Function(Gbeacon_set_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gbeacon_set_inputBuilder toBuilder() =>
      new Gbeacon_set_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gbeacon_set_input &&
        comments_count == other.comments_count &&
        created_at == other.created_at &&
        description == other.description &&
        enabled == other.enabled &&
        has_picture == other.has_picture &&
        id == other.id &&
        place == other.place &&
        timerange == other.timerange &&
        title == other.title &&
        updated_at == other.updated_at &&
        user_id == other.user_id;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, comments_count.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, description.hashCode);
    _$hash = $jc(_$hash, enabled.hashCode);
    _$hash = $jc(_$hash, has_picture.hashCode);
    _$hash = $jc(_$hash, id.hashCode);
    _$hash = $jc(_$hash, place.hashCode);
    _$hash = $jc(_$hash, timerange.hashCode);
    _$hash = $jc(_$hash, title.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jc(_$hash, user_id.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gbeacon_set_input')
          ..add('comments_count', comments_count)
          ..add('created_at', created_at)
          ..add('description', description)
          ..add('enabled', enabled)
          ..add('has_picture', has_picture)
          ..add('id', id)
          ..add('place', place)
          ..add('timerange', timerange)
          ..add('title', title)
          ..add('updated_at', updated_at)
          ..add('user_id', user_id))
        .toString();
  }
}

class Gbeacon_set_inputBuilder
    implements Builder<Gbeacon_set_input, Gbeacon_set_inputBuilder> {
  _$Gbeacon_set_input? _$v;

  int? _comments_count;
  int? get comments_count => _$this._comments_count;
  set comments_count(int? comments_count) =>
      _$this._comments_count = comments_count;

  DateTime? _created_at;
  DateTime? get created_at => _$this._created_at;
  set created_at(DateTime? created_at) => _$this._created_at = created_at;

  String? _description;
  String? get description => _$this._description;
  set description(String? description) => _$this._description = description;

  bool? _enabled;
  bool? get enabled => _$this._enabled;
  set enabled(bool? enabled) => _$this._enabled = enabled;

  bool? _has_picture;
  bool? get has_picture => _$this._has_picture;
  set has_picture(bool? has_picture) => _$this._has_picture = has_picture;

  String? _id;
  String? get id => _$this._id;
  set id(String? id) => _$this._id = id;

  _i2.LatLng? _place;
  _i2.LatLng? get place => _$this._place;
  set place(_i2.LatLng? place) => _$this._place = place;

  _i3.DateTimeRange? _timerange;
  _i3.DateTimeRange? get timerange => _$this._timerange;
  set timerange(_i3.DateTimeRange? timerange) => _$this._timerange = timerange;

  String? _title;
  String? get title => _$this._title;
  set title(String? title) => _$this._title = title;

  DateTime? _updated_at;
  DateTime? get updated_at => _$this._updated_at;
  set updated_at(DateTime? updated_at) => _$this._updated_at = updated_at;

  String? _user_id;
  String? get user_id => _$this._user_id;
  set user_id(String? user_id) => _$this._user_id = user_id;

  Gbeacon_set_inputBuilder();

  Gbeacon_set_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _comments_count = $v.comments_count;
      _created_at = $v.created_at;
      _description = $v.description;
      _enabled = $v.enabled;
      _has_picture = $v.has_picture;
      _id = $v.id;
      _place = $v.place;
      _timerange = $v.timerange;
      _title = $v.title;
      _updated_at = $v.updated_at;
      _user_id = $v.user_id;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gbeacon_set_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gbeacon_set_input;
  }

  @override
  void update(void Function(Gbeacon_set_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gbeacon_set_input build() => _build();

  _$Gbeacon_set_input _build() {
    final _$result = _$v ??
        new _$Gbeacon_set_input._(
            comments_count: comments_count,
            created_at: created_at,
            description: description,
            enabled: enabled,
            has_picture: has_picture,
            id: id,
            place: place,
            timerange: timerange,
            title: title,
            updated_at: updated_at,
            user_id: user_id);
    replace(_$result);
    return _$result;
  }
}

class _$Gbeacon_stream_cursor_input extends Gbeacon_stream_cursor_input {
  @override
  final Gbeacon_stream_cursor_value_input initial_value;
  @override
  final Gcursor_ordering? ordering;

  factory _$Gbeacon_stream_cursor_input(
          [void Function(Gbeacon_stream_cursor_inputBuilder)? updates]) =>
      (new Gbeacon_stream_cursor_inputBuilder()..update(updates))._build();

  _$Gbeacon_stream_cursor_input._({required this.initial_value, this.ordering})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        initial_value, r'Gbeacon_stream_cursor_input', 'initial_value');
  }

  @override
  Gbeacon_stream_cursor_input rebuild(
          void Function(Gbeacon_stream_cursor_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gbeacon_stream_cursor_inputBuilder toBuilder() =>
      new Gbeacon_stream_cursor_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gbeacon_stream_cursor_input &&
        initial_value == other.initial_value &&
        ordering == other.ordering;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, initial_value.hashCode);
    _$hash = $jc(_$hash, ordering.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gbeacon_stream_cursor_input')
          ..add('initial_value', initial_value)
          ..add('ordering', ordering))
        .toString();
  }
}

class Gbeacon_stream_cursor_inputBuilder
    implements
        Builder<Gbeacon_stream_cursor_input,
            Gbeacon_stream_cursor_inputBuilder> {
  _$Gbeacon_stream_cursor_input? _$v;

  Gbeacon_stream_cursor_value_inputBuilder? _initial_value;
  Gbeacon_stream_cursor_value_inputBuilder get initial_value =>
      _$this._initial_value ??= new Gbeacon_stream_cursor_value_inputBuilder();
  set initial_value(Gbeacon_stream_cursor_value_inputBuilder? initial_value) =>
      _$this._initial_value = initial_value;

  Gcursor_ordering? _ordering;
  Gcursor_ordering? get ordering => _$this._ordering;
  set ordering(Gcursor_ordering? ordering) => _$this._ordering = ordering;

  Gbeacon_stream_cursor_inputBuilder();

  Gbeacon_stream_cursor_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _initial_value = $v.initial_value.toBuilder();
      _ordering = $v.ordering;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gbeacon_stream_cursor_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gbeacon_stream_cursor_input;
  }

  @override
  void update(void Function(Gbeacon_stream_cursor_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gbeacon_stream_cursor_input build() => _build();

  _$Gbeacon_stream_cursor_input _build() {
    _$Gbeacon_stream_cursor_input _$result;
    try {
      _$result = _$v ??
          new _$Gbeacon_stream_cursor_input._(
              initial_value: initial_value.build(), ordering: ordering);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'initial_value';
        initial_value.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gbeacon_stream_cursor_input', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gbeacon_stream_cursor_value_input
    extends Gbeacon_stream_cursor_value_input {
  @override
  final int? comments_count;
  @override
  final DateTime? created_at;
  @override
  final String? description;
  @override
  final bool? enabled;
  @override
  final bool? has_picture;
  @override
  final String? id;
  @override
  final _i2.LatLng? place;
  @override
  final _i3.DateTimeRange? timerange;
  @override
  final String? title;
  @override
  final DateTime? updated_at;
  @override
  final String? user_id;

  factory _$Gbeacon_stream_cursor_value_input(
          [void Function(Gbeacon_stream_cursor_value_inputBuilder)? updates]) =>
      (new Gbeacon_stream_cursor_value_inputBuilder()..update(updates))
          ._build();

  _$Gbeacon_stream_cursor_value_input._(
      {this.comments_count,
      this.created_at,
      this.description,
      this.enabled,
      this.has_picture,
      this.id,
      this.place,
      this.timerange,
      this.title,
      this.updated_at,
      this.user_id})
      : super._();

  @override
  Gbeacon_stream_cursor_value_input rebuild(
          void Function(Gbeacon_stream_cursor_value_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gbeacon_stream_cursor_value_inputBuilder toBuilder() =>
      new Gbeacon_stream_cursor_value_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gbeacon_stream_cursor_value_input &&
        comments_count == other.comments_count &&
        created_at == other.created_at &&
        description == other.description &&
        enabled == other.enabled &&
        has_picture == other.has_picture &&
        id == other.id &&
        place == other.place &&
        timerange == other.timerange &&
        title == other.title &&
        updated_at == other.updated_at &&
        user_id == other.user_id;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, comments_count.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, description.hashCode);
    _$hash = $jc(_$hash, enabled.hashCode);
    _$hash = $jc(_$hash, has_picture.hashCode);
    _$hash = $jc(_$hash, id.hashCode);
    _$hash = $jc(_$hash, place.hashCode);
    _$hash = $jc(_$hash, timerange.hashCode);
    _$hash = $jc(_$hash, title.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jc(_$hash, user_id.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gbeacon_stream_cursor_value_input')
          ..add('comments_count', comments_count)
          ..add('created_at', created_at)
          ..add('description', description)
          ..add('enabled', enabled)
          ..add('has_picture', has_picture)
          ..add('id', id)
          ..add('place', place)
          ..add('timerange', timerange)
          ..add('title', title)
          ..add('updated_at', updated_at)
          ..add('user_id', user_id))
        .toString();
  }
}

class Gbeacon_stream_cursor_value_inputBuilder
    implements
        Builder<Gbeacon_stream_cursor_value_input,
            Gbeacon_stream_cursor_value_inputBuilder> {
  _$Gbeacon_stream_cursor_value_input? _$v;

  int? _comments_count;
  int? get comments_count => _$this._comments_count;
  set comments_count(int? comments_count) =>
      _$this._comments_count = comments_count;

  DateTime? _created_at;
  DateTime? get created_at => _$this._created_at;
  set created_at(DateTime? created_at) => _$this._created_at = created_at;

  String? _description;
  String? get description => _$this._description;
  set description(String? description) => _$this._description = description;

  bool? _enabled;
  bool? get enabled => _$this._enabled;
  set enabled(bool? enabled) => _$this._enabled = enabled;

  bool? _has_picture;
  bool? get has_picture => _$this._has_picture;
  set has_picture(bool? has_picture) => _$this._has_picture = has_picture;

  String? _id;
  String? get id => _$this._id;
  set id(String? id) => _$this._id = id;

  _i2.LatLng? _place;
  _i2.LatLng? get place => _$this._place;
  set place(_i2.LatLng? place) => _$this._place = place;

  _i3.DateTimeRange? _timerange;
  _i3.DateTimeRange? get timerange => _$this._timerange;
  set timerange(_i3.DateTimeRange? timerange) => _$this._timerange = timerange;

  String? _title;
  String? get title => _$this._title;
  set title(String? title) => _$this._title = title;

  DateTime? _updated_at;
  DateTime? get updated_at => _$this._updated_at;
  set updated_at(DateTime? updated_at) => _$this._updated_at = updated_at;

  String? _user_id;
  String? get user_id => _$this._user_id;
  set user_id(String? user_id) => _$this._user_id = user_id;

  Gbeacon_stream_cursor_value_inputBuilder();

  Gbeacon_stream_cursor_value_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _comments_count = $v.comments_count;
      _created_at = $v.created_at;
      _description = $v.description;
      _enabled = $v.enabled;
      _has_picture = $v.has_picture;
      _id = $v.id;
      _place = $v.place;
      _timerange = $v.timerange;
      _title = $v.title;
      _updated_at = $v.updated_at;
      _user_id = $v.user_id;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gbeacon_stream_cursor_value_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gbeacon_stream_cursor_value_input;
  }

  @override
  void update(
      void Function(Gbeacon_stream_cursor_value_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gbeacon_stream_cursor_value_input build() => _build();

  _$Gbeacon_stream_cursor_value_input _build() {
    final _$result = _$v ??
        new _$Gbeacon_stream_cursor_value_input._(
            comments_count: comments_count,
            created_at: created_at,
            description: description,
            enabled: enabled,
            has_picture: has_picture,
            id: id,
            place: place,
            timerange: timerange,
            title: title,
            updated_at: updated_at,
            user_id: user_id);
    replace(_$result);
    return _$result;
  }
}

class _$Gbeacon_updates extends Gbeacon_updates {
  @override
  final Gbeacon_inc_input? G_inc;
  @override
  final Gbeacon_set_input? G_set;
  @override
  final Gbeacon_bool_exp where;

  factory _$Gbeacon_updates([void Function(Gbeacon_updatesBuilder)? updates]) =>
      (new Gbeacon_updatesBuilder()..update(updates))._build();

  _$Gbeacon_updates._({this.G_inc, this.G_set, required this.where})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(where, r'Gbeacon_updates', 'where');
  }

  @override
  Gbeacon_updates rebuild(void Function(Gbeacon_updatesBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gbeacon_updatesBuilder toBuilder() =>
      new Gbeacon_updatesBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gbeacon_updates &&
        G_inc == other.G_inc &&
        G_set == other.G_set &&
        where == other.where;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, G_inc.hashCode);
    _$hash = $jc(_$hash, G_set.hashCode);
    _$hash = $jc(_$hash, where.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gbeacon_updates')
          ..add('G_inc', G_inc)
          ..add('G_set', G_set)
          ..add('where', where))
        .toString();
  }
}

class Gbeacon_updatesBuilder
    implements Builder<Gbeacon_updates, Gbeacon_updatesBuilder> {
  _$Gbeacon_updates? _$v;

  Gbeacon_inc_inputBuilder? _G_inc;
  Gbeacon_inc_inputBuilder get G_inc =>
      _$this._G_inc ??= new Gbeacon_inc_inputBuilder();
  set G_inc(Gbeacon_inc_inputBuilder? G_inc) => _$this._G_inc = G_inc;

  Gbeacon_set_inputBuilder? _G_set;
  Gbeacon_set_inputBuilder get G_set =>
      _$this._G_set ??= new Gbeacon_set_inputBuilder();
  set G_set(Gbeacon_set_inputBuilder? G_set) => _$this._G_set = G_set;

  Gbeacon_bool_expBuilder? _where;
  Gbeacon_bool_expBuilder get where =>
      _$this._where ??= new Gbeacon_bool_expBuilder();
  set where(Gbeacon_bool_expBuilder? where) => _$this._where = where;

  Gbeacon_updatesBuilder();

  Gbeacon_updatesBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _G_inc = $v.G_inc?.toBuilder();
      _G_set = $v.G_set?.toBuilder();
      _where = $v.where.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gbeacon_updates other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gbeacon_updates;
  }

  @override
  void update(void Function(Gbeacon_updatesBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gbeacon_updates build() => _build();

  _$Gbeacon_updates _build() {
    _$Gbeacon_updates _$result;
    try {
      _$result = _$v ??
          new _$Gbeacon_updates._(
              G_inc: _G_inc?.build(),
              G_set: _G_set?.build(),
              where: where.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'G_inc';
        _G_inc?.build();
        _$failedField = 'G_set';
        _G_set?.build();
        _$failedField = 'where';
        where.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gbeacon_updates', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GBoolean_comparison_exp extends GBoolean_comparison_exp {
  @override
  final bool? G_eq;
  @override
  final bool? G_gt;
  @override
  final bool? G_gte;
  @override
  final BuiltList<bool>? G_in;
  @override
  final bool? G_is_null;
  @override
  final bool? G_lt;
  @override
  final bool? G_lte;
  @override
  final bool? G_neq;
  @override
  final BuiltList<bool>? G_nin;

  factory _$GBoolean_comparison_exp(
          [void Function(GBoolean_comparison_expBuilder)? updates]) =>
      (new GBoolean_comparison_expBuilder()..update(updates))._build();

  _$GBoolean_comparison_exp._(
      {this.G_eq,
      this.G_gt,
      this.G_gte,
      this.G_in,
      this.G_is_null,
      this.G_lt,
      this.G_lte,
      this.G_neq,
      this.G_nin})
      : super._();

  @override
  GBoolean_comparison_exp rebuild(
          void Function(GBoolean_comparison_expBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GBoolean_comparison_expBuilder toBuilder() =>
      new GBoolean_comparison_expBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GBoolean_comparison_exp &&
        G_eq == other.G_eq &&
        G_gt == other.G_gt &&
        G_gte == other.G_gte &&
        G_in == other.G_in &&
        G_is_null == other.G_is_null &&
        G_lt == other.G_lt &&
        G_lte == other.G_lte &&
        G_neq == other.G_neq &&
        G_nin == other.G_nin;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, G_eq.hashCode);
    _$hash = $jc(_$hash, G_gt.hashCode);
    _$hash = $jc(_$hash, G_gte.hashCode);
    _$hash = $jc(_$hash, G_in.hashCode);
    _$hash = $jc(_$hash, G_is_null.hashCode);
    _$hash = $jc(_$hash, G_lt.hashCode);
    _$hash = $jc(_$hash, G_lte.hashCode);
    _$hash = $jc(_$hash, G_neq.hashCode);
    _$hash = $jc(_$hash, G_nin.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'GBoolean_comparison_exp')
          ..add('G_eq', G_eq)
          ..add('G_gt', G_gt)
          ..add('G_gte', G_gte)
          ..add('G_in', G_in)
          ..add('G_is_null', G_is_null)
          ..add('G_lt', G_lt)
          ..add('G_lte', G_lte)
          ..add('G_neq', G_neq)
          ..add('G_nin', G_nin))
        .toString();
  }
}

class GBoolean_comparison_expBuilder
    implements
        Builder<GBoolean_comparison_exp, GBoolean_comparison_expBuilder> {
  _$GBoolean_comparison_exp? _$v;

  bool? _G_eq;
  bool? get G_eq => _$this._G_eq;
  set G_eq(bool? G_eq) => _$this._G_eq = G_eq;

  bool? _G_gt;
  bool? get G_gt => _$this._G_gt;
  set G_gt(bool? G_gt) => _$this._G_gt = G_gt;

  bool? _G_gte;
  bool? get G_gte => _$this._G_gte;
  set G_gte(bool? G_gte) => _$this._G_gte = G_gte;

  ListBuilder<bool>? _G_in;
  ListBuilder<bool> get G_in => _$this._G_in ??= new ListBuilder<bool>();
  set G_in(ListBuilder<bool>? G_in) => _$this._G_in = G_in;

  bool? _G_is_null;
  bool? get G_is_null => _$this._G_is_null;
  set G_is_null(bool? G_is_null) => _$this._G_is_null = G_is_null;

  bool? _G_lt;
  bool? get G_lt => _$this._G_lt;
  set G_lt(bool? G_lt) => _$this._G_lt = G_lt;

  bool? _G_lte;
  bool? get G_lte => _$this._G_lte;
  set G_lte(bool? G_lte) => _$this._G_lte = G_lte;

  bool? _G_neq;
  bool? get G_neq => _$this._G_neq;
  set G_neq(bool? G_neq) => _$this._G_neq = G_neq;

  ListBuilder<bool>? _G_nin;
  ListBuilder<bool> get G_nin => _$this._G_nin ??= new ListBuilder<bool>();
  set G_nin(ListBuilder<bool>? G_nin) => _$this._G_nin = G_nin;

  GBoolean_comparison_expBuilder();

  GBoolean_comparison_expBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _G_eq = $v.G_eq;
      _G_gt = $v.G_gt;
      _G_gte = $v.G_gte;
      _G_in = $v.G_in?.toBuilder();
      _G_is_null = $v.G_is_null;
      _G_lt = $v.G_lt;
      _G_lte = $v.G_lte;
      _G_neq = $v.G_neq;
      _G_nin = $v.G_nin?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GBoolean_comparison_exp other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GBoolean_comparison_exp;
  }

  @override
  void update(void Function(GBoolean_comparison_expBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  GBoolean_comparison_exp build() => _build();

  _$GBoolean_comparison_exp _build() {
    _$GBoolean_comparison_exp _$result;
    try {
      _$result = _$v ??
          new _$GBoolean_comparison_exp._(
              G_eq: G_eq,
              G_gt: G_gt,
              G_gte: G_gte,
              G_in: _G_in?.build(),
              G_is_null: G_is_null,
              G_lt: G_lt,
              G_lte: G_lte,
              G_neq: G_neq,
              G_nin: _G_nin?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'G_in';
        _G_in?.build();

        _$failedField = 'G_nin';
        _G_nin?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'GBoolean_comparison_exp', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gcomment_aggregate_bool_exp extends Gcomment_aggregate_bool_exp {
  @override
  final Gcomment_aggregate_bool_exp_count? count;

  factory _$Gcomment_aggregate_bool_exp(
          [void Function(Gcomment_aggregate_bool_expBuilder)? updates]) =>
      (new Gcomment_aggregate_bool_expBuilder()..update(updates))._build();

  _$Gcomment_aggregate_bool_exp._({this.count}) : super._();

  @override
  Gcomment_aggregate_bool_exp rebuild(
          void Function(Gcomment_aggregate_bool_expBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gcomment_aggregate_bool_expBuilder toBuilder() =>
      new Gcomment_aggregate_bool_expBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gcomment_aggregate_bool_exp && count == other.count;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, count.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gcomment_aggregate_bool_exp')
          ..add('count', count))
        .toString();
  }
}

class Gcomment_aggregate_bool_expBuilder
    implements
        Builder<Gcomment_aggregate_bool_exp,
            Gcomment_aggregate_bool_expBuilder> {
  _$Gcomment_aggregate_bool_exp? _$v;

  Gcomment_aggregate_bool_exp_countBuilder? _count;
  Gcomment_aggregate_bool_exp_countBuilder get count =>
      _$this._count ??= new Gcomment_aggregate_bool_exp_countBuilder();
  set count(Gcomment_aggregate_bool_exp_countBuilder? count) =>
      _$this._count = count;

  Gcomment_aggregate_bool_expBuilder();

  Gcomment_aggregate_bool_expBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _count = $v.count?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gcomment_aggregate_bool_exp other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gcomment_aggregate_bool_exp;
  }

  @override
  void update(void Function(Gcomment_aggregate_bool_expBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gcomment_aggregate_bool_exp build() => _build();

  _$Gcomment_aggregate_bool_exp _build() {
    _$Gcomment_aggregate_bool_exp _$result;
    try {
      _$result =
          _$v ?? new _$Gcomment_aggregate_bool_exp._(count: _count?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'count';
        _count?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gcomment_aggregate_bool_exp', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gcomment_aggregate_bool_exp_count
    extends Gcomment_aggregate_bool_exp_count {
  @override
  final BuiltList<Gcomment_select_column>? arguments;
  @override
  final bool? distinct;
  @override
  final Gcomment_bool_exp? filter;
  @override
  final GInt_comparison_exp predicate;

  factory _$Gcomment_aggregate_bool_exp_count(
          [void Function(Gcomment_aggregate_bool_exp_countBuilder)? updates]) =>
      (new Gcomment_aggregate_bool_exp_countBuilder()..update(updates))
          ._build();

  _$Gcomment_aggregate_bool_exp_count._(
      {this.arguments, this.distinct, this.filter, required this.predicate})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        predicate, r'Gcomment_aggregate_bool_exp_count', 'predicate');
  }

  @override
  Gcomment_aggregate_bool_exp_count rebuild(
          void Function(Gcomment_aggregate_bool_exp_countBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gcomment_aggregate_bool_exp_countBuilder toBuilder() =>
      new Gcomment_aggregate_bool_exp_countBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gcomment_aggregate_bool_exp_count &&
        arguments == other.arguments &&
        distinct == other.distinct &&
        filter == other.filter &&
        predicate == other.predicate;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, arguments.hashCode);
    _$hash = $jc(_$hash, distinct.hashCode);
    _$hash = $jc(_$hash, filter.hashCode);
    _$hash = $jc(_$hash, predicate.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gcomment_aggregate_bool_exp_count')
          ..add('arguments', arguments)
          ..add('distinct', distinct)
          ..add('filter', filter)
          ..add('predicate', predicate))
        .toString();
  }
}

class Gcomment_aggregate_bool_exp_countBuilder
    implements
        Builder<Gcomment_aggregate_bool_exp_count,
            Gcomment_aggregate_bool_exp_countBuilder> {
  _$Gcomment_aggregate_bool_exp_count? _$v;

  ListBuilder<Gcomment_select_column>? _arguments;
  ListBuilder<Gcomment_select_column> get arguments =>
      _$this._arguments ??= new ListBuilder<Gcomment_select_column>();
  set arguments(ListBuilder<Gcomment_select_column>? arguments) =>
      _$this._arguments = arguments;

  bool? _distinct;
  bool? get distinct => _$this._distinct;
  set distinct(bool? distinct) => _$this._distinct = distinct;

  Gcomment_bool_expBuilder? _filter;
  Gcomment_bool_expBuilder get filter =>
      _$this._filter ??= new Gcomment_bool_expBuilder();
  set filter(Gcomment_bool_expBuilder? filter) => _$this._filter = filter;

  GInt_comparison_expBuilder? _predicate;
  GInt_comparison_expBuilder get predicate =>
      _$this._predicate ??= new GInt_comparison_expBuilder();
  set predicate(GInt_comparison_expBuilder? predicate) =>
      _$this._predicate = predicate;

  Gcomment_aggregate_bool_exp_countBuilder();

  Gcomment_aggregate_bool_exp_countBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _arguments = $v.arguments?.toBuilder();
      _distinct = $v.distinct;
      _filter = $v.filter?.toBuilder();
      _predicate = $v.predicate.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gcomment_aggregate_bool_exp_count other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gcomment_aggregate_bool_exp_count;
  }

  @override
  void update(
      void Function(Gcomment_aggregate_bool_exp_countBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gcomment_aggregate_bool_exp_count build() => _build();

  _$Gcomment_aggregate_bool_exp_count _build() {
    _$Gcomment_aggregate_bool_exp_count _$result;
    try {
      _$result = _$v ??
          new _$Gcomment_aggregate_bool_exp_count._(
              arguments: _arguments?.build(),
              distinct: distinct,
              filter: _filter?.build(),
              predicate: predicate.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'arguments';
        _arguments?.build();

        _$failedField = 'filter';
        _filter?.build();
        _$failedField = 'predicate';
        predicate.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gcomment_aggregate_bool_exp_count', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gcomment_aggregate_order_by extends Gcomment_aggregate_order_by {
  @override
  final Gorder_by? count;
  @override
  final Gcomment_max_order_by? max;
  @override
  final Gcomment_min_order_by? min;

  factory _$Gcomment_aggregate_order_by(
          [void Function(Gcomment_aggregate_order_byBuilder)? updates]) =>
      (new Gcomment_aggregate_order_byBuilder()..update(updates))._build();

  _$Gcomment_aggregate_order_by._({this.count, this.max, this.min}) : super._();

  @override
  Gcomment_aggregate_order_by rebuild(
          void Function(Gcomment_aggregate_order_byBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gcomment_aggregate_order_byBuilder toBuilder() =>
      new Gcomment_aggregate_order_byBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gcomment_aggregate_order_by &&
        count == other.count &&
        max == other.max &&
        min == other.min;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, count.hashCode);
    _$hash = $jc(_$hash, max.hashCode);
    _$hash = $jc(_$hash, min.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gcomment_aggregate_order_by')
          ..add('count', count)
          ..add('max', max)
          ..add('min', min))
        .toString();
  }
}

class Gcomment_aggregate_order_byBuilder
    implements
        Builder<Gcomment_aggregate_order_by,
            Gcomment_aggregate_order_byBuilder> {
  _$Gcomment_aggregate_order_by? _$v;

  Gorder_by? _count;
  Gorder_by? get count => _$this._count;
  set count(Gorder_by? count) => _$this._count = count;

  Gcomment_max_order_byBuilder? _max;
  Gcomment_max_order_byBuilder get max =>
      _$this._max ??= new Gcomment_max_order_byBuilder();
  set max(Gcomment_max_order_byBuilder? max) => _$this._max = max;

  Gcomment_min_order_byBuilder? _min;
  Gcomment_min_order_byBuilder get min =>
      _$this._min ??= new Gcomment_min_order_byBuilder();
  set min(Gcomment_min_order_byBuilder? min) => _$this._min = min;

  Gcomment_aggregate_order_byBuilder();

  Gcomment_aggregate_order_byBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _count = $v.count;
      _max = $v.max?.toBuilder();
      _min = $v.min?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gcomment_aggregate_order_by other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gcomment_aggregate_order_by;
  }

  @override
  void update(void Function(Gcomment_aggregate_order_byBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gcomment_aggregate_order_by build() => _build();

  _$Gcomment_aggregate_order_by _build() {
    _$Gcomment_aggregate_order_by _$result;
    try {
      _$result = _$v ??
          new _$Gcomment_aggregate_order_by._(
              count: count, max: _max?.build(), min: _min?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'max';
        _max?.build();
        _$failedField = 'min';
        _min?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gcomment_aggregate_order_by', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gcomment_arr_rel_insert_input extends Gcomment_arr_rel_insert_input {
  @override
  final BuiltList<Gcomment_insert_input> data;
  @override
  final Gcomment_on_conflict? on_conflict;

  factory _$Gcomment_arr_rel_insert_input(
          [void Function(Gcomment_arr_rel_insert_inputBuilder)? updates]) =>
      (new Gcomment_arr_rel_insert_inputBuilder()..update(updates))._build();

  _$Gcomment_arr_rel_insert_input._({required this.data, this.on_conflict})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        data, r'Gcomment_arr_rel_insert_input', 'data');
  }

  @override
  Gcomment_arr_rel_insert_input rebuild(
          void Function(Gcomment_arr_rel_insert_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gcomment_arr_rel_insert_inputBuilder toBuilder() =>
      new Gcomment_arr_rel_insert_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gcomment_arr_rel_insert_input &&
        data == other.data &&
        on_conflict == other.on_conflict;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, data.hashCode);
    _$hash = $jc(_$hash, on_conflict.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gcomment_arr_rel_insert_input')
          ..add('data', data)
          ..add('on_conflict', on_conflict))
        .toString();
  }
}

class Gcomment_arr_rel_insert_inputBuilder
    implements
        Builder<Gcomment_arr_rel_insert_input,
            Gcomment_arr_rel_insert_inputBuilder> {
  _$Gcomment_arr_rel_insert_input? _$v;

  ListBuilder<Gcomment_insert_input>? _data;
  ListBuilder<Gcomment_insert_input> get data =>
      _$this._data ??= new ListBuilder<Gcomment_insert_input>();
  set data(ListBuilder<Gcomment_insert_input>? data) => _$this._data = data;

  Gcomment_on_conflictBuilder? _on_conflict;
  Gcomment_on_conflictBuilder get on_conflict =>
      _$this._on_conflict ??= new Gcomment_on_conflictBuilder();
  set on_conflict(Gcomment_on_conflictBuilder? on_conflict) =>
      _$this._on_conflict = on_conflict;

  Gcomment_arr_rel_insert_inputBuilder();

  Gcomment_arr_rel_insert_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _data = $v.data.toBuilder();
      _on_conflict = $v.on_conflict?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gcomment_arr_rel_insert_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gcomment_arr_rel_insert_input;
  }

  @override
  void update(void Function(Gcomment_arr_rel_insert_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gcomment_arr_rel_insert_input build() => _build();

  _$Gcomment_arr_rel_insert_input _build() {
    _$Gcomment_arr_rel_insert_input _$result;
    try {
      _$result = _$v ??
          new _$Gcomment_arr_rel_insert_input._(
              data: data.build(), on_conflict: _on_conflict?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'data';
        data.build();
        _$failedField = 'on_conflict';
        _on_conflict?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gcomment_arr_rel_insert_input', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gcomment_bool_exp extends Gcomment_bool_exp {
  @override
  final BuiltList<Gcomment_bool_exp>? G_and;
  @override
  final Gcomment_bool_exp? G_not;
  @override
  final BuiltList<Gcomment_bool_exp>? G_or;
  @override
  final Guser_bool_exp? author;
  @override
  final GString_comparison_exp? beacon_id;
  @override
  final GString_comparison_exp? content;
  @override
  final Gtimestamptz_comparison_exp? created_at;
  @override
  final GString_comparison_exp? id;
  @override
  final GString_comparison_exp? user_id;

  factory _$Gcomment_bool_exp(
          [void Function(Gcomment_bool_expBuilder)? updates]) =>
      (new Gcomment_bool_expBuilder()..update(updates))._build();

  _$Gcomment_bool_exp._(
      {this.G_and,
      this.G_not,
      this.G_or,
      this.author,
      this.beacon_id,
      this.content,
      this.created_at,
      this.id,
      this.user_id})
      : super._();

  @override
  Gcomment_bool_exp rebuild(void Function(Gcomment_bool_expBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gcomment_bool_expBuilder toBuilder() =>
      new Gcomment_bool_expBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gcomment_bool_exp &&
        G_and == other.G_and &&
        G_not == other.G_not &&
        G_or == other.G_or &&
        author == other.author &&
        beacon_id == other.beacon_id &&
        content == other.content &&
        created_at == other.created_at &&
        id == other.id &&
        user_id == other.user_id;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, G_and.hashCode);
    _$hash = $jc(_$hash, G_not.hashCode);
    _$hash = $jc(_$hash, G_or.hashCode);
    _$hash = $jc(_$hash, author.hashCode);
    _$hash = $jc(_$hash, beacon_id.hashCode);
    _$hash = $jc(_$hash, content.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, id.hashCode);
    _$hash = $jc(_$hash, user_id.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gcomment_bool_exp')
          ..add('G_and', G_and)
          ..add('G_not', G_not)
          ..add('G_or', G_or)
          ..add('author', author)
          ..add('beacon_id', beacon_id)
          ..add('content', content)
          ..add('created_at', created_at)
          ..add('id', id)
          ..add('user_id', user_id))
        .toString();
  }
}

class Gcomment_bool_expBuilder
    implements Builder<Gcomment_bool_exp, Gcomment_bool_expBuilder> {
  _$Gcomment_bool_exp? _$v;

  ListBuilder<Gcomment_bool_exp>? _G_and;
  ListBuilder<Gcomment_bool_exp> get G_and =>
      _$this._G_and ??= new ListBuilder<Gcomment_bool_exp>();
  set G_and(ListBuilder<Gcomment_bool_exp>? G_and) => _$this._G_and = G_and;

  Gcomment_bool_expBuilder? _G_not;
  Gcomment_bool_expBuilder get G_not =>
      _$this._G_not ??= new Gcomment_bool_expBuilder();
  set G_not(Gcomment_bool_expBuilder? G_not) => _$this._G_not = G_not;

  ListBuilder<Gcomment_bool_exp>? _G_or;
  ListBuilder<Gcomment_bool_exp> get G_or =>
      _$this._G_or ??= new ListBuilder<Gcomment_bool_exp>();
  set G_or(ListBuilder<Gcomment_bool_exp>? G_or) => _$this._G_or = G_or;

  Guser_bool_expBuilder? _author;
  Guser_bool_expBuilder get author =>
      _$this._author ??= new Guser_bool_expBuilder();
  set author(Guser_bool_expBuilder? author) => _$this._author = author;

  GString_comparison_expBuilder? _beacon_id;
  GString_comparison_expBuilder get beacon_id =>
      _$this._beacon_id ??= new GString_comparison_expBuilder();
  set beacon_id(GString_comparison_expBuilder? beacon_id) =>
      _$this._beacon_id = beacon_id;

  GString_comparison_expBuilder? _content;
  GString_comparison_expBuilder get content =>
      _$this._content ??= new GString_comparison_expBuilder();
  set content(GString_comparison_expBuilder? content) =>
      _$this._content = content;

  Gtimestamptz_comparison_expBuilder? _created_at;
  Gtimestamptz_comparison_expBuilder get created_at =>
      _$this._created_at ??= new Gtimestamptz_comparison_expBuilder();
  set created_at(Gtimestamptz_comparison_expBuilder? created_at) =>
      _$this._created_at = created_at;

  GString_comparison_expBuilder? _id;
  GString_comparison_expBuilder get id =>
      _$this._id ??= new GString_comparison_expBuilder();
  set id(GString_comparison_expBuilder? id) => _$this._id = id;

  GString_comparison_expBuilder? _user_id;
  GString_comparison_expBuilder get user_id =>
      _$this._user_id ??= new GString_comparison_expBuilder();
  set user_id(GString_comparison_expBuilder? user_id) =>
      _$this._user_id = user_id;

  Gcomment_bool_expBuilder();

  Gcomment_bool_expBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _G_and = $v.G_and?.toBuilder();
      _G_not = $v.G_not?.toBuilder();
      _G_or = $v.G_or?.toBuilder();
      _author = $v.author?.toBuilder();
      _beacon_id = $v.beacon_id?.toBuilder();
      _content = $v.content?.toBuilder();
      _created_at = $v.created_at?.toBuilder();
      _id = $v.id?.toBuilder();
      _user_id = $v.user_id?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gcomment_bool_exp other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gcomment_bool_exp;
  }

  @override
  void update(void Function(Gcomment_bool_expBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gcomment_bool_exp build() => _build();

  _$Gcomment_bool_exp _build() {
    _$Gcomment_bool_exp _$result;
    try {
      _$result = _$v ??
          new _$Gcomment_bool_exp._(
              G_and: _G_and?.build(),
              G_not: _G_not?.build(),
              G_or: _G_or?.build(),
              author: _author?.build(),
              beacon_id: _beacon_id?.build(),
              content: _content?.build(),
              created_at: _created_at?.build(),
              id: _id?.build(),
              user_id: _user_id?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'G_and';
        _G_and?.build();
        _$failedField = 'G_not';
        _G_not?.build();
        _$failedField = 'G_or';
        _G_or?.build();
        _$failedField = 'author';
        _author?.build();
        _$failedField = 'beacon_id';
        _beacon_id?.build();
        _$failedField = 'content';
        _content?.build();
        _$failedField = 'created_at';
        _created_at?.build();
        _$failedField = 'id';
        _id?.build();
        _$failedField = 'user_id';
        _user_id?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gcomment_bool_exp', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gcomment_insert_input extends Gcomment_insert_input {
  @override
  final Guser_obj_rel_insert_input? author;
  @override
  final String? beacon_id;
  @override
  final String? content;
  @override
  final DateTime? created_at;
  @override
  final String? id;
  @override
  final String? user_id;

  factory _$Gcomment_insert_input(
          [void Function(Gcomment_insert_inputBuilder)? updates]) =>
      (new Gcomment_insert_inputBuilder()..update(updates))._build();

  _$Gcomment_insert_input._(
      {this.author,
      this.beacon_id,
      this.content,
      this.created_at,
      this.id,
      this.user_id})
      : super._();

  @override
  Gcomment_insert_input rebuild(
          void Function(Gcomment_insert_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gcomment_insert_inputBuilder toBuilder() =>
      new Gcomment_insert_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gcomment_insert_input &&
        author == other.author &&
        beacon_id == other.beacon_id &&
        content == other.content &&
        created_at == other.created_at &&
        id == other.id &&
        user_id == other.user_id;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, author.hashCode);
    _$hash = $jc(_$hash, beacon_id.hashCode);
    _$hash = $jc(_$hash, content.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, id.hashCode);
    _$hash = $jc(_$hash, user_id.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gcomment_insert_input')
          ..add('author', author)
          ..add('beacon_id', beacon_id)
          ..add('content', content)
          ..add('created_at', created_at)
          ..add('id', id)
          ..add('user_id', user_id))
        .toString();
  }
}

class Gcomment_insert_inputBuilder
    implements Builder<Gcomment_insert_input, Gcomment_insert_inputBuilder> {
  _$Gcomment_insert_input? _$v;

  Guser_obj_rel_insert_inputBuilder? _author;
  Guser_obj_rel_insert_inputBuilder get author =>
      _$this._author ??= new Guser_obj_rel_insert_inputBuilder();
  set author(Guser_obj_rel_insert_inputBuilder? author) =>
      _$this._author = author;

  String? _beacon_id;
  String? get beacon_id => _$this._beacon_id;
  set beacon_id(String? beacon_id) => _$this._beacon_id = beacon_id;

  String? _content;
  String? get content => _$this._content;
  set content(String? content) => _$this._content = content;

  DateTime? _created_at;
  DateTime? get created_at => _$this._created_at;
  set created_at(DateTime? created_at) => _$this._created_at = created_at;

  String? _id;
  String? get id => _$this._id;
  set id(String? id) => _$this._id = id;

  String? _user_id;
  String? get user_id => _$this._user_id;
  set user_id(String? user_id) => _$this._user_id = user_id;

  Gcomment_insert_inputBuilder();

  Gcomment_insert_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _author = $v.author?.toBuilder();
      _beacon_id = $v.beacon_id;
      _content = $v.content;
      _created_at = $v.created_at;
      _id = $v.id;
      _user_id = $v.user_id;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gcomment_insert_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gcomment_insert_input;
  }

  @override
  void update(void Function(Gcomment_insert_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gcomment_insert_input build() => _build();

  _$Gcomment_insert_input _build() {
    _$Gcomment_insert_input _$result;
    try {
      _$result = _$v ??
          new _$Gcomment_insert_input._(
              author: _author?.build(),
              beacon_id: beacon_id,
              content: content,
              created_at: created_at,
              id: id,
              user_id: user_id);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'author';
        _author?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gcomment_insert_input', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gcomment_max_order_by extends Gcomment_max_order_by {
  @override
  final Gorder_by? beacon_id;
  @override
  final Gorder_by? content;
  @override
  final Gorder_by? created_at;
  @override
  final Gorder_by? id;
  @override
  final Gorder_by? user_id;

  factory _$Gcomment_max_order_by(
          [void Function(Gcomment_max_order_byBuilder)? updates]) =>
      (new Gcomment_max_order_byBuilder()..update(updates))._build();

  _$Gcomment_max_order_by._(
      {this.beacon_id, this.content, this.created_at, this.id, this.user_id})
      : super._();

  @override
  Gcomment_max_order_by rebuild(
          void Function(Gcomment_max_order_byBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gcomment_max_order_byBuilder toBuilder() =>
      new Gcomment_max_order_byBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gcomment_max_order_by &&
        beacon_id == other.beacon_id &&
        content == other.content &&
        created_at == other.created_at &&
        id == other.id &&
        user_id == other.user_id;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, beacon_id.hashCode);
    _$hash = $jc(_$hash, content.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, id.hashCode);
    _$hash = $jc(_$hash, user_id.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gcomment_max_order_by')
          ..add('beacon_id', beacon_id)
          ..add('content', content)
          ..add('created_at', created_at)
          ..add('id', id)
          ..add('user_id', user_id))
        .toString();
  }
}

class Gcomment_max_order_byBuilder
    implements Builder<Gcomment_max_order_by, Gcomment_max_order_byBuilder> {
  _$Gcomment_max_order_by? _$v;

  Gorder_by? _beacon_id;
  Gorder_by? get beacon_id => _$this._beacon_id;
  set beacon_id(Gorder_by? beacon_id) => _$this._beacon_id = beacon_id;

  Gorder_by? _content;
  Gorder_by? get content => _$this._content;
  set content(Gorder_by? content) => _$this._content = content;

  Gorder_by? _created_at;
  Gorder_by? get created_at => _$this._created_at;
  set created_at(Gorder_by? created_at) => _$this._created_at = created_at;

  Gorder_by? _id;
  Gorder_by? get id => _$this._id;
  set id(Gorder_by? id) => _$this._id = id;

  Gorder_by? _user_id;
  Gorder_by? get user_id => _$this._user_id;
  set user_id(Gorder_by? user_id) => _$this._user_id = user_id;

  Gcomment_max_order_byBuilder();

  Gcomment_max_order_byBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _beacon_id = $v.beacon_id;
      _content = $v.content;
      _created_at = $v.created_at;
      _id = $v.id;
      _user_id = $v.user_id;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gcomment_max_order_by other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gcomment_max_order_by;
  }

  @override
  void update(void Function(Gcomment_max_order_byBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gcomment_max_order_by build() => _build();

  _$Gcomment_max_order_by _build() {
    final _$result = _$v ??
        new _$Gcomment_max_order_by._(
            beacon_id: beacon_id,
            content: content,
            created_at: created_at,
            id: id,
            user_id: user_id);
    replace(_$result);
    return _$result;
  }
}

class _$Gcomment_min_order_by extends Gcomment_min_order_by {
  @override
  final Gorder_by? beacon_id;
  @override
  final Gorder_by? content;
  @override
  final Gorder_by? created_at;
  @override
  final Gorder_by? id;
  @override
  final Gorder_by? user_id;

  factory _$Gcomment_min_order_by(
          [void Function(Gcomment_min_order_byBuilder)? updates]) =>
      (new Gcomment_min_order_byBuilder()..update(updates))._build();

  _$Gcomment_min_order_by._(
      {this.beacon_id, this.content, this.created_at, this.id, this.user_id})
      : super._();

  @override
  Gcomment_min_order_by rebuild(
          void Function(Gcomment_min_order_byBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gcomment_min_order_byBuilder toBuilder() =>
      new Gcomment_min_order_byBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gcomment_min_order_by &&
        beacon_id == other.beacon_id &&
        content == other.content &&
        created_at == other.created_at &&
        id == other.id &&
        user_id == other.user_id;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, beacon_id.hashCode);
    _$hash = $jc(_$hash, content.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, id.hashCode);
    _$hash = $jc(_$hash, user_id.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gcomment_min_order_by')
          ..add('beacon_id', beacon_id)
          ..add('content', content)
          ..add('created_at', created_at)
          ..add('id', id)
          ..add('user_id', user_id))
        .toString();
  }
}

class Gcomment_min_order_byBuilder
    implements Builder<Gcomment_min_order_by, Gcomment_min_order_byBuilder> {
  _$Gcomment_min_order_by? _$v;

  Gorder_by? _beacon_id;
  Gorder_by? get beacon_id => _$this._beacon_id;
  set beacon_id(Gorder_by? beacon_id) => _$this._beacon_id = beacon_id;

  Gorder_by? _content;
  Gorder_by? get content => _$this._content;
  set content(Gorder_by? content) => _$this._content = content;

  Gorder_by? _created_at;
  Gorder_by? get created_at => _$this._created_at;
  set created_at(Gorder_by? created_at) => _$this._created_at = created_at;

  Gorder_by? _id;
  Gorder_by? get id => _$this._id;
  set id(Gorder_by? id) => _$this._id = id;

  Gorder_by? _user_id;
  Gorder_by? get user_id => _$this._user_id;
  set user_id(Gorder_by? user_id) => _$this._user_id = user_id;

  Gcomment_min_order_byBuilder();

  Gcomment_min_order_byBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _beacon_id = $v.beacon_id;
      _content = $v.content;
      _created_at = $v.created_at;
      _id = $v.id;
      _user_id = $v.user_id;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gcomment_min_order_by other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gcomment_min_order_by;
  }

  @override
  void update(void Function(Gcomment_min_order_byBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gcomment_min_order_by build() => _build();

  _$Gcomment_min_order_by _build() {
    final _$result = _$v ??
        new _$Gcomment_min_order_by._(
            beacon_id: beacon_id,
            content: content,
            created_at: created_at,
            id: id,
            user_id: user_id);
    replace(_$result);
    return _$result;
  }
}

class _$Gcomment_on_conflict extends Gcomment_on_conflict {
  @override
  final Gcomment_constraint constraint;
  @override
  final BuiltList<Gcomment_update_column> update_columns;
  @override
  final Gcomment_bool_exp? where;

  factory _$Gcomment_on_conflict(
          [void Function(Gcomment_on_conflictBuilder)? updates]) =>
      (new Gcomment_on_conflictBuilder()..update(updates))._build();

  _$Gcomment_on_conflict._(
      {required this.constraint, required this.update_columns, this.where})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        constraint, r'Gcomment_on_conflict', 'constraint');
    BuiltValueNullFieldError.checkNotNull(
        update_columns, r'Gcomment_on_conflict', 'update_columns');
  }

  @override
  Gcomment_on_conflict rebuild(
          void Function(Gcomment_on_conflictBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gcomment_on_conflictBuilder toBuilder() =>
      new Gcomment_on_conflictBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gcomment_on_conflict &&
        constraint == other.constraint &&
        update_columns == other.update_columns &&
        where == other.where;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, constraint.hashCode);
    _$hash = $jc(_$hash, update_columns.hashCode);
    _$hash = $jc(_$hash, where.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gcomment_on_conflict')
          ..add('constraint', constraint)
          ..add('update_columns', update_columns)
          ..add('where', where))
        .toString();
  }
}

class Gcomment_on_conflictBuilder
    implements Builder<Gcomment_on_conflict, Gcomment_on_conflictBuilder> {
  _$Gcomment_on_conflict? _$v;

  Gcomment_constraint? _constraint;
  Gcomment_constraint? get constraint => _$this._constraint;
  set constraint(Gcomment_constraint? constraint) =>
      _$this._constraint = constraint;

  ListBuilder<Gcomment_update_column>? _update_columns;
  ListBuilder<Gcomment_update_column> get update_columns =>
      _$this._update_columns ??= new ListBuilder<Gcomment_update_column>();
  set update_columns(ListBuilder<Gcomment_update_column>? update_columns) =>
      _$this._update_columns = update_columns;

  Gcomment_bool_expBuilder? _where;
  Gcomment_bool_expBuilder get where =>
      _$this._where ??= new Gcomment_bool_expBuilder();
  set where(Gcomment_bool_expBuilder? where) => _$this._where = where;

  Gcomment_on_conflictBuilder();

  Gcomment_on_conflictBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _constraint = $v.constraint;
      _update_columns = $v.update_columns.toBuilder();
      _where = $v.where?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gcomment_on_conflict other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gcomment_on_conflict;
  }

  @override
  void update(void Function(Gcomment_on_conflictBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gcomment_on_conflict build() => _build();

  _$Gcomment_on_conflict _build() {
    _$Gcomment_on_conflict _$result;
    try {
      _$result = _$v ??
          new _$Gcomment_on_conflict._(
              constraint: BuiltValueNullFieldError.checkNotNull(
                  constraint, r'Gcomment_on_conflict', 'constraint'),
              update_columns: update_columns.build(),
              where: _where?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'update_columns';
        update_columns.build();
        _$failedField = 'where';
        _where?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gcomment_on_conflict', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gcomment_order_by extends Gcomment_order_by {
  @override
  final Guser_order_by? author;
  @override
  final Gorder_by? beacon_id;
  @override
  final Gorder_by? content;
  @override
  final Gorder_by? created_at;
  @override
  final Gorder_by? id;
  @override
  final Gorder_by? user_id;

  factory _$Gcomment_order_by(
          [void Function(Gcomment_order_byBuilder)? updates]) =>
      (new Gcomment_order_byBuilder()..update(updates))._build();

  _$Gcomment_order_by._(
      {this.author,
      this.beacon_id,
      this.content,
      this.created_at,
      this.id,
      this.user_id})
      : super._();

  @override
  Gcomment_order_by rebuild(void Function(Gcomment_order_byBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gcomment_order_byBuilder toBuilder() =>
      new Gcomment_order_byBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gcomment_order_by &&
        author == other.author &&
        beacon_id == other.beacon_id &&
        content == other.content &&
        created_at == other.created_at &&
        id == other.id &&
        user_id == other.user_id;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, author.hashCode);
    _$hash = $jc(_$hash, beacon_id.hashCode);
    _$hash = $jc(_$hash, content.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, id.hashCode);
    _$hash = $jc(_$hash, user_id.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gcomment_order_by')
          ..add('author', author)
          ..add('beacon_id', beacon_id)
          ..add('content', content)
          ..add('created_at', created_at)
          ..add('id', id)
          ..add('user_id', user_id))
        .toString();
  }
}

class Gcomment_order_byBuilder
    implements Builder<Gcomment_order_by, Gcomment_order_byBuilder> {
  _$Gcomment_order_by? _$v;

  Guser_order_byBuilder? _author;
  Guser_order_byBuilder get author =>
      _$this._author ??= new Guser_order_byBuilder();
  set author(Guser_order_byBuilder? author) => _$this._author = author;

  Gorder_by? _beacon_id;
  Gorder_by? get beacon_id => _$this._beacon_id;
  set beacon_id(Gorder_by? beacon_id) => _$this._beacon_id = beacon_id;

  Gorder_by? _content;
  Gorder_by? get content => _$this._content;
  set content(Gorder_by? content) => _$this._content = content;

  Gorder_by? _created_at;
  Gorder_by? get created_at => _$this._created_at;
  set created_at(Gorder_by? created_at) => _$this._created_at = created_at;

  Gorder_by? _id;
  Gorder_by? get id => _$this._id;
  set id(Gorder_by? id) => _$this._id = id;

  Gorder_by? _user_id;
  Gorder_by? get user_id => _$this._user_id;
  set user_id(Gorder_by? user_id) => _$this._user_id = user_id;

  Gcomment_order_byBuilder();

  Gcomment_order_byBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _author = $v.author?.toBuilder();
      _beacon_id = $v.beacon_id;
      _content = $v.content;
      _created_at = $v.created_at;
      _id = $v.id;
      _user_id = $v.user_id;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gcomment_order_by other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gcomment_order_by;
  }

  @override
  void update(void Function(Gcomment_order_byBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gcomment_order_by build() => _build();

  _$Gcomment_order_by _build() {
    _$Gcomment_order_by _$result;
    try {
      _$result = _$v ??
          new _$Gcomment_order_by._(
              author: _author?.build(),
              beacon_id: beacon_id,
              content: content,
              created_at: created_at,
              id: id,
              user_id: user_id);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'author';
        _author?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gcomment_order_by', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gcomment_pk_columns_input extends Gcomment_pk_columns_input {
  @override
  final String id;

  factory _$Gcomment_pk_columns_input(
          [void Function(Gcomment_pk_columns_inputBuilder)? updates]) =>
      (new Gcomment_pk_columns_inputBuilder()..update(updates))._build();

  _$Gcomment_pk_columns_input._({required this.id}) : super._() {
    BuiltValueNullFieldError.checkNotNull(
        id, r'Gcomment_pk_columns_input', 'id');
  }

  @override
  Gcomment_pk_columns_input rebuild(
          void Function(Gcomment_pk_columns_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gcomment_pk_columns_inputBuilder toBuilder() =>
      new Gcomment_pk_columns_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gcomment_pk_columns_input && id == other.id;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, id.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gcomment_pk_columns_input')
          ..add('id', id))
        .toString();
  }
}

class Gcomment_pk_columns_inputBuilder
    implements
        Builder<Gcomment_pk_columns_input, Gcomment_pk_columns_inputBuilder> {
  _$Gcomment_pk_columns_input? _$v;

  String? _id;
  String? get id => _$this._id;
  set id(String? id) => _$this._id = id;

  Gcomment_pk_columns_inputBuilder();

  Gcomment_pk_columns_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _id = $v.id;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gcomment_pk_columns_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gcomment_pk_columns_input;
  }

  @override
  void update(void Function(Gcomment_pk_columns_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gcomment_pk_columns_input build() => _build();

  _$Gcomment_pk_columns_input _build() {
    final _$result = _$v ??
        new _$Gcomment_pk_columns_input._(
            id: BuiltValueNullFieldError.checkNotNull(
                id, r'Gcomment_pk_columns_input', 'id'));
    replace(_$result);
    return _$result;
  }
}

class _$Gcomment_set_input extends Gcomment_set_input {
  @override
  final String? beacon_id;
  @override
  final String? content;
  @override
  final DateTime? created_at;
  @override
  final String? id;
  @override
  final String? user_id;

  factory _$Gcomment_set_input(
          [void Function(Gcomment_set_inputBuilder)? updates]) =>
      (new Gcomment_set_inputBuilder()..update(updates))._build();

  _$Gcomment_set_input._(
      {this.beacon_id, this.content, this.created_at, this.id, this.user_id})
      : super._();

  @override
  Gcomment_set_input rebuild(
          void Function(Gcomment_set_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gcomment_set_inputBuilder toBuilder() =>
      new Gcomment_set_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gcomment_set_input &&
        beacon_id == other.beacon_id &&
        content == other.content &&
        created_at == other.created_at &&
        id == other.id &&
        user_id == other.user_id;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, beacon_id.hashCode);
    _$hash = $jc(_$hash, content.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, id.hashCode);
    _$hash = $jc(_$hash, user_id.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gcomment_set_input')
          ..add('beacon_id', beacon_id)
          ..add('content', content)
          ..add('created_at', created_at)
          ..add('id', id)
          ..add('user_id', user_id))
        .toString();
  }
}

class Gcomment_set_inputBuilder
    implements Builder<Gcomment_set_input, Gcomment_set_inputBuilder> {
  _$Gcomment_set_input? _$v;

  String? _beacon_id;
  String? get beacon_id => _$this._beacon_id;
  set beacon_id(String? beacon_id) => _$this._beacon_id = beacon_id;

  String? _content;
  String? get content => _$this._content;
  set content(String? content) => _$this._content = content;

  DateTime? _created_at;
  DateTime? get created_at => _$this._created_at;
  set created_at(DateTime? created_at) => _$this._created_at = created_at;

  String? _id;
  String? get id => _$this._id;
  set id(String? id) => _$this._id = id;

  String? _user_id;
  String? get user_id => _$this._user_id;
  set user_id(String? user_id) => _$this._user_id = user_id;

  Gcomment_set_inputBuilder();

  Gcomment_set_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _beacon_id = $v.beacon_id;
      _content = $v.content;
      _created_at = $v.created_at;
      _id = $v.id;
      _user_id = $v.user_id;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gcomment_set_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gcomment_set_input;
  }

  @override
  void update(void Function(Gcomment_set_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gcomment_set_input build() => _build();

  _$Gcomment_set_input _build() {
    final _$result = _$v ??
        new _$Gcomment_set_input._(
            beacon_id: beacon_id,
            content: content,
            created_at: created_at,
            id: id,
            user_id: user_id);
    replace(_$result);
    return _$result;
  }
}

class _$Gcomment_stream_cursor_input extends Gcomment_stream_cursor_input {
  @override
  final Gcomment_stream_cursor_value_input initial_value;
  @override
  final Gcursor_ordering? ordering;

  factory _$Gcomment_stream_cursor_input(
          [void Function(Gcomment_stream_cursor_inputBuilder)? updates]) =>
      (new Gcomment_stream_cursor_inputBuilder()..update(updates))._build();

  _$Gcomment_stream_cursor_input._({required this.initial_value, this.ordering})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        initial_value, r'Gcomment_stream_cursor_input', 'initial_value');
  }

  @override
  Gcomment_stream_cursor_input rebuild(
          void Function(Gcomment_stream_cursor_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gcomment_stream_cursor_inputBuilder toBuilder() =>
      new Gcomment_stream_cursor_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gcomment_stream_cursor_input &&
        initial_value == other.initial_value &&
        ordering == other.ordering;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, initial_value.hashCode);
    _$hash = $jc(_$hash, ordering.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gcomment_stream_cursor_input')
          ..add('initial_value', initial_value)
          ..add('ordering', ordering))
        .toString();
  }
}

class Gcomment_stream_cursor_inputBuilder
    implements
        Builder<Gcomment_stream_cursor_input,
            Gcomment_stream_cursor_inputBuilder> {
  _$Gcomment_stream_cursor_input? _$v;

  Gcomment_stream_cursor_value_inputBuilder? _initial_value;
  Gcomment_stream_cursor_value_inputBuilder get initial_value =>
      _$this._initial_value ??= new Gcomment_stream_cursor_value_inputBuilder();
  set initial_value(Gcomment_stream_cursor_value_inputBuilder? initial_value) =>
      _$this._initial_value = initial_value;

  Gcursor_ordering? _ordering;
  Gcursor_ordering? get ordering => _$this._ordering;
  set ordering(Gcursor_ordering? ordering) => _$this._ordering = ordering;

  Gcomment_stream_cursor_inputBuilder();

  Gcomment_stream_cursor_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _initial_value = $v.initial_value.toBuilder();
      _ordering = $v.ordering;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gcomment_stream_cursor_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gcomment_stream_cursor_input;
  }

  @override
  void update(void Function(Gcomment_stream_cursor_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gcomment_stream_cursor_input build() => _build();

  _$Gcomment_stream_cursor_input _build() {
    _$Gcomment_stream_cursor_input _$result;
    try {
      _$result = _$v ??
          new _$Gcomment_stream_cursor_input._(
              initial_value: initial_value.build(), ordering: ordering);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'initial_value';
        initial_value.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gcomment_stream_cursor_input', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gcomment_stream_cursor_value_input
    extends Gcomment_stream_cursor_value_input {
  @override
  final String? beacon_id;
  @override
  final String? content;
  @override
  final DateTime? created_at;
  @override
  final String? id;
  @override
  final String? user_id;

  factory _$Gcomment_stream_cursor_value_input(
          [void Function(Gcomment_stream_cursor_value_inputBuilder)?
              updates]) =>
      (new Gcomment_stream_cursor_value_inputBuilder()..update(updates))
          ._build();

  _$Gcomment_stream_cursor_value_input._(
      {this.beacon_id, this.content, this.created_at, this.id, this.user_id})
      : super._();

  @override
  Gcomment_stream_cursor_value_input rebuild(
          void Function(Gcomment_stream_cursor_value_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gcomment_stream_cursor_value_inputBuilder toBuilder() =>
      new Gcomment_stream_cursor_value_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gcomment_stream_cursor_value_input &&
        beacon_id == other.beacon_id &&
        content == other.content &&
        created_at == other.created_at &&
        id == other.id &&
        user_id == other.user_id;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, beacon_id.hashCode);
    _$hash = $jc(_$hash, content.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, id.hashCode);
    _$hash = $jc(_$hash, user_id.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gcomment_stream_cursor_value_input')
          ..add('beacon_id', beacon_id)
          ..add('content', content)
          ..add('created_at', created_at)
          ..add('id', id)
          ..add('user_id', user_id))
        .toString();
  }
}

class Gcomment_stream_cursor_value_inputBuilder
    implements
        Builder<Gcomment_stream_cursor_value_input,
            Gcomment_stream_cursor_value_inputBuilder> {
  _$Gcomment_stream_cursor_value_input? _$v;

  String? _beacon_id;
  String? get beacon_id => _$this._beacon_id;
  set beacon_id(String? beacon_id) => _$this._beacon_id = beacon_id;

  String? _content;
  String? get content => _$this._content;
  set content(String? content) => _$this._content = content;

  DateTime? _created_at;
  DateTime? get created_at => _$this._created_at;
  set created_at(DateTime? created_at) => _$this._created_at = created_at;

  String? _id;
  String? get id => _$this._id;
  set id(String? id) => _$this._id = id;

  String? _user_id;
  String? get user_id => _$this._user_id;
  set user_id(String? user_id) => _$this._user_id = user_id;

  Gcomment_stream_cursor_value_inputBuilder();

  Gcomment_stream_cursor_value_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _beacon_id = $v.beacon_id;
      _content = $v.content;
      _created_at = $v.created_at;
      _id = $v.id;
      _user_id = $v.user_id;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gcomment_stream_cursor_value_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gcomment_stream_cursor_value_input;
  }

  @override
  void update(
      void Function(Gcomment_stream_cursor_value_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gcomment_stream_cursor_value_input build() => _build();

  _$Gcomment_stream_cursor_value_input _build() {
    final _$result = _$v ??
        new _$Gcomment_stream_cursor_value_input._(
            beacon_id: beacon_id,
            content: content,
            created_at: created_at,
            id: id,
            user_id: user_id);
    replace(_$result);
    return _$result;
  }
}

class _$Gcomment_updates extends Gcomment_updates {
  @override
  final Gcomment_set_input? G_set;
  @override
  final Gcomment_bool_exp where;

  factory _$Gcomment_updates(
          [void Function(Gcomment_updatesBuilder)? updates]) =>
      (new Gcomment_updatesBuilder()..update(updates))._build();

  _$Gcomment_updates._({this.G_set, required this.where}) : super._() {
    BuiltValueNullFieldError.checkNotNull(where, r'Gcomment_updates', 'where');
  }

  @override
  Gcomment_updates rebuild(void Function(Gcomment_updatesBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gcomment_updatesBuilder toBuilder() =>
      new Gcomment_updatesBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gcomment_updates &&
        G_set == other.G_set &&
        where == other.where;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, G_set.hashCode);
    _$hash = $jc(_$hash, where.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gcomment_updates')
          ..add('G_set', G_set)
          ..add('where', where))
        .toString();
  }
}

class Gcomment_updatesBuilder
    implements Builder<Gcomment_updates, Gcomment_updatesBuilder> {
  _$Gcomment_updates? _$v;

  Gcomment_set_inputBuilder? _G_set;
  Gcomment_set_inputBuilder get G_set =>
      _$this._G_set ??= new Gcomment_set_inputBuilder();
  set G_set(Gcomment_set_inputBuilder? G_set) => _$this._G_set = G_set;

  Gcomment_bool_expBuilder? _where;
  Gcomment_bool_expBuilder get where =>
      _$this._where ??= new Gcomment_bool_expBuilder();
  set where(Gcomment_bool_expBuilder? where) => _$this._where = where;

  Gcomment_updatesBuilder();

  Gcomment_updatesBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _G_set = $v.G_set?.toBuilder();
      _where = $v.where.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gcomment_updates other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gcomment_updates;
  }

  @override
  void update(void Function(Gcomment_updatesBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gcomment_updates build() => _build();

  _$Gcomment_updates _build() {
    _$Gcomment_updates _$result;
    try {
      _$result = _$v ??
          new _$Gcomment_updates._(
              G_set: _G_set?.build(), where: where.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'G_set';
        _G_set?.build();
        _$failedField = 'where';
        where.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gcomment_updates', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Ggeography_cast_exp extends Ggeography_cast_exp {
  @override
  final Ggeometry_comparison_exp? geometry;

  factory _$Ggeography_cast_exp(
          [void Function(Ggeography_cast_expBuilder)? updates]) =>
      (new Ggeography_cast_expBuilder()..update(updates))._build();

  _$Ggeography_cast_exp._({this.geometry}) : super._();

  @override
  Ggeography_cast_exp rebuild(
          void Function(Ggeography_cast_expBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Ggeography_cast_expBuilder toBuilder() =>
      new Ggeography_cast_expBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Ggeography_cast_exp && geometry == other.geometry;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, geometry.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Ggeography_cast_exp')
          ..add('geometry', geometry))
        .toString();
  }
}

class Ggeography_cast_expBuilder
    implements Builder<Ggeography_cast_exp, Ggeography_cast_expBuilder> {
  _$Ggeography_cast_exp? _$v;

  Ggeometry_comparison_expBuilder? _geometry;
  Ggeometry_comparison_expBuilder get geometry =>
      _$this._geometry ??= new Ggeometry_comparison_expBuilder();
  set geometry(Ggeometry_comparison_expBuilder? geometry) =>
      _$this._geometry = geometry;

  Ggeography_cast_expBuilder();

  Ggeography_cast_expBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _geometry = $v.geometry?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Ggeography_cast_exp other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Ggeography_cast_exp;
  }

  @override
  void update(void Function(Ggeography_cast_expBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Ggeography_cast_exp build() => _build();

  _$Ggeography_cast_exp _build() {
    _$Ggeography_cast_exp _$result;
    try {
      _$result =
          _$v ?? new _$Ggeography_cast_exp._(geometry: _geometry?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'geometry';
        _geometry?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Ggeography_cast_exp', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Ggeography_comparison_exp extends Ggeography_comparison_exp {
  @override
  final Ggeography_cast_exp? G_cast;
  @override
  final _i2.LatLng? G_eq;
  @override
  final _i2.LatLng? G_gt;
  @override
  final _i2.LatLng? G_gte;
  @override
  final BuiltList<_i2.LatLng>? G_in;
  @override
  final bool? G_is_null;
  @override
  final _i2.LatLng? G_lt;
  @override
  final _i2.LatLng? G_lte;
  @override
  final _i2.LatLng? G_neq;
  @override
  final BuiltList<_i2.LatLng>? G_nin;
  @override
  final Gst_d_within_geography_input? G_st_d_within;
  @override
  final _i2.LatLng? G_st_intersects;

  factory _$Ggeography_comparison_exp(
          [void Function(Ggeography_comparison_expBuilder)? updates]) =>
      (new Ggeography_comparison_expBuilder()..update(updates))._build();

  _$Ggeography_comparison_exp._(
      {this.G_cast,
      this.G_eq,
      this.G_gt,
      this.G_gte,
      this.G_in,
      this.G_is_null,
      this.G_lt,
      this.G_lte,
      this.G_neq,
      this.G_nin,
      this.G_st_d_within,
      this.G_st_intersects})
      : super._();

  @override
  Ggeography_comparison_exp rebuild(
          void Function(Ggeography_comparison_expBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Ggeography_comparison_expBuilder toBuilder() =>
      new Ggeography_comparison_expBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Ggeography_comparison_exp &&
        G_cast == other.G_cast &&
        G_eq == other.G_eq &&
        G_gt == other.G_gt &&
        G_gte == other.G_gte &&
        G_in == other.G_in &&
        G_is_null == other.G_is_null &&
        G_lt == other.G_lt &&
        G_lte == other.G_lte &&
        G_neq == other.G_neq &&
        G_nin == other.G_nin &&
        G_st_d_within == other.G_st_d_within &&
        G_st_intersects == other.G_st_intersects;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, G_cast.hashCode);
    _$hash = $jc(_$hash, G_eq.hashCode);
    _$hash = $jc(_$hash, G_gt.hashCode);
    _$hash = $jc(_$hash, G_gte.hashCode);
    _$hash = $jc(_$hash, G_in.hashCode);
    _$hash = $jc(_$hash, G_is_null.hashCode);
    _$hash = $jc(_$hash, G_lt.hashCode);
    _$hash = $jc(_$hash, G_lte.hashCode);
    _$hash = $jc(_$hash, G_neq.hashCode);
    _$hash = $jc(_$hash, G_nin.hashCode);
    _$hash = $jc(_$hash, G_st_d_within.hashCode);
    _$hash = $jc(_$hash, G_st_intersects.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Ggeography_comparison_exp')
          ..add('G_cast', G_cast)
          ..add('G_eq', G_eq)
          ..add('G_gt', G_gt)
          ..add('G_gte', G_gte)
          ..add('G_in', G_in)
          ..add('G_is_null', G_is_null)
          ..add('G_lt', G_lt)
          ..add('G_lte', G_lte)
          ..add('G_neq', G_neq)
          ..add('G_nin', G_nin)
          ..add('G_st_d_within', G_st_d_within)
          ..add('G_st_intersects', G_st_intersects))
        .toString();
  }
}

class Ggeography_comparison_expBuilder
    implements
        Builder<Ggeography_comparison_exp, Ggeography_comparison_expBuilder> {
  _$Ggeography_comparison_exp? _$v;

  Ggeography_cast_expBuilder? _G_cast;
  Ggeography_cast_expBuilder get G_cast =>
      _$this._G_cast ??= new Ggeography_cast_expBuilder();
  set G_cast(Ggeography_cast_expBuilder? G_cast) => _$this._G_cast = G_cast;

  _i2.LatLng? _G_eq;
  _i2.LatLng? get G_eq => _$this._G_eq;
  set G_eq(_i2.LatLng? G_eq) => _$this._G_eq = G_eq;

  _i2.LatLng? _G_gt;
  _i2.LatLng? get G_gt => _$this._G_gt;
  set G_gt(_i2.LatLng? G_gt) => _$this._G_gt = G_gt;

  _i2.LatLng? _G_gte;
  _i2.LatLng? get G_gte => _$this._G_gte;
  set G_gte(_i2.LatLng? G_gte) => _$this._G_gte = G_gte;

  ListBuilder<_i2.LatLng>? _G_in;
  ListBuilder<_i2.LatLng> get G_in =>
      _$this._G_in ??= new ListBuilder<_i2.LatLng>();
  set G_in(ListBuilder<_i2.LatLng>? G_in) => _$this._G_in = G_in;

  bool? _G_is_null;
  bool? get G_is_null => _$this._G_is_null;
  set G_is_null(bool? G_is_null) => _$this._G_is_null = G_is_null;

  _i2.LatLng? _G_lt;
  _i2.LatLng? get G_lt => _$this._G_lt;
  set G_lt(_i2.LatLng? G_lt) => _$this._G_lt = G_lt;

  _i2.LatLng? _G_lte;
  _i2.LatLng? get G_lte => _$this._G_lte;
  set G_lte(_i2.LatLng? G_lte) => _$this._G_lte = G_lte;

  _i2.LatLng? _G_neq;
  _i2.LatLng? get G_neq => _$this._G_neq;
  set G_neq(_i2.LatLng? G_neq) => _$this._G_neq = G_neq;

  ListBuilder<_i2.LatLng>? _G_nin;
  ListBuilder<_i2.LatLng> get G_nin =>
      _$this._G_nin ??= new ListBuilder<_i2.LatLng>();
  set G_nin(ListBuilder<_i2.LatLng>? G_nin) => _$this._G_nin = G_nin;

  Gst_d_within_geography_inputBuilder? _G_st_d_within;
  Gst_d_within_geography_inputBuilder get G_st_d_within =>
      _$this._G_st_d_within ??= new Gst_d_within_geography_inputBuilder();
  set G_st_d_within(Gst_d_within_geography_inputBuilder? G_st_d_within) =>
      _$this._G_st_d_within = G_st_d_within;

  _i2.LatLng? _G_st_intersects;
  _i2.LatLng? get G_st_intersects => _$this._G_st_intersects;
  set G_st_intersects(_i2.LatLng? G_st_intersects) =>
      _$this._G_st_intersects = G_st_intersects;

  Ggeography_comparison_expBuilder();

  Ggeography_comparison_expBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _G_cast = $v.G_cast?.toBuilder();
      _G_eq = $v.G_eq;
      _G_gt = $v.G_gt;
      _G_gte = $v.G_gte;
      _G_in = $v.G_in?.toBuilder();
      _G_is_null = $v.G_is_null;
      _G_lt = $v.G_lt;
      _G_lte = $v.G_lte;
      _G_neq = $v.G_neq;
      _G_nin = $v.G_nin?.toBuilder();
      _G_st_d_within = $v.G_st_d_within?.toBuilder();
      _G_st_intersects = $v.G_st_intersects;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Ggeography_comparison_exp other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Ggeography_comparison_exp;
  }

  @override
  void update(void Function(Ggeography_comparison_expBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Ggeography_comparison_exp build() => _build();

  _$Ggeography_comparison_exp _build() {
    _$Ggeography_comparison_exp _$result;
    try {
      _$result = _$v ??
          new _$Ggeography_comparison_exp._(
              G_cast: _G_cast?.build(),
              G_eq: G_eq,
              G_gt: G_gt,
              G_gte: G_gte,
              G_in: _G_in?.build(),
              G_is_null: G_is_null,
              G_lt: G_lt,
              G_lte: G_lte,
              G_neq: G_neq,
              G_nin: _G_nin?.build(),
              G_st_d_within: _G_st_d_within?.build(),
              G_st_intersects: G_st_intersects);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'G_cast';
        _G_cast?.build();

        _$failedField = 'G_in';
        _G_in?.build();

        _$failedField = 'G_nin';
        _G_nin?.build();
        _$failedField = 'G_st_d_within';
        _G_st_d_within?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Ggeography_comparison_exp', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Ggeometry extends Ggeometry {
  @override
  final String value;

  factory _$Ggeometry([void Function(GgeometryBuilder)? updates]) =>
      (new GgeometryBuilder()..update(updates))._build();

  _$Ggeometry._({required this.value}) : super._() {
    BuiltValueNullFieldError.checkNotNull(value, r'Ggeometry', 'value');
  }

  @override
  Ggeometry rebuild(void Function(GgeometryBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GgeometryBuilder toBuilder() => new GgeometryBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Ggeometry && value == other.value;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, value.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Ggeometry')..add('value', value))
        .toString();
  }
}

class GgeometryBuilder implements Builder<Ggeometry, GgeometryBuilder> {
  _$Ggeometry? _$v;

  String? _value;
  String? get value => _$this._value;
  set value(String? value) => _$this._value = value;

  GgeometryBuilder();

  GgeometryBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _value = $v.value;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Ggeometry other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Ggeometry;
  }

  @override
  void update(void Function(GgeometryBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Ggeometry build() => _build();

  _$Ggeometry _build() {
    final _$result = _$v ??
        new _$Ggeometry._(
            value: BuiltValueNullFieldError.checkNotNull(
                value, r'Ggeometry', 'value'));
    replace(_$result);
    return _$result;
  }
}

class _$Ggeometry_cast_exp extends Ggeometry_cast_exp {
  @override
  final Ggeography_comparison_exp? geography;

  factory _$Ggeometry_cast_exp(
          [void Function(Ggeometry_cast_expBuilder)? updates]) =>
      (new Ggeometry_cast_expBuilder()..update(updates))._build();

  _$Ggeometry_cast_exp._({this.geography}) : super._();

  @override
  Ggeometry_cast_exp rebuild(
          void Function(Ggeometry_cast_expBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Ggeometry_cast_expBuilder toBuilder() =>
      new Ggeometry_cast_expBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Ggeometry_cast_exp && geography == other.geography;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, geography.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Ggeometry_cast_exp')
          ..add('geography', geography))
        .toString();
  }
}

class Ggeometry_cast_expBuilder
    implements Builder<Ggeometry_cast_exp, Ggeometry_cast_expBuilder> {
  _$Ggeometry_cast_exp? _$v;

  Ggeography_comparison_expBuilder? _geography;
  Ggeography_comparison_expBuilder get geography =>
      _$this._geography ??= new Ggeography_comparison_expBuilder();
  set geography(Ggeography_comparison_expBuilder? geography) =>
      _$this._geography = geography;

  Ggeometry_cast_expBuilder();

  Ggeometry_cast_expBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _geography = $v.geography?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Ggeometry_cast_exp other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Ggeometry_cast_exp;
  }

  @override
  void update(void Function(Ggeometry_cast_expBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Ggeometry_cast_exp build() => _build();

  _$Ggeometry_cast_exp _build() {
    _$Ggeometry_cast_exp _$result;
    try {
      _$result =
          _$v ?? new _$Ggeometry_cast_exp._(geography: _geography?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'geography';
        _geography?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Ggeometry_cast_exp', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Ggeometry_comparison_exp extends Ggeometry_comparison_exp {
  @override
  final Ggeometry_cast_exp? G_cast;
  @override
  final Ggeometry? G_eq;
  @override
  final Ggeometry? G_gt;
  @override
  final Ggeometry? G_gte;
  @override
  final BuiltList<Ggeometry>? G_in;
  @override
  final bool? G_is_null;
  @override
  final Ggeometry? G_lt;
  @override
  final Ggeometry? G_lte;
  @override
  final Ggeometry? G_neq;
  @override
  final BuiltList<Ggeometry>? G_nin;
  @override
  final Gst_d_within_input? G_st_3d_d_within;
  @override
  final Ggeometry? G_st_3d_intersects;
  @override
  final Ggeometry? G_st_contains;
  @override
  final Ggeometry? G_st_crosses;
  @override
  final Gst_d_within_input? G_st_d_within;
  @override
  final Ggeometry? G_st_equals;
  @override
  final Ggeometry? G_st_intersects;
  @override
  final Ggeometry? G_st_overlaps;
  @override
  final Ggeometry? G_st_touches;
  @override
  final Ggeometry? G_st_within;

  factory _$Ggeometry_comparison_exp(
          [void Function(Ggeometry_comparison_expBuilder)? updates]) =>
      (new Ggeometry_comparison_expBuilder()..update(updates))._build();

  _$Ggeometry_comparison_exp._(
      {this.G_cast,
      this.G_eq,
      this.G_gt,
      this.G_gte,
      this.G_in,
      this.G_is_null,
      this.G_lt,
      this.G_lte,
      this.G_neq,
      this.G_nin,
      this.G_st_3d_d_within,
      this.G_st_3d_intersects,
      this.G_st_contains,
      this.G_st_crosses,
      this.G_st_d_within,
      this.G_st_equals,
      this.G_st_intersects,
      this.G_st_overlaps,
      this.G_st_touches,
      this.G_st_within})
      : super._();

  @override
  Ggeometry_comparison_exp rebuild(
          void Function(Ggeometry_comparison_expBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Ggeometry_comparison_expBuilder toBuilder() =>
      new Ggeometry_comparison_expBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Ggeometry_comparison_exp &&
        G_cast == other.G_cast &&
        G_eq == other.G_eq &&
        G_gt == other.G_gt &&
        G_gte == other.G_gte &&
        G_in == other.G_in &&
        G_is_null == other.G_is_null &&
        G_lt == other.G_lt &&
        G_lte == other.G_lte &&
        G_neq == other.G_neq &&
        G_nin == other.G_nin &&
        G_st_3d_d_within == other.G_st_3d_d_within &&
        G_st_3d_intersects == other.G_st_3d_intersects &&
        G_st_contains == other.G_st_contains &&
        G_st_crosses == other.G_st_crosses &&
        G_st_d_within == other.G_st_d_within &&
        G_st_equals == other.G_st_equals &&
        G_st_intersects == other.G_st_intersects &&
        G_st_overlaps == other.G_st_overlaps &&
        G_st_touches == other.G_st_touches &&
        G_st_within == other.G_st_within;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, G_cast.hashCode);
    _$hash = $jc(_$hash, G_eq.hashCode);
    _$hash = $jc(_$hash, G_gt.hashCode);
    _$hash = $jc(_$hash, G_gte.hashCode);
    _$hash = $jc(_$hash, G_in.hashCode);
    _$hash = $jc(_$hash, G_is_null.hashCode);
    _$hash = $jc(_$hash, G_lt.hashCode);
    _$hash = $jc(_$hash, G_lte.hashCode);
    _$hash = $jc(_$hash, G_neq.hashCode);
    _$hash = $jc(_$hash, G_nin.hashCode);
    _$hash = $jc(_$hash, G_st_3d_d_within.hashCode);
    _$hash = $jc(_$hash, G_st_3d_intersects.hashCode);
    _$hash = $jc(_$hash, G_st_contains.hashCode);
    _$hash = $jc(_$hash, G_st_crosses.hashCode);
    _$hash = $jc(_$hash, G_st_d_within.hashCode);
    _$hash = $jc(_$hash, G_st_equals.hashCode);
    _$hash = $jc(_$hash, G_st_intersects.hashCode);
    _$hash = $jc(_$hash, G_st_overlaps.hashCode);
    _$hash = $jc(_$hash, G_st_touches.hashCode);
    _$hash = $jc(_$hash, G_st_within.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Ggeometry_comparison_exp')
          ..add('G_cast', G_cast)
          ..add('G_eq', G_eq)
          ..add('G_gt', G_gt)
          ..add('G_gte', G_gte)
          ..add('G_in', G_in)
          ..add('G_is_null', G_is_null)
          ..add('G_lt', G_lt)
          ..add('G_lte', G_lte)
          ..add('G_neq', G_neq)
          ..add('G_nin', G_nin)
          ..add('G_st_3d_d_within', G_st_3d_d_within)
          ..add('G_st_3d_intersects', G_st_3d_intersects)
          ..add('G_st_contains', G_st_contains)
          ..add('G_st_crosses', G_st_crosses)
          ..add('G_st_d_within', G_st_d_within)
          ..add('G_st_equals', G_st_equals)
          ..add('G_st_intersects', G_st_intersects)
          ..add('G_st_overlaps', G_st_overlaps)
          ..add('G_st_touches', G_st_touches)
          ..add('G_st_within', G_st_within))
        .toString();
  }
}

class Ggeometry_comparison_expBuilder
    implements
        Builder<Ggeometry_comparison_exp, Ggeometry_comparison_expBuilder> {
  _$Ggeometry_comparison_exp? _$v;

  Ggeometry_cast_expBuilder? _G_cast;
  Ggeometry_cast_expBuilder get G_cast =>
      _$this._G_cast ??= new Ggeometry_cast_expBuilder();
  set G_cast(Ggeometry_cast_expBuilder? G_cast) => _$this._G_cast = G_cast;

  GgeometryBuilder? _G_eq;
  GgeometryBuilder get G_eq => _$this._G_eq ??= new GgeometryBuilder();
  set G_eq(GgeometryBuilder? G_eq) => _$this._G_eq = G_eq;

  GgeometryBuilder? _G_gt;
  GgeometryBuilder get G_gt => _$this._G_gt ??= new GgeometryBuilder();
  set G_gt(GgeometryBuilder? G_gt) => _$this._G_gt = G_gt;

  GgeometryBuilder? _G_gte;
  GgeometryBuilder get G_gte => _$this._G_gte ??= new GgeometryBuilder();
  set G_gte(GgeometryBuilder? G_gte) => _$this._G_gte = G_gte;

  ListBuilder<Ggeometry>? _G_in;
  ListBuilder<Ggeometry> get G_in =>
      _$this._G_in ??= new ListBuilder<Ggeometry>();
  set G_in(ListBuilder<Ggeometry>? G_in) => _$this._G_in = G_in;

  bool? _G_is_null;
  bool? get G_is_null => _$this._G_is_null;
  set G_is_null(bool? G_is_null) => _$this._G_is_null = G_is_null;

  GgeometryBuilder? _G_lt;
  GgeometryBuilder get G_lt => _$this._G_lt ??= new GgeometryBuilder();
  set G_lt(GgeometryBuilder? G_lt) => _$this._G_lt = G_lt;

  GgeometryBuilder? _G_lte;
  GgeometryBuilder get G_lte => _$this._G_lte ??= new GgeometryBuilder();
  set G_lte(GgeometryBuilder? G_lte) => _$this._G_lte = G_lte;

  GgeometryBuilder? _G_neq;
  GgeometryBuilder get G_neq => _$this._G_neq ??= new GgeometryBuilder();
  set G_neq(GgeometryBuilder? G_neq) => _$this._G_neq = G_neq;

  ListBuilder<Ggeometry>? _G_nin;
  ListBuilder<Ggeometry> get G_nin =>
      _$this._G_nin ??= new ListBuilder<Ggeometry>();
  set G_nin(ListBuilder<Ggeometry>? G_nin) => _$this._G_nin = G_nin;

  Gst_d_within_inputBuilder? _G_st_3d_d_within;
  Gst_d_within_inputBuilder get G_st_3d_d_within =>
      _$this._G_st_3d_d_within ??= new Gst_d_within_inputBuilder();
  set G_st_3d_d_within(Gst_d_within_inputBuilder? G_st_3d_d_within) =>
      _$this._G_st_3d_d_within = G_st_3d_d_within;

  GgeometryBuilder? _G_st_3d_intersects;
  GgeometryBuilder get G_st_3d_intersects =>
      _$this._G_st_3d_intersects ??= new GgeometryBuilder();
  set G_st_3d_intersects(GgeometryBuilder? G_st_3d_intersects) =>
      _$this._G_st_3d_intersects = G_st_3d_intersects;

  GgeometryBuilder? _G_st_contains;
  GgeometryBuilder get G_st_contains =>
      _$this._G_st_contains ??= new GgeometryBuilder();
  set G_st_contains(GgeometryBuilder? G_st_contains) =>
      _$this._G_st_contains = G_st_contains;

  GgeometryBuilder? _G_st_crosses;
  GgeometryBuilder get G_st_crosses =>
      _$this._G_st_crosses ??= new GgeometryBuilder();
  set G_st_crosses(GgeometryBuilder? G_st_crosses) =>
      _$this._G_st_crosses = G_st_crosses;

  Gst_d_within_inputBuilder? _G_st_d_within;
  Gst_d_within_inputBuilder get G_st_d_within =>
      _$this._G_st_d_within ??= new Gst_d_within_inputBuilder();
  set G_st_d_within(Gst_d_within_inputBuilder? G_st_d_within) =>
      _$this._G_st_d_within = G_st_d_within;

  GgeometryBuilder? _G_st_equals;
  GgeometryBuilder get G_st_equals =>
      _$this._G_st_equals ??= new GgeometryBuilder();
  set G_st_equals(GgeometryBuilder? G_st_equals) =>
      _$this._G_st_equals = G_st_equals;

  GgeometryBuilder? _G_st_intersects;
  GgeometryBuilder get G_st_intersects =>
      _$this._G_st_intersects ??= new GgeometryBuilder();
  set G_st_intersects(GgeometryBuilder? G_st_intersects) =>
      _$this._G_st_intersects = G_st_intersects;

  GgeometryBuilder? _G_st_overlaps;
  GgeometryBuilder get G_st_overlaps =>
      _$this._G_st_overlaps ??= new GgeometryBuilder();
  set G_st_overlaps(GgeometryBuilder? G_st_overlaps) =>
      _$this._G_st_overlaps = G_st_overlaps;

  GgeometryBuilder? _G_st_touches;
  GgeometryBuilder get G_st_touches =>
      _$this._G_st_touches ??= new GgeometryBuilder();
  set G_st_touches(GgeometryBuilder? G_st_touches) =>
      _$this._G_st_touches = G_st_touches;

  GgeometryBuilder? _G_st_within;
  GgeometryBuilder get G_st_within =>
      _$this._G_st_within ??= new GgeometryBuilder();
  set G_st_within(GgeometryBuilder? G_st_within) =>
      _$this._G_st_within = G_st_within;

  Ggeometry_comparison_expBuilder();

  Ggeometry_comparison_expBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _G_cast = $v.G_cast?.toBuilder();
      _G_eq = $v.G_eq?.toBuilder();
      _G_gt = $v.G_gt?.toBuilder();
      _G_gte = $v.G_gte?.toBuilder();
      _G_in = $v.G_in?.toBuilder();
      _G_is_null = $v.G_is_null;
      _G_lt = $v.G_lt?.toBuilder();
      _G_lte = $v.G_lte?.toBuilder();
      _G_neq = $v.G_neq?.toBuilder();
      _G_nin = $v.G_nin?.toBuilder();
      _G_st_3d_d_within = $v.G_st_3d_d_within?.toBuilder();
      _G_st_3d_intersects = $v.G_st_3d_intersects?.toBuilder();
      _G_st_contains = $v.G_st_contains?.toBuilder();
      _G_st_crosses = $v.G_st_crosses?.toBuilder();
      _G_st_d_within = $v.G_st_d_within?.toBuilder();
      _G_st_equals = $v.G_st_equals?.toBuilder();
      _G_st_intersects = $v.G_st_intersects?.toBuilder();
      _G_st_overlaps = $v.G_st_overlaps?.toBuilder();
      _G_st_touches = $v.G_st_touches?.toBuilder();
      _G_st_within = $v.G_st_within?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Ggeometry_comparison_exp other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Ggeometry_comparison_exp;
  }

  @override
  void update(void Function(Ggeometry_comparison_expBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Ggeometry_comparison_exp build() => _build();

  _$Ggeometry_comparison_exp _build() {
    _$Ggeometry_comparison_exp _$result;
    try {
      _$result = _$v ??
          new _$Ggeometry_comparison_exp._(
              G_cast: _G_cast?.build(),
              G_eq: _G_eq?.build(),
              G_gt: _G_gt?.build(),
              G_gte: _G_gte?.build(),
              G_in: _G_in?.build(),
              G_is_null: G_is_null,
              G_lt: _G_lt?.build(),
              G_lte: _G_lte?.build(),
              G_neq: _G_neq?.build(),
              G_nin: _G_nin?.build(),
              G_st_3d_d_within: _G_st_3d_d_within?.build(),
              G_st_3d_intersects: _G_st_3d_intersects?.build(),
              G_st_contains: _G_st_contains?.build(),
              G_st_crosses: _G_st_crosses?.build(),
              G_st_d_within: _G_st_d_within?.build(),
              G_st_equals: _G_st_equals?.build(),
              G_st_intersects: _G_st_intersects?.build(),
              G_st_overlaps: _G_st_overlaps?.build(),
              G_st_touches: _G_st_touches?.build(),
              G_st_within: _G_st_within?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'G_cast';
        _G_cast?.build();
        _$failedField = 'G_eq';
        _G_eq?.build();
        _$failedField = 'G_gt';
        _G_gt?.build();
        _$failedField = 'G_gte';
        _G_gte?.build();
        _$failedField = 'G_in';
        _G_in?.build();

        _$failedField = 'G_lt';
        _G_lt?.build();
        _$failedField = 'G_lte';
        _G_lte?.build();
        _$failedField = 'G_neq';
        _G_neq?.build();
        _$failedField = 'G_nin';
        _G_nin?.build();
        _$failedField = 'G_st_3d_d_within';
        _G_st_3d_d_within?.build();
        _$failedField = 'G_st_3d_intersects';
        _G_st_3d_intersects?.build();
        _$failedField = 'G_st_contains';
        _G_st_contains?.build();
        _$failedField = 'G_st_crosses';
        _G_st_crosses?.build();
        _$failedField = 'G_st_d_within';
        _G_st_d_within?.build();
        _$failedField = 'G_st_equals';
        _G_st_equals?.build();
        _$failedField = 'G_st_intersects';
        _G_st_intersects?.build();
        _$failedField = 'G_st_overlaps';
        _G_st_overlaps?.build();
        _$failedField = 'G_st_touches';
        _G_st_touches?.build();
        _$failedField = 'G_st_within';
        _G_st_within?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Ggeometry_comparison_exp', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GInt_comparison_exp extends GInt_comparison_exp {
  @override
  final int? G_eq;
  @override
  final int? G_gt;
  @override
  final int? G_gte;
  @override
  final BuiltList<int>? G_in;
  @override
  final bool? G_is_null;
  @override
  final int? G_lt;
  @override
  final int? G_lte;
  @override
  final int? G_neq;
  @override
  final BuiltList<int>? G_nin;

  factory _$GInt_comparison_exp(
          [void Function(GInt_comparison_expBuilder)? updates]) =>
      (new GInt_comparison_expBuilder()..update(updates))._build();

  _$GInt_comparison_exp._(
      {this.G_eq,
      this.G_gt,
      this.G_gte,
      this.G_in,
      this.G_is_null,
      this.G_lt,
      this.G_lte,
      this.G_neq,
      this.G_nin})
      : super._();

  @override
  GInt_comparison_exp rebuild(
          void Function(GInt_comparison_expBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GInt_comparison_expBuilder toBuilder() =>
      new GInt_comparison_expBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GInt_comparison_exp &&
        G_eq == other.G_eq &&
        G_gt == other.G_gt &&
        G_gte == other.G_gte &&
        G_in == other.G_in &&
        G_is_null == other.G_is_null &&
        G_lt == other.G_lt &&
        G_lte == other.G_lte &&
        G_neq == other.G_neq &&
        G_nin == other.G_nin;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, G_eq.hashCode);
    _$hash = $jc(_$hash, G_gt.hashCode);
    _$hash = $jc(_$hash, G_gte.hashCode);
    _$hash = $jc(_$hash, G_in.hashCode);
    _$hash = $jc(_$hash, G_is_null.hashCode);
    _$hash = $jc(_$hash, G_lt.hashCode);
    _$hash = $jc(_$hash, G_lte.hashCode);
    _$hash = $jc(_$hash, G_neq.hashCode);
    _$hash = $jc(_$hash, G_nin.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'GInt_comparison_exp')
          ..add('G_eq', G_eq)
          ..add('G_gt', G_gt)
          ..add('G_gte', G_gte)
          ..add('G_in', G_in)
          ..add('G_is_null', G_is_null)
          ..add('G_lt', G_lt)
          ..add('G_lte', G_lte)
          ..add('G_neq', G_neq)
          ..add('G_nin', G_nin))
        .toString();
  }
}

class GInt_comparison_expBuilder
    implements Builder<GInt_comparison_exp, GInt_comparison_expBuilder> {
  _$GInt_comparison_exp? _$v;

  int? _G_eq;
  int? get G_eq => _$this._G_eq;
  set G_eq(int? G_eq) => _$this._G_eq = G_eq;

  int? _G_gt;
  int? get G_gt => _$this._G_gt;
  set G_gt(int? G_gt) => _$this._G_gt = G_gt;

  int? _G_gte;
  int? get G_gte => _$this._G_gte;
  set G_gte(int? G_gte) => _$this._G_gte = G_gte;

  ListBuilder<int>? _G_in;
  ListBuilder<int> get G_in => _$this._G_in ??= new ListBuilder<int>();
  set G_in(ListBuilder<int>? G_in) => _$this._G_in = G_in;

  bool? _G_is_null;
  bool? get G_is_null => _$this._G_is_null;
  set G_is_null(bool? G_is_null) => _$this._G_is_null = G_is_null;

  int? _G_lt;
  int? get G_lt => _$this._G_lt;
  set G_lt(int? G_lt) => _$this._G_lt = G_lt;

  int? _G_lte;
  int? get G_lte => _$this._G_lte;
  set G_lte(int? G_lte) => _$this._G_lte = G_lte;

  int? _G_neq;
  int? get G_neq => _$this._G_neq;
  set G_neq(int? G_neq) => _$this._G_neq = G_neq;

  ListBuilder<int>? _G_nin;
  ListBuilder<int> get G_nin => _$this._G_nin ??= new ListBuilder<int>();
  set G_nin(ListBuilder<int>? G_nin) => _$this._G_nin = G_nin;

  GInt_comparison_expBuilder();

  GInt_comparison_expBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _G_eq = $v.G_eq;
      _G_gt = $v.G_gt;
      _G_gte = $v.G_gte;
      _G_in = $v.G_in?.toBuilder();
      _G_is_null = $v.G_is_null;
      _G_lt = $v.G_lt;
      _G_lte = $v.G_lte;
      _G_neq = $v.G_neq;
      _G_nin = $v.G_nin?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GInt_comparison_exp other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GInt_comparison_exp;
  }

  @override
  void update(void Function(GInt_comparison_expBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  GInt_comparison_exp build() => _build();

  _$GInt_comparison_exp _build() {
    _$GInt_comparison_exp _$result;
    try {
      _$result = _$v ??
          new _$GInt_comparison_exp._(
              G_eq: G_eq,
              G_gt: G_gt,
              G_gte: G_gte,
              G_in: _G_in?.build(),
              G_is_null: G_is_null,
              G_lt: G_lt,
              G_lte: G_lte,
              G_neq: G_neq,
              G_nin: _G_nin?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'G_in';
        _G_in?.build();

        _$failedField = 'G_nin';
        _G_nin?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'GInt_comparison_exp', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gst_d_within_geography_input extends Gst_d_within_geography_input {
  @override
  final double distance;
  @override
  final _i2.LatLng from;
  @override
  final bool? use_spheroid;

  factory _$Gst_d_within_geography_input(
          [void Function(Gst_d_within_geography_inputBuilder)? updates]) =>
      (new Gst_d_within_geography_inputBuilder()..update(updates))._build();

  _$Gst_d_within_geography_input._(
      {required this.distance, required this.from, this.use_spheroid})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        distance, r'Gst_d_within_geography_input', 'distance');
    BuiltValueNullFieldError.checkNotNull(
        from, r'Gst_d_within_geography_input', 'from');
  }

  @override
  Gst_d_within_geography_input rebuild(
          void Function(Gst_d_within_geography_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gst_d_within_geography_inputBuilder toBuilder() =>
      new Gst_d_within_geography_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gst_d_within_geography_input &&
        distance == other.distance &&
        from == other.from &&
        use_spheroid == other.use_spheroid;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, distance.hashCode);
    _$hash = $jc(_$hash, from.hashCode);
    _$hash = $jc(_$hash, use_spheroid.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gst_d_within_geography_input')
          ..add('distance', distance)
          ..add('from', from)
          ..add('use_spheroid', use_spheroid))
        .toString();
  }
}

class Gst_d_within_geography_inputBuilder
    implements
        Builder<Gst_d_within_geography_input,
            Gst_d_within_geography_inputBuilder> {
  _$Gst_d_within_geography_input? _$v;

  double? _distance;
  double? get distance => _$this._distance;
  set distance(double? distance) => _$this._distance = distance;

  _i2.LatLng? _from;
  _i2.LatLng? get from => _$this._from;
  set from(_i2.LatLng? from) => _$this._from = from;

  bool? _use_spheroid;
  bool? get use_spheroid => _$this._use_spheroid;
  set use_spheroid(bool? use_spheroid) => _$this._use_spheroid = use_spheroid;

  Gst_d_within_geography_inputBuilder();

  Gst_d_within_geography_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _distance = $v.distance;
      _from = $v.from;
      _use_spheroid = $v.use_spheroid;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gst_d_within_geography_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gst_d_within_geography_input;
  }

  @override
  void update(void Function(Gst_d_within_geography_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gst_d_within_geography_input build() => _build();

  _$Gst_d_within_geography_input _build() {
    final _$result = _$v ??
        new _$Gst_d_within_geography_input._(
            distance: BuiltValueNullFieldError.checkNotNull(
                distance, r'Gst_d_within_geography_input', 'distance'),
            from: BuiltValueNullFieldError.checkNotNull(
                from, r'Gst_d_within_geography_input', 'from'),
            use_spheroid: use_spheroid);
    replace(_$result);
    return _$result;
  }
}

class _$Gst_d_within_input extends Gst_d_within_input {
  @override
  final double distance;
  @override
  final Ggeometry from;

  factory _$Gst_d_within_input(
          [void Function(Gst_d_within_inputBuilder)? updates]) =>
      (new Gst_d_within_inputBuilder()..update(updates))._build();

  _$Gst_d_within_input._({required this.distance, required this.from})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        distance, r'Gst_d_within_input', 'distance');
    BuiltValueNullFieldError.checkNotNull(from, r'Gst_d_within_input', 'from');
  }

  @override
  Gst_d_within_input rebuild(
          void Function(Gst_d_within_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gst_d_within_inputBuilder toBuilder() =>
      new Gst_d_within_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gst_d_within_input &&
        distance == other.distance &&
        from == other.from;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, distance.hashCode);
    _$hash = $jc(_$hash, from.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gst_d_within_input')
          ..add('distance', distance)
          ..add('from', from))
        .toString();
  }
}

class Gst_d_within_inputBuilder
    implements Builder<Gst_d_within_input, Gst_d_within_inputBuilder> {
  _$Gst_d_within_input? _$v;

  double? _distance;
  double? get distance => _$this._distance;
  set distance(double? distance) => _$this._distance = distance;

  GgeometryBuilder? _from;
  GgeometryBuilder get from => _$this._from ??= new GgeometryBuilder();
  set from(GgeometryBuilder? from) => _$this._from = from;

  Gst_d_within_inputBuilder();

  Gst_d_within_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _distance = $v.distance;
      _from = $v.from.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gst_d_within_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gst_d_within_input;
  }

  @override
  void update(void Function(Gst_d_within_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gst_d_within_input build() => _build();

  _$Gst_d_within_input _build() {
    _$Gst_d_within_input _$result;
    try {
      _$result = _$v ??
          new _$Gst_d_within_input._(
              distance: BuiltValueNullFieldError.checkNotNull(
                  distance, r'Gst_d_within_input', 'distance'),
              from: from.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'from';
        from.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gst_d_within_input', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GString_comparison_exp extends GString_comparison_exp {
  @override
  final String? G_eq;
  @override
  final String? G_gt;
  @override
  final String? G_gte;
  @override
  final String? G_ilike;
  @override
  final BuiltList<String>? G_in;
  @override
  final String? G_iregex;
  @override
  final bool? G_is_null;
  @override
  final String? G_like;
  @override
  final String? G_lt;
  @override
  final String? G_lte;
  @override
  final String? G_neq;
  @override
  final String? G_nilike;
  @override
  final BuiltList<String>? G_nin;
  @override
  final String? G_niregex;
  @override
  final String? G_nlike;
  @override
  final String? G_nregex;
  @override
  final String? G_nsimilar;
  @override
  final String? G_regex;
  @override
  final String? G_similar;

  factory _$GString_comparison_exp(
          [void Function(GString_comparison_expBuilder)? updates]) =>
      (new GString_comparison_expBuilder()..update(updates))._build();

  _$GString_comparison_exp._(
      {this.G_eq,
      this.G_gt,
      this.G_gte,
      this.G_ilike,
      this.G_in,
      this.G_iregex,
      this.G_is_null,
      this.G_like,
      this.G_lt,
      this.G_lte,
      this.G_neq,
      this.G_nilike,
      this.G_nin,
      this.G_niregex,
      this.G_nlike,
      this.G_nregex,
      this.G_nsimilar,
      this.G_regex,
      this.G_similar})
      : super._();

  @override
  GString_comparison_exp rebuild(
          void Function(GString_comparison_expBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GString_comparison_expBuilder toBuilder() =>
      new GString_comparison_expBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GString_comparison_exp &&
        G_eq == other.G_eq &&
        G_gt == other.G_gt &&
        G_gte == other.G_gte &&
        G_ilike == other.G_ilike &&
        G_in == other.G_in &&
        G_iregex == other.G_iregex &&
        G_is_null == other.G_is_null &&
        G_like == other.G_like &&
        G_lt == other.G_lt &&
        G_lte == other.G_lte &&
        G_neq == other.G_neq &&
        G_nilike == other.G_nilike &&
        G_nin == other.G_nin &&
        G_niregex == other.G_niregex &&
        G_nlike == other.G_nlike &&
        G_nregex == other.G_nregex &&
        G_nsimilar == other.G_nsimilar &&
        G_regex == other.G_regex &&
        G_similar == other.G_similar;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, G_eq.hashCode);
    _$hash = $jc(_$hash, G_gt.hashCode);
    _$hash = $jc(_$hash, G_gte.hashCode);
    _$hash = $jc(_$hash, G_ilike.hashCode);
    _$hash = $jc(_$hash, G_in.hashCode);
    _$hash = $jc(_$hash, G_iregex.hashCode);
    _$hash = $jc(_$hash, G_is_null.hashCode);
    _$hash = $jc(_$hash, G_like.hashCode);
    _$hash = $jc(_$hash, G_lt.hashCode);
    _$hash = $jc(_$hash, G_lte.hashCode);
    _$hash = $jc(_$hash, G_neq.hashCode);
    _$hash = $jc(_$hash, G_nilike.hashCode);
    _$hash = $jc(_$hash, G_nin.hashCode);
    _$hash = $jc(_$hash, G_niregex.hashCode);
    _$hash = $jc(_$hash, G_nlike.hashCode);
    _$hash = $jc(_$hash, G_nregex.hashCode);
    _$hash = $jc(_$hash, G_nsimilar.hashCode);
    _$hash = $jc(_$hash, G_regex.hashCode);
    _$hash = $jc(_$hash, G_similar.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'GString_comparison_exp')
          ..add('G_eq', G_eq)
          ..add('G_gt', G_gt)
          ..add('G_gte', G_gte)
          ..add('G_ilike', G_ilike)
          ..add('G_in', G_in)
          ..add('G_iregex', G_iregex)
          ..add('G_is_null', G_is_null)
          ..add('G_like', G_like)
          ..add('G_lt', G_lt)
          ..add('G_lte', G_lte)
          ..add('G_neq', G_neq)
          ..add('G_nilike', G_nilike)
          ..add('G_nin', G_nin)
          ..add('G_niregex', G_niregex)
          ..add('G_nlike', G_nlike)
          ..add('G_nregex', G_nregex)
          ..add('G_nsimilar', G_nsimilar)
          ..add('G_regex', G_regex)
          ..add('G_similar', G_similar))
        .toString();
  }
}

class GString_comparison_expBuilder
    implements Builder<GString_comparison_exp, GString_comparison_expBuilder> {
  _$GString_comparison_exp? _$v;

  String? _G_eq;
  String? get G_eq => _$this._G_eq;
  set G_eq(String? G_eq) => _$this._G_eq = G_eq;

  String? _G_gt;
  String? get G_gt => _$this._G_gt;
  set G_gt(String? G_gt) => _$this._G_gt = G_gt;

  String? _G_gte;
  String? get G_gte => _$this._G_gte;
  set G_gte(String? G_gte) => _$this._G_gte = G_gte;

  String? _G_ilike;
  String? get G_ilike => _$this._G_ilike;
  set G_ilike(String? G_ilike) => _$this._G_ilike = G_ilike;

  ListBuilder<String>? _G_in;
  ListBuilder<String> get G_in => _$this._G_in ??= new ListBuilder<String>();
  set G_in(ListBuilder<String>? G_in) => _$this._G_in = G_in;

  String? _G_iregex;
  String? get G_iregex => _$this._G_iregex;
  set G_iregex(String? G_iregex) => _$this._G_iregex = G_iregex;

  bool? _G_is_null;
  bool? get G_is_null => _$this._G_is_null;
  set G_is_null(bool? G_is_null) => _$this._G_is_null = G_is_null;

  String? _G_like;
  String? get G_like => _$this._G_like;
  set G_like(String? G_like) => _$this._G_like = G_like;

  String? _G_lt;
  String? get G_lt => _$this._G_lt;
  set G_lt(String? G_lt) => _$this._G_lt = G_lt;

  String? _G_lte;
  String? get G_lte => _$this._G_lte;
  set G_lte(String? G_lte) => _$this._G_lte = G_lte;

  String? _G_neq;
  String? get G_neq => _$this._G_neq;
  set G_neq(String? G_neq) => _$this._G_neq = G_neq;

  String? _G_nilike;
  String? get G_nilike => _$this._G_nilike;
  set G_nilike(String? G_nilike) => _$this._G_nilike = G_nilike;

  ListBuilder<String>? _G_nin;
  ListBuilder<String> get G_nin => _$this._G_nin ??= new ListBuilder<String>();
  set G_nin(ListBuilder<String>? G_nin) => _$this._G_nin = G_nin;

  String? _G_niregex;
  String? get G_niregex => _$this._G_niregex;
  set G_niregex(String? G_niregex) => _$this._G_niregex = G_niregex;

  String? _G_nlike;
  String? get G_nlike => _$this._G_nlike;
  set G_nlike(String? G_nlike) => _$this._G_nlike = G_nlike;

  String? _G_nregex;
  String? get G_nregex => _$this._G_nregex;
  set G_nregex(String? G_nregex) => _$this._G_nregex = G_nregex;

  String? _G_nsimilar;
  String? get G_nsimilar => _$this._G_nsimilar;
  set G_nsimilar(String? G_nsimilar) => _$this._G_nsimilar = G_nsimilar;

  String? _G_regex;
  String? get G_regex => _$this._G_regex;
  set G_regex(String? G_regex) => _$this._G_regex = G_regex;

  String? _G_similar;
  String? get G_similar => _$this._G_similar;
  set G_similar(String? G_similar) => _$this._G_similar = G_similar;

  GString_comparison_expBuilder();

  GString_comparison_expBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _G_eq = $v.G_eq;
      _G_gt = $v.G_gt;
      _G_gte = $v.G_gte;
      _G_ilike = $v.G_ilike;
      _G_in = $v.G_in?.toBuilder();
      _G_iregex = $v.G_iregex;
      _G_is_null = $v.G_is_null;
      _G_like = $v.G_like;
      _G_lt = $v.G_lt;
      _G_lte = $v.G_lte;
      _G_neq = $v.G_neq;
      _G_nilike = $v.G_nilike;
      _G_nin = $v.G_nin?.toBuilder();
      _G_niregex = $v.G_niregex;
      _G_nlike = $v.G_nlike;
      _G_nregex = $v.G_nregex;
      _G_nsimilar = $v.G_nsimilar;
      _G_regex = $v.G_regex;
      _G_similar = $v.G_similar;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GString_comparison_exp other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GString_comparison_exp;
  }

  @override
  void update(void Function(GString_comparison_expBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  GString_comparison_exp build() => _build();

  _$GString_comparison_exp _build() {
    _$GString_comparison_exp _$result;
    try {
      _$result = _$v ??
          new _$GString_comparison_exp._(
              G_eq: G_eq,
              G_gt: G_gt,
              G_gte: G_gte,
              G_ilike: G_ilike,
              G_in: _G_in?.build(),
              G_iregex: G_iregex,
              G_is_null: G_is_null,
              G_like: G_like,
              G_lt: G_lt,
              G_lte: G_lte,
              G_neq: G_neq,
              G_nilike: G_nilike,
              G_nin: _G_nin?.build(),
              G_niregex: G_niregex,
              G_nlike: G_nlike,
              G_nregex: G_nregex,
              G_nsimilar: G_nsimilar,
              G_regex: G_regex,
              G_similar: G_similar);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'G_in';
        _G_in?.build();

        _$failedField = 'G_nin';
        _G_nin?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'GString_comparison_exp', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gtimestamptz_comparison_exp extends Gtimestamptz_comparison_exp {
  @override
  final DateTime? G_eq;
  @override
  final DateTime? G_gt;
  @override
  final DateTime? G_gte;
  @override
  final BuiltList<DateTime>? G_in;
  @override
  final bool? G_is_null;
  @override
  final DateTime? G_lt;
  @override
  final DateTime? G_lte;
  @override
  final DateTime? G_neq;
  @override
  final BuiltList<DateTime>? G_nin;

  factory _$Gtimestamptz_comparison_exp(
          [void Function(Gtimestamptz_comparison_expBuilder)? updates]) =>
      (new Gtimestamptz_comparison_expBuilder()..update(updates))._build();

  _$Gtimestamptz_comparison_exp._(
      {this.G_eq,
      this.G_gt,
      this.G_gte,
      this.G_in,
      this.G_is_null,
      this.G_lt,
      this.G_lte,
      this.G_neq,
      this.G_nin})
      : super._();

  @override
  Gtimestamptz_comparison_exp rebuild(
          void Function(Gtimestamptz_comparison_expBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gtimestamptz_comparison_expBuilder toBuilder() =>
      new Gtimestamptz_comparison_expBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gtimestamptz_comparison_exp &&
        G_eq == other.G_eq &&
        G_gt == other.G_gt &&
        G_gte == other.G_gte &&
        G_in == other.G_in &&
        G_is_null == other.G_is_null &&
        G_lt == other.G_lt &&
        G_lte == other.G_lte &&
        G_neq == other.G_neq &&
        G_nin == other.G_nin;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, G_eq.hashCode);
    _$hash = $jc(_$hash, G_gt.hashCode);
    _$hash = $jc(_$hash, G_gte.hashCode);
    _$hash = $jc(_$hash, G_in.hashCode);
    _$hash = $jc(_$hash, G_is_null.hashCode);
    _$hash = $jc(_$hash, G_lt.hashCode);
    _$hash = $jc(_$hash, G_lte.hashCode);
    _$hash = $jc(_$hash, G_neq.hashCode);
    _$hash = $jc(_$hash, G_nin.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gtimestamptz_comparison_exp')
          ..add('G_eq', G_eq)
          ..add('G_gt', G_gt)
          ..add('G_gte', G_gte)
          ..add('G_in', G_in)
          ..add('G_is_null', G_is_null)
          ..add('G_lt', G_lt)
          ..add('G_lte', G_lte)
          ..add('G_neq', G_neq)
          ..add('G_nin', G_nin))
        .toString();
  }
}

class Gtimestamptz_comparison_expBuilder
    implements
        Builder<Gtimestamptz_comparison_exp,
            Gtimestamptz_comparison_expBuilder> {
  _$Gtimestamptz_comparison_exp? _$v;

  DateTime? _G_eq;
  DateTime? get G_eq => _$this._G_eq;
  set G_eq(DateTime? G_eq) => _$this._G_eq = G_eq;

  DateTime? _G_gt;
  DateTime? get G_gt => _$this._G_gt;
  set G_gt(DateTime? G_gt) => _$this._G_gt = G_gt;

  DateTime? _G_gte;
  DateTime? get G_gte => _$this._G_gte;
  set G_gte(DateTime? G_gte) => _$this._G_gte = G_gte;

  ListBuilder<DateTime>? _G_in;
  ListBuilder<DateTime> get G_in =>
      _$this._G_in ??= new ListBuilder<DateTime>();
  set G_in(ListBuilder<DateTime>? G_in) => _$this._G_in = G_in;

  bool? _G_is_null;
  bool? get G_is_null => _$this._G_is_null;
  set G_is_null(bool? G_is_null) => _$this._G_is_null = G_is_null;

  DateTime? _G_lt;
  DateTime? get G_lt => _$this._G_lt;
  set G_lt(DateTime? G_lt) => _$this._G_lt = G_lt;

  DateTime? _G_lte;
  DateTime? get G_lte => _$this._G_lte;
  set G_lte(DateTime? G_lte) => _$this._G_lte = G_lte;

  DateTime? _G_neq;
  DateTime? get G_neq => _$this._G_neq;
  set G_neq(DateTime? G_neq) => _$this._G_neq = G_neq;

  ListBuilder<DateTime>? _G_nin;
  ListBuilder<DateTime> get G_nin =>
      _$this._G_nin ??= new ListBuilder<DateTime>();
  set G_nin(ListBuilder<DateTime>? G_nin) => _$this._G_nin = G_nin;

  Gtimestamptz_comparison_expBuilder();

  Gtimestamptz_comparison_expBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _G_eq = $v.G_eq;
      _G_gt = $v.G_gt;
      _G_gte = $v.G_gte;
      _G_in = $v.G_in?.toBuilder();
      _G_is_null = $v.G_is_null;
      _G_lt = $v.G_lt;
      _G_lte = $v.G_lte;
      _G_neq = $v.G_neq;
      _G_nin = $v.G_nin?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gtimestamptz_comparison_exp other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gtimestamptz_comparison_exp;
  }

  @override
  void update(void Function(Gtimestamptz_comparison_expBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gtimestamptz_comparison_exp build() => _build();

  _$Gtimestamptz_comparison_exp _build() {
    _$Gtimestamptz_comparison_exp _$result;
    try {
      _$result = _$v ??
          new _$Gtimestamptz_comparison_exp._(
              G_eq: G_eq,
              G_gt: G_gt,
              G_gte: G_gte,
              G_in: _G_in?.build(),
              G_is_null: G_is_null,
              G_lt: G_lt,
              G_lte: G_lte,
              G_neq: G_neq,
              G_nin: _G_nin?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'G_in';
        _G_in?.build();

        _$failedField = 'G_nin';
        _G_nin?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gtimestamptz_comparison_exp', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gtstzrange_comparison_exp extends Gtstzrange_comparison_exp {
  @override
  final _i3.DateTimeRange? G_eq;
  @override
  final _i3.DateTimeRange? G_gt;
  @override
  final _i3.DateTimeRange? G_gte;
  @override
  final BuiltList<_i3.DateTimeRange>? G_in;
  @override
  final bool? G_is_null;
  @override
  final _i3.DateTimeRange? G_lt;
  @override
  final _i3.DateTimeRange? G_lte;
  @override
  final _i3.DateTimeRange? G_neq;
  @override
  final BuiltList<_i3.DateTimeRange>? G_nin;

  factory _$Gtstzrange_comparison_exp(
          [void Function(Gtstzrange_comparison_expBuilder)? updates]) =>
      (new Gtstzrange_comparison_expBuilder()..update(updates))._build();

  _$Gtstzrange_comparison_exp._(
      {this.G_eq,
      this.G_gt,
      this.G_gte,
      this.G_in,
      this.G_is_null,
      this.G_lt,
      this.G_lte,
      this.G_neq,
      this.G_nin})
      : super._();

  @override
  Gtstzrange_comparison_exp rebuild(
          void Function(Gtstzrange_comparison_expBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gtstzrange_comparison_expBuilder toBuilder() =>
      new Gtstzrange_comparison_expBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gtstzrange_comparison_exp &&
        G_eq == other.G_eq &&
        G_gt == other.G_gt &&
        G_gte == other.G_gte &&
        G_in == other.G_in &&
        G_is_null == other.G_is_null &&
        G_lt == other.G_lt &&
        G_lte == other.G_lte &&
        G_neq == other.G_neq &&
        G_nin == other.G_nin;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, G_eq.hashCode);
    _$hash = $jc(_$hash, G_gt.hashCode);
    _$hash = $jc(_$hash, G_gte.hashCode);
    _$hash = $jc(_$hash, G_in.hashCode);
    _$hash = $jc(_$hash, G_is_null.hashCode);
    _$hash = $jc(_$hash, G_lt.hashCode);
    _$hash = $jc(_$hash, G_lte.hashCode);
    _$hash = $jc(_$hash, G_neq.hashCode);
    _$hash = $jc(_$hash, G_nin.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gtstzrange_comparison_exp')
          ..add('G_eq', G_eq)
          ..add('G_gt', G_gt)
          ..add('G_gte', G_gte)
          ..add('G_in', G_in)
          ..add('G_is_null', G_is_null)
          ..add('G_lt', G_lt)
          ..add('G_lte', G_lte)
          ..add('G_neq', G_neq)
          ..add('G_nin', G_nin))
        .toString();
  }
}

class Gtstzrange_comparison_expBuilder
    implements
        Builder<Gtstzrange_comparison_exp, Gtstzrange_comparison_expBuilder> {
  _$Gtstzrange_comparison_exp? _$v;

  _i3.DateTimeRange? _G_eq;
  _i3.DateTimeRange? get G_eq => _$this._G_eq;
  set G_eq(_i3.DateTimeRange? G_eq) => _$this._G_eq = G_eq;

  _i3.DateTimeRange? _G_gt;
  _i3.DateTimeRange? get G_gt => _$this._G_gt;
  set G_gt(_i3.DateTimeRange? G_gt) => _$this._G_gt = G_gt;

  _i3.DateTimeRange? _G_gte;
  _i3.DateTimeRange? get G_gte => _$this._G_gte;
  set G_gte(_i3.DateTimeRange? G_gte) => _$this._G_gte = G_gte;

  ListBuilder<_i3.DateTimeRange>? _G_in;
  ListBuilder<_i3.DateTimeRange> get G_in =>
      _$this._G_in ??= new ListBuilder<_i3.DateTimeRange>();
  set G_in(ListBuilder<_i3.DateTimeRange>? G_in) => _$this._G_in = G_in;

  bool? _G_is_null;
  bool? get G_is_null => _$this._G_is_null;
  set G_is_null(bool? G_is_null) => _$this._G_is_null = G_is_null;

  _i3.DateTimeRange? _G_lt;
  _i3.DateTimeRange? get G_lt => _$this._G_lt;
  set G_lt(_i3.DateTimeRange? G_lt) => _$this._G_lt = G_lt;

  _i3.DateTimeRange? _G_lte;
  _i3.DateTimeRange? get G_lte => _$this._G_lte;
  set G_lte(_i3.DateTimeRange? G_lte) => _$this._G_lte = G_lte;

  _i3.DateTimeRange? _G_neq;
  _i3.DateTimeRange? get G_neq => _$this._G_neq;
  set G_neq(_i3.DateTimeRange? G_neq) => _$this._G_neq = G_neq;

  ListBuilder<_i3.DateTimeRange>? _G_nin;
  ListBuilder<_i3.DateTimeRange> get G_nin =>
      _$this._G_nin ??= new ListBuilder<_i3.DateTimeRange>();
  set G_nin(ListBuilder<_i3.DateTimeRange>? G_nin) => _$this._G_nin = G_nin;

  Gtstzrange_comparison_expBuilder();

  Gtstzrange_comparison_expBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _G_eq = $v.G_eq;
      _G_gt = $v.G_gt;
      _G_gte = $v.G_gte;
      _G_in = $v.G_in?.toBuilder();
      _G_is_null = $v.G_is_null;
      _G_lt = $v.G_lt;
      _G_lte = $v.G_lte;
      _G_neq = $v.G_neq;
      _G_nin = $v.G_nin?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gtstzrange_comparison_exp other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gtstzrange_comparison_exp;
  }

  @override
  void update(void Function(Gtstzrange_comparison_expBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gtstzrange_comparison_exp build() => _build();

  _$Gtstzrange_comparison_exp _build() {
    _$Gtstzrange_comparison_exp _$result;
    try {
      _$result = _$v ??
          new _$Gtstzrange_comparison_exp._(
              G_eq: G_eq,
              G_gt: G_gt,
              G_gte: G_gte,
              G_in: _G_in?.build(),
              G_is_null: G_is_null,
              G_lt: G_lt,
              G_lte: G_lte,
              G_neq: G_neq,
              G_nin: _G_nin?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'G_in';
        _G_in?.build();

        _$failedField = 'G_nin';
        _G_nin?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gtstzrange_comparison_exp', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Guser_bool_exp extends Guser_bool_exp {
  @override
  final BuiltList<Guser_bool_exp>? G_and;
  @override
  final Guser_bool_exp? G_not;
  @override
  final BuiltList<Guser_bool_exp>? G_or;
  @override
  final Gtimestamptz_comparison_exp? created_at;
  @override
  final GString_comparison_exp? description;
  @override
  final GBoolean_comparison_exp? has_picture;
  @override
  final GString_comparison_exp? id;
  @override
  final GString_comparison_exp? title;
  @override
  final Gtimestamptz_comparison_exp? updated_at;

  factory _$Guser_bool_exp([void Function(Guser_bool_expBuilder)? updates]) =>
      (new Guser_bool_expBuilder()..update(updates))._build();

  _$Guser_bool_exp._(
      {this.G_and,
      this.G_not,
      this.G_or,
      this.created_at,
      this.description,
      this.has_picture,
      this.id,
      this.title,
      this.updated_at})
      : super._();

  @override
  Guser_bool_exp rebuild(void Function(Guser_bool_expBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Guser_bool_expBuilder toBuilder() =>
      new Guser_bool_expBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Guser_bool_exp &&
        G_and == other.G_and &&
        G_not == other.G_not &&
        G_or == other.G_or &&
        created_at == other.created_at &&
        description == other.description &&
        has_picture == other.has_picture &&
        id == other.id &&
        title == other.title &&
        updated_at == other.updated_at;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, G_and.hashCode);
    _$hash = $jc(_$hash, G_not.hashCode);
    _$hash = $jc(_$hash, G_or.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, description.hashCode);
    _$hash = $jc(_$hash, has_picture.hashCode);
    _$hash = $jc(_$hash, id.hashCode);
    _$hash = $jc(_$hash, title.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Guser_bool_exp')
          ..add('G_and', G_and)
          ..add('G_not', G_not)
          ..add('G_or', G_or)
          ..add('created_at', created_at)
          ..add('description', description)
          ..add('has_picture', has_picture)
          ..add('id', id)
          ..add('title', title)
          ..add('updated_at', updated_at))
        .toString();
  }
}

class Guser_bool_expBuilder
    implements Builder<Guser_bool_exp, Guser_bool_expBuilder> {
  _$Guser_bool_exp? _$v;

  ListBuilder<Guser_bool_exp>? _G_and;
  ListBuilder<Guser_bool_exp> get G_and =>
      _$this._G_and ??= new ListBuilder<Guser_bool_exp>();
  set G_and(ListBuilder<Guser_bool_exp>? G_and) => _$this._G_and = G_and;

  Guser_bool_expBuilder? _G_not;
  Guser_bool_expBuilder get G_not =>
      _$this._G_not ??= new Guser_bool_expBuilder();
  set G_not(Guser_bool_expBuilder? G_not) => _$this._G_not = G_not;

  ListBuilder<Guser_bool_exp>? _G_or;
  ListBuilder<Guser_bool_exp> get G_or =>
      _$this._G_or ??= new ListBuilder<Guser_bool_exp>();
  set G_or(ListBuilder<Guser_bool_exp>? G_or) => _$this._G_or = G_or;

  Gtimestamptz_comparison_expBuilder? _created_at;
  Gtimestamptz_comparison_expBuilder get created_at =>
      _$this._created_at ??= new Gtimestamptz_comparison_expBuilder();
  set created_at(Gtimestamptz_comparison_expBuilder? created_at) =>
      _$this._created_at = created_at;

  GString_comparison_expBuilder? _description;
  GString_comparison_expBuilder get description =>
      _$this._description ??= new GString_comparison_expBuilder();
  set description(GString_comparison_expBuilder? description) =>
      _$this._description = description;

  GBoolean_comparison_expBuilder? _has_picture;
  GBoolean_comparison_expBuilder get has_picture =>
      _$this._has_picture ??= new GBoolean_comparison_expBuilder();
  set has_picture(GBoolean_comparison_expBuilder? has_picture) =>
      _$this._has_picture = has_picture;

  GString_comparison_expBuilder? _id;
  GString_comparison_expBuilder get id =>
      _$this._id ??= new GString_comparison_expBuilder();
  set id(GString_comparison_expBuilder? id) => _$this._id = id;

  GString_comparison_expBuilder? _title;
  GString_comparison_expBuilder get title =>
      _$this._title ??= new GString_comparison_expBuilder();
  set title(GString_comparison_expBuilder? title) => _$this._title = title;

  Gtimestamptz_comparison_expBuilder? _updated_at;
  Gtimestamptz_comparison_expBuilder get updated_at =>
      _$this._updated_at ??= new Gtimestamptz_comparison_expBuilder();
  set updated_at(Gtimestamptz_comparison_expBuilder? updated_at) =>
      _$this._updated_at = updated_at;

  Guser_bool_expBuilder();

  Guser_bool_expBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _G_and = $v.G_and?.toBuilder();
      _G_not = $v.G_not?.toBuilder();
      _G_or = $v.G_or?.toBuilder();
      _created_at = $v.created_at?.toBuilder();
      _description = $v.description?.toBuilder();
      _has_picture = $v.has_picture?.toBuilder();
      _id = $v.id?.toBuilder();
      _title = $v.title?.toBuilder();
      _updated_at = $v.updated_at?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Guser_bool_exp other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Guser_bool_exp;
  }

  @override
  void update(void Function(Guser_bool_expBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Guser_bool_exp build() => _build();

  _$Guser_bool_exp _build() {
    _$Guser_bool_exp _$result;
    try {
      _$result = _$v ??
          new _$Guser_bool_exp._(
              G_and: _G_and?.build(),
              G_not: _G_not?.build(),
              G_or: _G_or?.build(),
              created_at: _created_at?.build(),
              description: _description?.build(),
              has_picture: _has_picture?.build(),
              id: _id?.build(),
              title: _title?.build(),
              updated_at: _updated_at?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'G_and';
        _G_and?.build();
        _$failedField = 'G_not';
        _G_not?.build();
        _$failedField = 'G_or';
        _G_or?.build();
        _$failedField = 'created_at';
        _created_at?.build();
        _$failedField = 'description';
        _description?.build();
        _$failedField = 'has_picture';
        _has_picture?.build();
        _$failedField = 'id';
        _id?.build();
        _$failedField = 'title';
        _title?.build();
        _$failedField = 'updated_at';
        _updated_at?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Guser_bool_exp', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Guser_insert_input extends Guser_insert_input {
  @override
  final DateTime? created_at;
  @override
  final String? description;
  @override
  final bool? has_picture;
  @override
  final String? id;
  @override
  final String? title;
  @override
  final DateTime? updated_at;

  factory _$Guser_insert_input(
          [void Function(Guser_insert_inputBuilder)? updates]) =>
      (new Guser_insert_inputBuilder()..update(updates))._build();

  _$Guser_insert_input._(
      {this.created_at,
      this.description,
      this.has_picture,
      this.id,
      this.title,
      this.updated_at})
      : super._();

  @override
  Guser_insert_input rebuild(
          void Function(Guser_insert_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Guser_insert_inputBuilder toBuilder() =>
      new Guser_insert_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Guser_insert_input &&
        created_at == other.created_at &&
        description == other.description &&
        has_picture == other.has_picture &&
        id == other.id &&
        title == other.title &&
        updated_at == other.updated_at;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, description.hashCode);
    _$hash = $jc(_$hash, has_picture.hashCode);
    _$hash = $jc(_$hash, id.hashCode);
    _$hash = $jc(_$hash, title.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Guser_insert_input')
          ..add('created_at', created_at)
          ..add('description', description)
          ..add('has_picture', has_picture)
          ..add('id', id)
          ..add('title', title)
          ..add('updated_at', updated_at))
        .toString();
  }
}

class Guser_insert_inputBuilder
    implements Builder<Guser_insert_input, Guser_insert_inputBuilder> {
  _$Guser_insert_input? _$v;

  DateTime? _created_at;
  DateTime? get created_at => _$this._created_at;
  set created_at(DateTime? created_at) => _$this._created_at = created_at;

  String? _description;
  String? get description => _$this._description;
  set description(String? description) => _$this._description = description;

  bool? _has_picture;
  bool? get has_picture => _$this._has_picture;
  set has_picture(bool? has_picture) => _$this._has_picture = has_picture;

  String? _id;
  String? get id => _$this._id;
  set id(String? id) => _$this._id = id;

  String? _title;
  String? get title => _$this._title;
  set title(String? title) => _$this._title = title;

  DateTime? _updated_at;
  DateTime? get updated_at => _$this._updated_at;
  set updated_at(DateTime? updated_at) => _$this._updated_at = updated_at;

  Guser_insert_inputBuilder();

  Guser_insert_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _created_at = $v.created_at;
      _description = $v.description;
      _has_picture = $v.has_picture;
      _id = $v.id;
      _title = $v.title;
      _updated_at = $v.updated_at;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Guser_insert_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Guser_insert_input;
  }

  @override
  void update(void Function(Guser_insert_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Guser_insert_input build() => _build();

  _$Guser_insert_input _build() {
    final _$result = _$v ??
        new _$Guser_insert_input._(
            created_at: created_at,
            description: description,
            has_picture: has_picture,
            id: id,
            title: title,
            updated_at: updated_at);
    replace(_$result);
    return _$result;
  }
}

class _$Guser_obj_rel_insert_input extends Guser_obj_rel_insert_input {
  @override
  final Guser_insert_input data;
  @override
  final Guser_on_conflict? on_conflict;

  factory _$Guser_obj_rel_insert_input(
          [void Function(Guser_obj_rel_insert_inputBuilder)? updates]) =>
      (new Guser_obj_rel_insert_inputBuilder()..update(updates))._build();

  _$Guser_obj_rel_insert_input._({required this.data, this.on_conflict})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        data, r'Guser_obj_rel_insert_input', 'data');
  }

  @override
  Guser_obj_rel_insert_input rebuild(
          void Function(Guser_obj_rel_insert_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Guser_obj_rel_insert_inputBuilder toBuilder() =>
      new Guser_obj_rel_insert_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Guser_obj_rel_insert_input &&
        data == other.data &&
        on_conflict == other.on_conflict;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, data.hashCode);
    _$hash = $jc(_$hash, on_conflict.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Guser_obj_rel_insert_input')
          ..add('data', data)
          ..add('on_conflict', on_conflict))
        .toString();
  }
}

class Guser_obj_rel_insert_inputBuilder
    implements
        Builder<Guser_obj_rel_insert_input, Guser_obj_rel_insert_inputBuilder> {
  _$Guser_obj_rel_insert_input? _$v;

  Guser_insert_inputBuilder? _data;
  Guser_insert_inputBuilder get data =>
      _$this._data ??= new Guser_insert_inputBuilder();
  set data(Guser_insert_inputBuilder? data) => _$this._data = data;

  Guser_on_conflictBuilder? _on_conflict;
  Guser_on_conflictBuilder get on_conflict =>
      _$this._on_conflict ??= new Guser_on_conflictBuilder();
  set on_conflict(Guser_on_conflictBuilder? on_conflict) =>
      _$this._on_conflict = on_conflict;

  Guser_obj_rel_insert_inputBuilder();

  Guser_obj_rel_insert_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _data = $v.data.toBuilder();
      _on_conflict = $v.on_conflict?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Guser_obj_rel_insert_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Guser_obj_rel_insert_input;
  }

  @override
  void update(void Function(Guser_obj_rel_insert_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Guser_obj_rel_insert_input build() => _build();

  _$Guser_obj_rel_insert_input _build() {
    _$Guser_obj_rel_insert_input _$result;
    try {
      _$result = _$v ??
          new _$Guser_obj_rel_insert_input._(
              data: data.build(), on_conflict: _on_conflict?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'data';
        data.build();
        _$failedField = 'on_conflict';
        _on_conflict?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Guser_obj_rel_insert_input', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Guser_on_conflict extends Guser_on_conflict {
  @override
  final Guser_constraint constraint;
  @override
  final BuiltList<Guser_update_column> update_columns;
  @override
  final Guser_bool_exp? where;

  factory _$Guser_on_conflict(
          [void Function(Guser_on_conflictBuilder)? updates]) =>
      (new Guser_on_conflictBuilder()..update(updates))._build();

  _$Guser_on_conflict._(
      {required this.constraint, required this.update_columns, this.where})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        constraint, r'Guser_on_conflict', 'constraint');
    BuiltValueNullFieldError.checkNotNull(
        update_columns, r'Guser_on_conflict', 'update_columns');
  }

  @override
  Guser_on_conflict rebuild(void Function(Guser_on_conflictBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Guser_on_conflictBuilder toBuilder() =>
      new Guser_on_conflictBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Guser_on_conflict &&
        constraint == other.constraint &&
        update_columns == other.update_columns &&
        where == other.where;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, constraint.hashCode);
    _$hash = $jc(_$hash, update_columns.hashCode);
    _$hash = $jc(_$hash, where.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Guser_on_conflict')
          ..add('constraint', constraint)
          ..add('update_columns', update_columns)
          ..add('where', where))
        .toString();
  }
}

class Guser_on_conflictBuilder
    implements Builder<Guser_on_conflict, Guser_on_conflictBuilder> {
  _$Guser_on_conflict? _$v;

  Guser_constraint? _constraint;
  Guser_constraint? get constraint => _$this._constraint;
  set constraint(Guser_constraint? constraint) =>
      _$this._constraint = constraint;

  ListBuilder<Guser_update_column>? _update_columns;
  ListBuilder<Guser_update_column> get update_columns =>
      _$this._update_columns ??= new ListBuilder<Guser_update_column>();
  set update_columns(ListBuilder<Guser_update_column>? update_columns) =>
      _$this._update_columns = update_columns;

  Guser_bool_expBuilder? _where;
  Guser_bool_expBuilder get where =>
      _$this._where ??= new Guser_bool_expBuilder();
  set where(Guser_bool_expBuilder? where) => _$this._where = where;

  Guser_on_conflictBuilder();

  Guser_on_conflictBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _constraint = $v.constraint;
      _update_columns = $v.update_columns.toBuilder();
      _where = $v.where?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Guser_on_conflict other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Guser_on_conflict;
  }

  @override
  void update(void Function(Guser_on_conflictBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Guser_on_conflict build() => _build();

  _$Guser_on_conflict _build() {
    _$Guser_on_conflict _$result;
    try {
      _$result = _$v ??
          new _$Guser_on_conflict._(
              constraint: BuiltValueNullFieldError.checkNotNull(
                  constraint, r'Guser_on_conflict', 'constraint'),
              update_columns: update_columns.build(),
              where: _where?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'update_columns';
        update_columns.build();
        _$failedField = 'where';
        _where?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Guser_on_conflict', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Guser_order_by extends Guser_order_by {
  @override
  final Gorder_by? created_at;
  @override
  final Gorder_by? description;
  @override
  final Gorder_by? has_picture;
  @override
  final Gorder_by? id;
  @override
  final Gorder_by? title;
  @override
  final Gorder_by? updated_at;

  factory _$Guser_order_by([void Function(Guser_order_byBuilder)? updates]) =>
      (new Guser_order_byBuilder()..update(updates))._build();

  _$Guser_order_by._(
      {this.created_at,
      this.description,
      this.has_picture,
      this.id,
      this.title,
      this.updated_at})
      : super._();

  @override
  Guser_order_by rebuild(void Function(Guser_order_byBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Guser_order_byBuilder toBuilder() =>
      new Guser_order_byBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Guser_order_by &&
        created_at == other.created_at &&
        description == other.description &&
        has_picture == other.has_picture &&
        id == other.id &&
        title == other.title &&
        updated_at == other.updated_at;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, description.hashCode);
    _$hash = $jc(_$hash, has_picture.hashCode);
    _$hash = $jc(_$hash, id.hashCode);
    _$hash = $jc(_$hash, title.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Guser_order_by')
          ..add('created_at', created_at)
          ..add('description', description)
          ..add('has_picture', has_picture)
          ..add('id', id)
          ..add('title', title)
          ..add('updated_at', updated_at))
        .toString();
  }
}

class Guser_order_byBuilder
    implements Builder<Guser_order_by, Guser_order_byBuilder> {
  _$Guser_order_by? _$v;

  Gorder_by? _created_at;
  Gorder_by? get created_at => _$this._created_at;
  set created_at(Gorder_by? created_at) => _$this._created_at = created_at;

  Gorder_by? _description;
  Gorder_by? get description => _$this._description;
  set description(Gorder_by? description) => _$this._description = description;

  Gorder_by? _has_picture;
  Gorder_by? get has_picture => _$this._has_picture;
  set has_picture(Gorder_by? has_picture) => _$this._has_picture = has_picture;

  Gorder_by? _id;
  Gorder_by? get id => _$this._id;
  set id(Gorder_by? id) => _$this._id = id;

  Gorder_by? _title;
  Gorder_by? get title => _$this._title;
  set title(Gorder_by? title) => _$this._title = title;

  Gorder_by? _updated_at;
  Gorder_by? get updated_at => _$this._updated_at;
  set updated_at(Gorder_by? updated_at) => _$this._updated_at = updated_at;

  Guser_order_byBuilder();

  Guser_order_byBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _created_at = $v.created_at;
      _description = $v.description;
      _has_picture = $v.has_picture;
      _id = $v.id;
      _title = $v.title;
      _updated_at = $v.updated_at;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Guser_order_by other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Guser_order_by;
  }

  @override
  void update(void Function(Guser_order_byBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Guser_order_by build() => _build();

  _$Guser_order_by _build() {
    final _$result = _$v ??
        new _$Guser_order_by._(
            created_at: created_at,
            description: description,
            has_picture: has_picture,
            id: id,
            title: title,
            updated_at: updated_at);
    replace(_$result);
    return _$result;
  }
}

class _$Guser_pk_columns_input extends Guser_pk_columns_input {
  @override
  final String id;

  factory _$Guser_pk_columns_input(
          [void Function(Guser_pk_columns_inputBuilder)? updates]) =>
      (new Guser_pk_columns_inputBuilder()..update(updates))._build();

  _$Guser_pk_columns_input._({required this.id}) : super._() {
    BuiltValueNullFieldError.checkNotNull(id, r'Guser_pk_columns_input', 'id');
  }

  @override
  Guser_pk_columns_input rebuild(
          void Function(Guser_pk_columns_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Guser_pk_columns_inputBuilder toBuilder() =>
      new Guser_pk_columns_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Guser_pk_columns_input && id == other.id;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, id.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Guser_pk_columns_input')
          ..add('id', id))
        .toString();
  }
}

class Guser_pk_columns_inputBuilder
    implements Builder<Guser_pk_columns_input, Guser_pk_columns_inputBuilder> {
  _$Guser_pk_columns_input? _$v;

  String? _id;
  String? get id => _$this._id;
  set id(String? id) => _$this._id = id;

  Guser_pk_columns_inputBuilder();

  Guser_pk_columns_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _id = $v.id;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Guser_pk_columns_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Guser_pk_columns_input;
  }

  @override
  void update(void Function(Guser_pk_columns_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Guser_pk_columns_input build() => _build();

  _$Guser_pk_columns_input _build() {
    final _$result = _$v ??
        new _$Guser_pk_columns_input._(
            id: BuiltValueNullFieldError.checkNotNull(
                id, r'Guser_pk_columns_input', 'id'));
    replace(_$result);
    return _$result;
  }
}

class _$Guser_set_input extends Guser_set_input {
  @override
  final DateTime? created_at;
  @override
  final String? description;
  @override
  final bool? has_picture;
  @override
  final String? id;
  @override
  final String? title;
  @override
  final DateTime? updated_at;

  factory _$Guser_set_input([void Function(Guser_set_inputBuilder)? updates]) =>
      (new Guser_set_inputBuilder()..update(updates))._build();

  _$Guser_set_input._(
      {this.created_at,
      this.description,
      this.has_picture,
      this.id,
      this.title,
      this.updated_at})
      : super._();

  @override
  Guser_set_input rebuild(void Function(Guser_set_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Guser_set_inputBuilder toBuilder() =>
      new Guser_set_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Guser_set_input &&
        created_at == other.created_at &&
        description == other.description &&
        has_picture == other.has_picture &&
        id == other.id &&
        title == other.title &&
        updated_at == other.updated_at;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, description.hashCode);
    _$hash = $jc(_$hash, has_picture.hashCode);
    _$hash = $jc(_$hash, id.hashCode);
    _$hash = $jc(_$hash, title.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Guser_set_input')
          ..add('created_at', created_at)
          ..add('description', description)
          ..add('has_picture', has_picture)
          ..add('id', id)
          ..add('title', title)
          ..add('updated_at', updated_at))
        .toString();
  }
}

class Guser_set_inputBuilder
    implements Builder<Guser_set_input, Guser_set_inputBuilder> {
  _$Guser_set_input? _$v;

  DateTime? _created_at;
  DateTime? get created_at => _$this._created_at;
  set created_at(DateTime? created_at) => _$this._created_at = created_at;

  String? _description;
  String? get description => _$this._description;
  set description(String? description) => _$this._description = description;

  bool? _has_picture;
  bool? get has_picture => _$this._has_picture;
  set has_picture(bool? has_picture) => _$this._has_picture = has_picture;

  String? _id;
  String? get id => _$this._id;
  set id(String? id) => _$this._id = id;

  String? _title;
  String? get title => _$this._title;
  set title(String? title) => _$this._title = title;

  DateTime? _updated_at;
  DateTime? get updated_at => _$this._updated_at;
  set updated_at(DateTime? updated_at) => _$this._updated_at = updated_at;

  Guser_set_inputBuilder();

  Guser_set_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _created_at = $v.created_at;
      _description = $v.description;
      _has_picture = $v.has_picture;
      _id = $v.id;
      _title = $v.title;
      _updated_at = $v.updated_at;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Guser_set_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Guser_set_input;
  }

  @override
  void update(void Function(Guser_set_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Guser_set_input build() => _build();

  _$Guser_set_input _build() {
    final _$result = _$v ??
        new _$Guser_set_input._(
            created_at: created_at,
            description: description,
            has_picture: has_picture,
            id: id,
            title: title,
            updated_at: updated_at);
    replace(_$result);
    return _$result;
  }
}

class _$Guser_stream_cursor_input extends Guser_stream_cursor_input {
  @override
  final Guser_stream_cursor_value_input initial_value;
  @override
  final Gcursor_ordering? ordering;

  factory _$Guser_stream_cursor_input(
          [void Function(Guser_stream_cursor_inputBuilder)? updates]) =>
      (new Guser_stream_cursor_inputBuilder()..update(updates))._build();

  _$Guser_stream_cursor_input._({required this.initial_value, this.ordering})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        initial_value, r'Guser_stream_cursor_input', 'initial_value');
  }

  @override
  Guser_stream_cursor_input rebuild(
          void Function(Guser_stream_cursor_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Guser_stream_cursor_inputBuilder toBuilder() =>
      new Guser_stream_cursor_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Guser_stream_cursor_input &&
        initial_value == other.initial_value &&
        ordering == other.ordering;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, initial_value.hashCode);
    _$hash = $jc(_$hash, ordering.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Guser_stream_cursor_input')
          ..add('initial_value', initial_value)
          ..add('ordering', ordering))
        .toString();
  }
}

class Guser_stream_cursor_inputBuilder
    implements
        Builder<Guser_stream_cursor_input, Guser_stream_cursor_inputBuilder> {
  _$Guser_stream_cursor_input? _$v;

  Guser_stream_cursor_value_inputBuilder? _initial_value;
  Guser_stream_cursor_value_inputBuilder get initial_value =>
      _$this._initial_value ??= new Guser_stream_cursor_value_inputBuilder();
  set initial_value(Guser_stream_cursor_value_inputBuilder? initial_value) =>
      _$this._initial_value = initial_value;

  Gcursor_ordering? _ordering;
  Gcursor_ordering? get ordering => _$this._ordering;
  set ordering(Gcursor_ordering? ordering) => _$this._ordering = ordering;

  Guser_stream_cursor_inputBuilder();

  Guser_stream_cursor_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _initial_value = $v.initial_value.toBuilder();
      _ordering = $v.ordering;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Guser_stream_cursor_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Guser_stream_cursor_input;
  }

  @override
  void update(void Function(Guser_stream_cursor_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Guser_stream_cursor_input build() => _build();

  _$Guser_stream_cursor_input _build() {
    _$Guser_stream_cursor_input _$result;
    try {
      _$result = _$v ??
          new _$Guser_stream_cursor_input._(
              initial_value: initial_value.build(), ordering: ordering);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'initial_value';
        initial_value.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Guser_stream_cursor_input', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Guser_stream_cursor_value_input
    extends Guser_stream_cursor_value_input {
  @override
  final DateTime? created_at;
  @override
  final String? description;
  @override
  final bool? has_picture;
  @override
  final String? id;
  @override
  final String? title;
  @override
  final DateTime? updated_at;

  factory _$Guser_stream_cursor_value_input(
          [void Function(Guser_stream_cursor_value_inputBuilder)? updates]) =>
      (new Guser_stream_cursor_value_inputBuilder()..update(updates))._build();

  _$Guser_stream_cursor_value_input._(
      {this.created_at,
      this.description,
      this.has_picture,
      this.id,
      this.title,
      this.updated_at})
      : super._();

  @override
  Guser_stream_cursor_value_input rebuild(
          void Function(Guser_stream_cursor_value_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Guser_stream_cursor_value_inputBuilder toBuilder() =>
      new Guser_stream_cursor_value_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Guser_stream_cursor_value_input &&
        created_at == other.created_at &&
        description == other.description &&
        has_picture == other.has_picture &&
        id == other.id &&
        title == other.title &&
        updated_at == other.updated_at;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, description.hashCode);
    _$hash = $jc(_$hash, has_picture.hashCode);
    _$hash = $jc(_$hash, id.hashCode);
    _$hash = $jc(_$hash, title.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Guser_stream_cursor_value_input')
          ..add('created_at', created_at)
          ..add('description', description)
          ..add('has_picture', has_picture)
          ..add('id', id)
          ..add('title', title)
          ..add('updated_at', updated_at))
        .toString();
  }
}

class Guser_stream_cursor_value_inputBuilder
    implements
        Builder<Guser_stream_cursor_value_input,
            Guser_stream_cursor_value_inputBuilder> {
  _$Guser_stream_cursor_value_input? _$v;

  DateTime? _created_at;
  DateTime? get created_at => _$this._created_at;
  set created_at(DateTime? created_at) => _$this._created_at = created_at;

  String? _description;
  String? get description => _$this._description;
  set description(String? description) => _$this._description = description;

  bool? _has_picture;
  bool? get has_picture => _$this._has_picture;
  set has_picture(bool? has_picture) => _$this._has_picture = has_picture;

  String? _id;
  String? get id => _$this._id;
  set id(String? id) => _$this._id = id;

  String? _title;
  String? get title => _$this._title;
  set title(String? title) => _$this._title = title;

  DateTime? _updated_at;
  DateTime? get updated_at => _$this._updated_at;
  set updated_at(DateTime? updated_at) => _$this._updated_at = updated_at;

  Guser_stream_cursor_value_inputBuilder();

  Guser_stream_cursor_value_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _created_at = $v.created_at;
      _description = $v.description;
      _has_picture = $v.has_picture;
      _id = $v.id;
      _title = $v.title;
      _updated_at = $v.updated_at;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Guser_stream_cursor_value_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Guser_stream_cursor_value_input;
  }

  @override
  void update(void Function(Guser_stream_cursor_value_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Guser_stream_cursor_value_input build() => _build();

  _$Guser_stream_cursor_value_input _build() {
    final _$result = _$v ??
        new _$Guser_stream_cursor_value_input._(
            created_at: created_at,
            description: description,
            has_picture: has_picture,
            id: id,
            title: title,
            updated_at: updated_at);
    replace(_$result);
    return _$result;
  }
}

class _$Guser_updates extends Guser_updates {
  @override
  final Guser_set_input? G_set;
  @override
  final Guser_bool_exp where;

  factory _$Guser_updates([void Function(Guser_updatesBuilder)? updates]) =>
      (new Guser_updatesBuilder()..update(updates))._build();

  _$Guser_updates._({this.G_set, required this.where}) : super._() {
    BuiltValueNullFieldError.checkNotNull(where, r'Guser_updates', 'where');
  }

  @override
  Guser_updates rebuild(void Function(Guser_updatesBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Guser_updatesBuilder toBuilder() => new Guser_updatesBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Guser_updates &&
        G_set == other.G_set &&
        where == other.where;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, G_set.hashCode);
    _$hash = $jc(_$hash, where.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Guser_updates')
          ..add('G_set', G_set)
          ..add('where', where))
        .toString();
  }
}

class Guser_updatesBuilder
    implements Builder<Guser_updates, Guser_updatesBuilder> {
  _$Guser_updates? _$v;

  Guser_set_inputBuilder? _G_set;
  Guser_set_inputBuilder get G_set =>
      _$this._G_set ??= new Guser_set_inputBuilder();
  set G_set(Guser_set_inputBuilder? G_set) => _$this._G_set = G_set;

  Guser_bool_expBuilder? _where;
  Guser_bool_expBuilder get where =>
      _$this._where ??= new Guser_bool_expBuilder();
  set where(Guser_bool_expBuilder? where) => _$this._where = where;

  Guser_updatesBuilder();

  Guser_updatesBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _G_set = $v.G_set?.toBuilder();
      _where = $v.where.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Guser_updates other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Guser_updates;
  }

  @override
  void update(void Function(Guser_updatesBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Guser_updates build() => _build();

  _$Guser_updates _build() {
    _$Guser_updates _$result;
    try {
      _$result = _$v ??
          new _$Guser_updates._(G_set: _G_set?.build(), where: where.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'G_set';
        _G_set?.build();
        _$failedField = 'where';
        where.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Guser_updates', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_beacon_bool_exp extends Gvote_beacon_bool_exp {
  @override
  final BuiltList<Gvote_beacon_bool_exp>? G_and;
  @override
  final Gvote_beacon_bool_exp? G_not;
  @override
  final BuiltList<Gvote_beacon_bool_exp>? G_or;
  @override
  final GInt_comparison_exp? amount;
  @override
  final Gtimestamptz_comparison_exp? created_at;
  @override
  final GString_comparison_exp? object;
  @override
  final GString_comparison_exp? subject;
  @override
  final Gtimestamptz_comparison_exp? updated_at;

  factory _$Gvote_beacon_bool_exp(
          [void Function(Gvote_beacon_bool_expBuilder)? updates]) =>
      (new Gvote_beacon_bool_expBuilder()..update(updates))._build();

  _$Gvote_beacon_bool_exp._(
      {this.G_and,
      this.G_not,
      this.G_or,
      this.amount,
      this.created_at,
      this.object,
      this.subject,
      this.updated_at})
      : super._();

  @override
  Gvote_beacon_bool_exp rebuild(
          void Function(Gvote_beacon_bool_expBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_beacon_bool_expBuilder toBuilder() =>
      new Gvote_beacon_bool_expBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_beacon_bool_exp &&
        G_and == other.G_and &&
        G_not == other.G_not &&
        G_or == other.G_or &&
        amount == other.amount &&
        created_at == other.created_at &&
        object == other.object &&
        subject == other.subject &&
        updated_at == other.updated_at;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, G_and.hashCode);
    _$hash = $jc(_$hash, G_not.hashCode);
    _$hash = $jc(_$hash, G_or.hashCode);
    _$hash = $jc(_$hash, amount.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, object.hashCode);
    _$hash = $jc(_$hash, subject.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_beacon_bool_exp')
          ..add('G_and', G_and)
          ..add('G_not', G_not)
          ..add('G_or', G_or)
          ..add('amount', amount)
          ..add('created_at', created_at)
          ..add('object', object)
          ..add('subject', subject)
          ..add('updated_at', updated_at))
        .toString();
  }
}

class Gvote_beacon_bool_expBuilder
    implements Builder<Gvote_beacon_bool_exp, Gvote_beacon_bool_expBuilder> {
  _$Gvote_beacon_bool_exp? _$v;

  ListBuilder<Gvote_beacon_bool_exp>? _G_and;
  ListBuilder<Gvote_beacon_bool_exp> get G_and =>
      _$this._G_and ??= new ListBuilder<Gvote_beacon_bool_exp>();
  set G_and(ListBuilder<Gvote_beacon_bool_exp>? G_and) => _$this._G_and = G_and;

  Gvote_beacon_bool_expBuilder? _G_not;
  Gvote_beacon_bool_expBuilder get G_not =>
      _$this._G_not ??= new Gvote_beacon_bool_expBuilder();
  set G_not(Gvote_beacon_bool_expBuilder? G_not) => _$this._G_not = G_not;

  ListBuilder<Gvote_beacon_bool_exp>? _G_or;
  ListBuilder<Gvote_beacon_bool_exp> get G_or =>
      _$this._G_or ??= new ListBuilder<Gvote_beacon_bool_exp>();
  set G_or(ListBuilder<Gvote_beacon_bool_exp>? G_or) => _$this._G_or = G_or;

  GInt_comparison_expBuilder? _amount;
  GInt_comparison_expBuilder get amount =>
      _$this._amount ??= new GInt_comparison_expBuilder();
  set amount(GInt_comparison_expBuilder? amount) => _$this._amount = amount;

  Gtimestamptz_comparison_expBuilder? _created_at;
  Gtimestamptz_comparison_expBuilder get created_at =>
      _$this._created_at ??= new Gtimestamptz_comparison_expBuilder();
  set created_at(Gtimestamptz_comparison_expBuilder? created_at) =>
      _$this._created_at = created_at;

  GString_comparison_expBuilder? _object;
  GString_comparison_expBuilder get object =>
      _$this._object ??= new GString_comparison_expBuilder();
  set object(GString_comparison_expBuilder? object) => _$this._object = object;

  GString_comparison_expBuilder? _subject;
  GString_comparison_expBuilder get subject =>
      _$this._subject ??= new GString_comparison_expBuilder();
  set subject(GString_comparison_expBuilder? subject) =>
      _$this._subject = subject;

  Gtimestamptz_comparison_expBuilder? _updated_at;
  Gtimestamptz_comparison_expBuilder get updated_at =>
      _$this._updated_at ??= new Gtimestamptz_comparison_expBuilder();
  set updated_at(Gtimestamptz_comparison_expBuilder? updated_at) =>
      _$this._updated_at = updated_at;

  Gvote_beacon_bool_expBuilder();

  Gvote_beacon_bool_expBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _G_and = $v.G_and?.toBuilder();
      _G_not = $v.G_not?.toBuilder();
      _G_or = $v.G_or?.toBuilder();
      _amount = $v.amount?.toBuilder();
      _created_at = $v.created_at?.toBuilder();
      _object = $v.object?.toBuilder();
      _subject = $v.subject?.toBuilder();
      _updated_at = $v.updated_at?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_beacon_bool_exp other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_beacon_bool_exp;
  }

  @override
  void update(void Function(Gvote_beacon_bool_expBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_beacon_bool_exp build() => _build();

  _$Gvote_beacon_bool_exp _build() {
    _$Gvote_beacon_bool_exp _$result;
    try {
      _$result = _$v ??
          new _$Gvote_beacon_bool_exp._(
              G_and: _G_and?.build(),
              G_not: _G_not?.build(),
              G_or: _G_or?.build(),
              amount: _amount?.build(),
              created_at: _created_at?.build(),
              object: _object?.build(),
              subject: _subject?.build(),
              updated_at: _updated_at?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'G_and';
        _G_and?.build();
        _$failedField = 'G_not';
        _G_not?.build();
        _$failedField = 'G_or';
        _G_or?.build();
        _$failedField = 'amount';
        _amount?.build();
        _$failedField = 'created_at';
        _created_at?.build();
        _$failedField = 'object';
        _object?.build();
        _$failedField = 'subject';
        _subject?.build();
        _$failedField = 'updated_at';
        _updated_at?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gvote_beacon_bool_exp', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_beacon_inc_input extends Gvote_beacon_inc_input {
  @override
  final int? amount;

  factory _$Gvote_beacon_inc_input(
          [void Function(Gvote_beacon_inc_inputBuilder)? updates]) =>
      (new Gvote_beacon_inc_inputBuilder()..update(updates))._build();

  _$Gvote_beacon_inc_input._({this.amount}) : super._();

  @override
  Gvote_beacon_inc_input rebuild(
          void Function(Gvote_beacon_inc_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_beacon_inc_inputBuilder toBuilder() =>
      new Gvote_beacon_inc_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_beacon_inc_input && amount == other.amount;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, amount.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_beacon_inc_input')
          ..add('amount', amount))
        .toString();
  }
}

class Gvote_beacon_inc_inputBuilder
    implements Builder<Gvote_beacon_inc_input, Gvote_beacon_inc_inputBuilder> {
  _$Gvote_beacon_inc_input? _$v;

  int? _amount;
  int? get amount => _$this._amount;
  set amount(int? amount) => _$this._amount = amount;

  Gvote_beacon_inc_inputBuilder();

  Gvote_beacon_inc_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _amount = $v.amount;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_beacon_inc_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_beacon_inc_input;
  }

  @override
  void update(void Function(Gvote_beacon_inc_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_beacon_inc_input build() => _build();

  _$Gvote_beacon_inc_input _build() {
    final _$result = _$v ?? new _$Gvote_beacon_inc_input._(amount: amount);
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_beacon_insert_input extends Gvote_beacon_insert_input {
  @override
  final int? amount;
  @override
  final DateTime? created_at;
  @override
  final String? object;
  @override
  final String? subject;
  @override
  final DateTime? updated_at;

  factory _$Gvote_beacon_insert_input(
          [void Function(Gvote_beacon_insert_inputBuilder)? updates]) =>
      (new Gvote_beacon_insert_inputBuilder()..update(updates))._build();

  _$Gvote_beacon_insert_input._(
      {this.amount,
      this.created_at,
      this.object,
      this.subject,
      this.updated_at})
      : super._();

  @override
  Gvote_beacon_insert_input rebuild(
          void Function(Gvote_beacon_insert_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_beacon_insert_inputBuilder toBuilder() =>
      new Gvote_beacon_insert_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_beacon_insert_input &&
        amount == other.amount &&
        created_at == other.created_at &&
        object == other.object &&
        subject == other.subject &&
        updated_at == other.updated_at;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, amount.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, object.hashCode);
    _$hash = $jc(_$hash, subject.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_beacon_insert_input')
          ..add('amount', amount)
          ..add('created_at', created_at)
          ..add('object', object)
          ..add('subject', subject)
          ..add('updated_at', updated_at))
        .toString();
  }
}

class Gvote_beacon_insert_inputBuilder
    implements
        Builder<Gvote_beacon_insert_input, Gvote_beacon_insert_inputBuilder> {
  _$Gvote_beacon_insert_input? _$v;

  int? _amount;
  int? get amount => _$this._amount;
  set amount(int? amount) => _$this._amount = amount;

  DateTime? _created_at;
  DateTime? get created_at => _$this._created_at;
  set created_at(DateTime? created_at) => _$this._created_at = created_at;

  String? _object;
  String? get object => _$this._object;
  set object(String? object) => _$this._object = object;

  String? _subject;
  String? get subject => _$this._subject;
  set subject(String? subject) => _$this._subject = subject;

  DateTime? _updated_at;
  DateTime? get updated_at => _$this._updated_at;
  set updated_at(DateTime? updated_at) => _$this._updated_at = updated_at;

  Gvote_beacon_insert_inputBuilder();

  Gvote_beacon_insert_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _amount = $v.amount;
      _created_at = $v.created_at;
      _object = $v.object;
      _subject = $v.subject;
      _updated_at = $v.updated_at;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_beacon_insert_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_beacon_insert_input;
  }

  @override
  void update(void Function(Gvote_beacon_insert_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_beacon_insert_input build() => _build();

  _$Gvote_beacon_insert_input _build() {
    final _$result = _$v ??
        new _$Gvote_beacon_insert_input._(
            amount: amount,
            created_at: created_at,
            object: object,
            subject: subject,
            updated_at: updated_at);
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_beacon_on_conflict extends Gvote_beacon_on_conflict {
  @override
  final Gvote_beacon_constraint constraint;
  @override
  final BuiltList<Gvote_beacon_update_column> update_columns;
  @override
  final Gvote_beacon_bool_exp? where;

  factory _$Gvote_beacon_on_conflict(
          [void Function(Gvote_beacon_on_conflictBuilder)? updates]) =>
      (new Gvote_beacon_on_conflictBuilder()..update(updates))._build();

  _$Gvote_beacon_on_conflict._(
      {required this.constraint, required this.update_columns, this.where})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        constraint, r'Gvote_beacon_on_conflict', 'constraint');
    BuiltValueNullFieldError.checkNotNull(
        update_columns, r'Gvote_beacon_on_conflict', 'update_columns');
  }

  @override
  Gvote_beacon_on_conflict rebuild(
          void Function(Gvote_beacon_on_conflictBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_beacon_on_conflictBuilder toBuilder() =>
      new Gvote_beacon_on_conflictBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_beacon_on_conflict &&
        constraint == other.constraint &&
        update_columns == other.update_columns &&
        where == other.where;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, constraint.hashCode);
    _$hash = $jc(_$hash, update_columns.hashCode);
    _$hash = $jc(_$hash, where.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_beacon_on_conflict')
          ..add('constraint', constraint)
          ..add('update_columns', update_columns)
          ..add('where', where))
        .toString();
  }
}

class Gvote_beacon_on_conflictBuilder
    implements
        Builder<Gvote_beacon_on_conflict, Gvote_beacon_on_conflictBuilder> {
  _$Gvote_beacon_on_conflict? _$v;

  Gvote_beacon_constraint? _constraint;
  Gvote_beacon_constraint? get constraint => _$this._constraint;
  set constraint(Gvote_beacon_constraint? constraint) =>
      _$this._constraint = constraint;

  ListBuilder<Gvote_beacon_update_column>? _update_columns;
  ListBuilder<Gvote_beacon_update_column> get update_columns =>
      _$this._update_columns ??= new ListBuilder<Gvote_beacon_update_column>();
  set update_columns(ListBuilder<Gvote_beacon_update_column>? update_columns) =>
      _$this._update_columns = update_columns;

  Gvote_beacon_bool_expBuilder? _where;
  Gvote_beacon_bool_expBuilder get where =>
      _$this._where ??= new Gvote_beacon_bool_expBuilder();
  set where(Gvote_beacon_bool_expBuilder? where) => _$this._where = where;

  Gvote_beacon_on_conflictBuilder();

  Gvote_beacon_on_conflictBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _constraint = $v.constraint;
      _update_columns = $v.update_columns.toBuilder();
      _where = $v.where?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_beacon_on_conflict other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_beacon_on_conflict;
  }

  @override
  void update(void Function(Gvote_beacon_on_conflictBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_beacon_on_conflict build() => _build();

  _$Gvote_beacon_on_conflict _build() {
    _$Gvote_beacon_on_conflict _$result;
    try {
      _$result = _$v ??
          new _$Gvote_beacon_on_conflict._(
              constraint: BuiltValueNullFieldError.checkNotNull(
                  constraint, r'Gvote_beacon_on_conflict', 'constraint'),
              update_columns: update_columns.build(),
              where: _where?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'update_columns';
        update_columns.build();
        _$failedField = 'where';
        _where?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gvote_beacon_on_conflict', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_beacon_order_by extends Gvote_beacon_order_by {
  @override
  final Gorder_by? amount;
  @override
  final Gorder_by? created_at;
  @override
  final Gorder_by? object;
  @override
  final Gorder_by? subject;
  @override
  final Gorder_by? updated_at;

  factory _$Gvote_beacon_order_by(
          [void Function(Gvote_beacon_order_byBuilder)? updates]) =>
      (new Gvote_beacon_order_byBuilder()..update(updates))._build();

  _$Gvote_beacon_order_by._(
      {this.amount,
      this.created_at,
      this.object,
      this.subject,
      this.updated_at})
      : super._();

  @override
  Gvote_beacon_order_by rebuild(
          void Function(Gvote_beacon_order_byBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_beacon_order_byBuilder toBuilder() =>
      new Gvote_beacon_order_byBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_beacon_order_by &&
        amount == other.amount &&
        created_at == other.created_at &&
        object == other.object &&
        subject == other.subject &&
        updated_at == other.updated_at;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, amount.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, object.hashCode);
    _$hash = $jc(_$hash, subject.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_beacon_order_by')
          ..add('amount', amount)
          ..add('created_at', created_at)
          ..add('object', object)
          ..add('subject', subject)
          ..add('updated_at', updated_at))
        .toString();
  }
}

class Gvote_beacon_order_byBuilder
    implements Builder<Gvote_beacon_order_by, Gvote_beacon_order_byBuilder> {
  _$Gvote_beacon_order_by? _$v;

  Gorder_by? _amount;
  Gorder_by? get amount => _$this._amount;
  set amount(Gorder_by? amount) => _$this._amount = amount;

  Gorder_by? _created_at;
  Gorder_by? get created_at => _$this._created_at;
  set created_at(Gorder_by? created_at) => _$this._created_at = created_at;

  Gorder_by? _object;
  Gorder_by? get object => _$this._object;
  set object(Gorder_by? object) => _$this._object = object;

  Gorder_by? _subject;
  Gorder_by? get subject => _$this._subject;
  set subject(Gorder_by? subject) => _$this._subject = subject;

  Gorder_by? _updated_at;
  Gorder_by? get updated_at => _$this._updated_at;
  set updated_at(Gorder_by? updated_at) => _$this._updated_at = updated_at;

  Gvote_beacon_order_byBuilder();

  Gvote_beacon_order_byBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _amount = $v.amount;
      _created_at = $v.created_at;
      _object = $v.object;
      _subject = $v.subject;
      _updated_at = $v.updated_at;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_beacon_order_by other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_beacon_order_by;
  }

  @override
  void update(void Function(Gvote_beacon_order_byBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_beacon_order_by build() => _build();

  _$Gvote_beacon_order_by _build() {
    final _$result = _$v ??
        new _$Gvote_beacon_order_by._(
            amount: amount,
            created_at: created_at,
            object: object,
            subject: subject,
            updated_at: updated_at);
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_beacon_pk_columns_input extends Gvote_beacon_pk_columns_input {
  @override
  final String object;
  @override
  final String subject;

  factory _$Gvote_beacon_pk_columns_input(
          [void Function(Gvote_beacon_pk_columns_inputBuilder)? updates]) =>
      (new Gvote_beacon_pk_columns_inputBuilder()..update(updates))._build();

  _$Gvote_beacon_pk_columns_input._(
      {required this.object, required this.subject})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        object, r'Gvote_beacon_pk_columns_input', 'object');
    BuiltValueNullFieldError.checkNotNull(
        subject, r'Gvote_beacon_pk_columns_input', 'subject');
  }

  @override
  Gvote_beacon_pk_columns_input rebuild(
          void Function(Gvote_beacon_pk_columns_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_beacon_pk_columns_inputBuilder toBuilder() =>
      new Gvote_beacon_pk_columns_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_beacon_pk_columns_input &&
        object == other.object &&
        subject == other.subject;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, object.hashCode);
    _$hash = $jc(_$hash, subject.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_beacon_pk_columns_input')
          ..add('object', object)
          ..add('subject', subject))
        .toString();
  }
}

class Gvote_beacon_pk_columns_inputBuilder
    implements
        Builder<Gvote_beacon_pk_columns_input,
            Gvote_beacon_pk_columns_inputBuilder> {
  _$Gvote_beacon_pk_columns_input? _$v;

  String? _object;
  String? get object => _$this._object;
  set object(String? object) => _$this._object = object;

  String? _subject;
  String? get subject => _$this._subject;
  set subject(String? subject) => _$this._subject = subject;

  Gvote_beacon_pk_columns_inputBuilder();

  Gvote_beacon_pk_columns_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _object = $v.object;
      _subject = $v.subject;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_beacon_pk_columns_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_beacon_pk_columns_input;
  }

  @override
  void update(void Function(Gvote_beacon_pk_columns_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_beacon_pk_columns_input build() => _build();

  _$Gvote_beacon_pk_columns_input _build() {
    final _$result = _$v ??
        new _$Gvote_beacon_pk_columns_input._(
            object: BuiltValueNullFieldError.checkNotNull(
                object, r'Gvote_beacon_pk_columns_input', 'object'),
            subject: BuiltValueNullFieldError.checkNotNull(
                subject, r'Gvote_beacon_pk_columns_input', 'subject'));
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_beacon_set_input extends Gvote_beacon_set_input {
  @override
  final int? amount;
  @override
  final DateTime? created_at;
  @override
  final String? object;
  @override
  final String? subject;
  @override
  final DateTime? updated_at;

  factory _$Gvote_beacon_set_input(
          [void Function(Gvote_beacon_set_inputBuilder)? updates]) =>
      (new Gvote_beacon_set_inputBuilder()..update(updates))._build();

  _$Gvote_beacon_set_input._(
      {this.amount,
      this.created_at,
      this.object,
      this.subject,
      this.updated_at})
      : super._();

  @override
  Gvote_beacon_set_input rebuild(
          void Function(Gvote_beacon_set_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_beacon_set_inputBuilder toBuilder() =>
      new Gvote_beacon_set_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_beacon_set_input &&
        amount == other.amount &&
        created_at == other.created_at &&
        object == other.object &&
        subject == other.subject &&
        updated_at == other.updated_at;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, amount.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, object.hashCode);
    _$hash = $jc(_$hash, subject.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_beacon_set_input')
          ..add('amount', amount)
          ..add('created_at', created_at)
          ..add('object', object)
          ..add('subject', subject)
          ..add('updated_at', updated_at))
        .toString();
  }
}

class Gvote_beacon_set_inputBuilder
    implements Builder<Gvote_beacon_set_input, Gvote_beacon_set_inputBuilder> {
  _$Gvote_beacon_set_input? _$v;

  int? _amount;
  int? get amount => _$this._amount;
  set amount(int? amount) => _$this._amount = amount;

  DateTime? _created_at;
  DateTime? get created_at => _$this._created_at;
  set created_at(DateTime? created_at) => _$this._created_at = created_at;

  String? _object;
  String? get object => _$this._object;
  set object(String? object) => _$this._object = object;

  String? _subject;
  String? get subject => _$this._subject;
  set subject(String? subject) => _$this._subject = subject;

  DateTime? _updated_at;
  DateTime? get updated_at => _$this._updated_at;
  set updated_at(DateTime? updated_at) => _$this._updated_at = updated_at;

  Gvote_beacon_set_inputBuilder();

  Gvote_beacon_set_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _amount = $v.amount;
      _created_at = $v.created_at;
      _object = $v.object;
      _subject = $v.subject;
      _updated_at = $v.updated_at;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_beacon_set_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_beacon_set_input;
  }

  @override
  void update(void Function(Gvote_beacon_set_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_beacon_set_input build() => _build();

  _$Gvote_beacon_set_input _build() {
    final _$result = _$v ??
        new _$Gvote_beacon_set_input._(
            amount: amount,
            created_at: created_at,
            object: object,
            subject: subject,
            updated_at: updated_at);
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_beacon_stream_cursor_input
    extends Gvote_beacon_stream_cursor_input {
  @override
  final Gvote_beacon_stream_cursor_value_input initial_value;
  @override
  final Gcursor_ordering? ordering;

  factory _$Gvote_beacon_stream_cursor_input(
          [void Function(Gvote_beacon_stream_cursor_inputBuilder)? updates]) =>
      (new Gvote_beacon_stream_cursor_inputBuilder()..update(updates))._build();

  _$Gvote_beacon_stream_cursor_input._(
      {required this.initial_value, this.ordering})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        initial_value, r'Gvote_beacon_stream_cursor_input', 'initial_value');
  }

  @override
  Gvote_beacon_stream_cursor_input rebuild(
          void Function(Gvote_beacon_stream_cursor_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_beacon_stream_cursor_inputBuilder toBuilder() =>
      new Gvote_beacon_stream_cursor_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_beacon_stream_cursor_input &&
        initial_value == other.initial_value &&
        ordering == other.ordering;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, initial_value.hashCode);
    _$hash = $jc(_$hash, ordering.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_beacon_stream_cursor_input')
          ..add('initial_value', initial_value)
          ..add('ordering', ordering))
        .toString();
  }
}

class Gvote_beacon_stream_cursor_inputBuilder
    implements
        Builder<Gvote_beacon_stream_cursor_input,
            Gvote_beacon_stream_cursor_inputBuilder> {
  _$Gvote_beacon_stream_cursor_input? _$v;

  Gvote_beacon_stream_cursor_value_inputBuilder? _initial_value;
  Gvote_beacon_stream_cursor_value_inputBuilder get initial_value =>
      _$this._initial_value ??=
          new Gvote_beacon_stream_cursor_value_inputBuilder();
  set initial_value(
          Gvote_beacon_stream_cursor_value_inputBuilder? initial_value) =>
      _$this._initial_value = initial_value;

  Gcursor_ordering? _ordering;
  Gcursor_ordering? get ordering => _$this._ordering;
  set ordering(Gcursor_ordering? ordering) => _$this._ordering = ordering;

  Gvote_beacon_stream_cursor_inputBuilder();

  Gvote_beacon_stream_cursor_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _initial_value = $v.initial_value.toBuilder();
      _ordering = $v.ordering;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_beacon_stream_cursor_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_beacon_stream_cursor_input;
  }

  @override
  void update(void Function(Gvote_beacon_stream_cursor_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_beacon_stream_cursor_input build() => _build();

  _$Gvote_beacon_stream_cursor_input _build() {
    _$Gvote_beacon_stream_cursor_input _$result;
    try {
      _$result = _$v ??
          new _$Gvote_beacon_stream_cursor_input._(
              initial_value: initial_value.build(), ordering: ordering);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'initial_value';
        initial_value.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gvote_beacon_stream_cursor_input', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_beacon_stream_cursor_value_input
    extends Gvote_beacon_stream_cursor_value_input {
  @override
  final int? amount;
  @override
  final DateTime? created_at;
  @override
  final String? object;
  @override
  final String? subject;
  @override
  final DateTime? updated_at;

  factory _$Gvote_beacon_stream_cursor_value_input(
          [void Function(Gvote_beacon_stream_cursor_value_inputBuilder)?
              updates]) =>
      (new Gvote_beacon_stream_cursor_value_inputBuilder()..update(updates))
          ._build();

  _$Gvote_beacon_stream_cursor_value_input._(
      {this.amount,
      this.created_at,
      this.object,
      this.subject,
      this.updated_at})
      : super._();

  @override
  Gvote_beacon_stream_cursor_value_input rebuild(
          void Function(Gvote_beacon_stream_cursor_value_inputBuilder)
              updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_beacon_stream_cursor_value_inputBuilder toBuilder() =>
      new Gvote_beacon_stream_cursor_value_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_beacon_stream_cursor_value_input &&
        amount == other.amount &&
        created_at == other.created_at &&
        object == other.object &&
        subject == other.subject &&
        updated_at == other.updated_at;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, amount.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, object.hashCode);
    _$hash = $jc(_$hash, subject.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(
            r'Gvote_beacon_stream_cursor_value_input')
          ..add('amount', amount)
          ..add('created_at', created_at)
          ..add('object', object)
          ..add('subject', subject)
          ..add('updated_at', updated_at))
        .toString();
  }
}

class Gvote_beacon_stream_cursor_value_inputBuilder
    implements
        Builder<Gvote_beacon_stream_cursor_value_input,
            Gvote_beacon_stream_cursor_value_inputBuilder> {
  _$Gvote_beacon_stream_cursor_value_input? _$v;

  int? _amount;
  int? get amount => _$this._amount;
  set amount(int? amount) => _$this._amount = amount;

  DateTime? _created_at;
  DateTime? get created_at => _$this._created_at;
  set created_at(DateTime? created_at) => _$this._created_at = created_at;

  String? _object;
  String? get object => _$this._object;
  set object(String? object) => _$this._object = object;

  String? _subject;
  String? get subject => _$this._subject;
  set subject(String? subject) => _$this._subject = subject;

  DateTime? _updated_at;
  DateTime? get updated_at => _$this._updated_at;
  set updated_at(DateTime? updated_at) => _$this._updated_at = updated_at;

  Gvote_beacon_stream_cursor_value_inputBuilder();

  Gvote_beacon_stream_cursor_value_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _amount = $v.amount;
      _created_at = $v.created_at;
      _object = $v.object;
      _subject = $v.subject;
      _updated_at = $v.updated_at;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_beacon_stream_cursor_value_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_beacon_stream_cursor_value_input;
  }

  @override
  void update(
      void Function(Gvote_beacon_stream_cursor_value_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_beacon_stream_cursor_value_input build() => _build();

  _$Gvote_beacon_stream_cursor_value_input _build() {
    final _$result = _$v ??
        new _$Gvote_beacon_stream_cursor_value_input._(
            amount: amount,
            created_at: created_at,
            object: object,
            subject: subject,
            updated_at: updated_at);
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_beacon_updates extends Gvote_beacon_updates {
  @override
  final Gvote_beacon_inc_input? G_inc;
  @override
  final Gvote_beacon_set_input? G_set;
  @override
  final Gvote_beacon_bool_exp where;

  factory _$Gvote_beacon_updates(
          [void Function(Gvote_beacon_updatesBuilder)? updates]) =>
      (new Gvote_beacon_updatesBuilder()..update(updates))._build();

  _$Gvote_beacon_updates._({this.G_inc, this.G_set, required this.where})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        where, r'Gvote_beacon_updates', 'where');
  }

  @override
  Gvote_beacon_updates rebuild(
          void Function(Gvote_beacon_updatesBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_beacon_updatesBuilder toBuilder() =>
      new Gvote_beacon_updatesBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_beacon_updates &&
        G_inc == other.G_inc &&
        G_set == other.G_set &&
        where == other.where;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, G_inc.hashCode);
    _$hash = $jc(_$hash, G_set.hashCode);
    _$hash = $jc(_$hash, where.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_beacon_updates')
          ..add('G_inc', G_inc)
          ..add('G_set', G_set)
          ..add('where', where))
        .toString();
  }
}

class Gvote_beacon_updatesBuilder
    implements Builder<Gvote_beacon_updates, Gvote_beacon_updatesBuilder> {
  _$Gvote_beacon_updates? _$v;

  Gvote_beacon_inc_inputBuilder? _G_inc;
  Gvote_beacon_inc_inputBuilder get G_inc =>
      _$this._G_inc ??= new Gvote_beacon_inc_inputBuilder();
  set G_inc(Gvote_beacon_inc_inputBuilder? G_inc) => _$this._G_inc = G_inc;

  Gvote_beacon_set_inputBuilder? _G_set;
  Gvote_beacon_set_inputBuilder get G_set =>
      _$this._G_set ??= new Gvote_beacon_set_inputBuilder();
  set G_set(Gvote_beacon_set_inputBuilder? G_set) => _$this._G_set = G_set;

  Gvote_beacon_bool_expBuilder? _where;
  Gvote_beacon_bool_expBuilder get where =>
      _$this._where ??= new Gvote_beacon_bool_expBuilder();
  set where(Gvote_beacon_bool_expBuilder? where) => _$this._where = where;

  Gvote_beacon_updatesBuilder();

  Gvote_beacon_updatesBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _G_inc = $v.G_inc?.toBuilder();
      _G_set = $v.G_set?.toBuilder();
      _where = $v.where.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_beacon_updates other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_beacon_updates;
  }

  @override
  void update(void Function(Gvote_beacon_updatesBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_beacon_updates build() => _build();

  _$Gvote_beacon_updates _build() {
    _$Gvote_beacon_updates _$result;
    try {
      _$result = _$v ??
          new _$Gvote_beacon_updates._(
              G_inc: _G_inc?.build(),
              G_set: _G_set?.build(),
              where: where.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'G_inc';
        _G_inc?.build();
        _$failedField = 'G_set';
        _G_set?.build();
        _$failedField = 'where';
        where.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gvote_beacon_updates', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_comment_bool_exp extends Gvote_comment_bool_exp {
  @override
  final BuiltList<Gvote_comment_bool_exp>? G_and;
  @override
  final Gvote_comment_bool_exp? G_not;
  @override
  final BuiltList<Gvote_comment_bool_exp>? G_or;
  @override
  final GInt_comparison_exp? amount;
  @override
  final Gtimestamptz_comparison_exp? created_at;
  @override
  final GString_comparison_exp? object;
  @override
  final GString_comparison_exp? subject;
  @override
  final Gtimestamptz_comparison_exp? updated_at;

  factory _$Gvote_comment_bool_exp(
          [void Function(Gvote_comment_bool_expBuilder)? updates]) =>
      (new Gvote_comment_bool_expBuilder()..update(updates))._build();

  _$Gvote_comment_bool_exp._(
      {this.G_and,
      this.G_not,
      this.G_or,
      this.amount,
      this.created_at,
      this.object,
      this.subject,
      this.updated_at})
      : super._();

  @override
  Gvote_comment_bool_exp rebuild(
          void Function(Gvote_comment_bool_expBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_comment_bool_expBuilder toBuilder() =>
      new Gvote_comment_bool_expBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_comment_bool_exp &&
        G_and == other.G_and &&
        G_not == other.G_not &&
        G_or == other.G_or &&
        amount == other.amount &&
        created_at == other.created_at &&
        object == other.object &&
        subject == other.subject &&
        updated_at == other.updated_at;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, G_and.hashCode);
    _$hash = $jc(_$hash, G_not.hashCode);
    _$hash = $jc(_$hash, G_or.hashCode);
    _$hash = $jc(_$hash, amount.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, object.hashCode);
    _$hash = $jc(_$hash, subject.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_comment_bool_exp')
          ..add('G_and', G_and)
          ..add('G_not', G_not)
          ..add('G_or', G_or)
          ..add('amount', amount)
          ..add('created_at', created_at)
          ..add('object', object)
          ..add('subject', subject)
          ..add('updated_at', updated_at))
        .toString();
  }
}

class Gvote_comment_bool_expBuilder
    implements Builder<Gvote_comment_bool_exp, Gvote_comment_bool_expBuilder> {
  _$Gvote_comment_bool_exp? _$v;

  ListBuilder<Gvote_comment_bool_exp>? _G_and;
  ListBuilder<Gvote_comment_bool_exp> get G_and =>
      _$this._G_and ??= new ListBuilder<Gvote_comment_bool_exp>();
  set G_and(ListBuilder<Gvote_comment_bool_exp>? G_and) =>
      _$this._G_and = G_and;

  Gvote_comment_bool_expBuilder? _G_not;
  Gvote_comment_bool_expBuilder get G_not =>
      _$this._G_not ??= new Gvote_comment_bool_expBuilder();
  set G_not(Gvote_comment_bool_expBuilder? G_not) => _$this._G_not = G_not;

  ListBuilder<Gvote_comment_bool_exp>? _G_or;
  ListBuilder<Gvote_comment_bool_exp> get G_or =>
      _$this._G_or ??= new ListBuilder<Gvote_comment_bool_exp>();
  set G_or(ListBuilder<Gvote_comment_bool_exp>? G_or) => _$this._G_or = G_or;

  GInt_comparison_expBuilder? _amount;
  GInt_comparison_expBuilder get amount =>
      _$this._amount ??= new GInt_comparison_expBuilder();
  set amount(GInt_comparison_expBuilder? amount) => _$this._amount = amount;

  Gtimestamptz_comparison_expBuilder? _created_at;
  Gtimestamptz_comparison_expBuilder get created_at =>
      _$this._created_at ??= new Gtimestamptz_comparison_expBuilder();
  set created_at(Gtimestamptz_comparison_expBuilder? created_at) =>
      _$this._created_at = created_at;

  GString_comparison_expBuilder? _object;
  GString_comparison_expBuilder get object =>
      _$this._object ??= new GString_comparison_expBuilder();
  set object(GString_comparison_expBuilder? object) => _$this._object = object;

  GString_comparison_expBuilder? _subject;
  GString_comparison_expBuilder get subject =>
      _$this._subject ??= new GString_comparison_expBuilder();
  set subject(GString_comparison_expBuilder? subject) =>
      _$this._subject = subject;

  Gtimestamptz_comparison_expBuilder? _updated_at;
  Gtimestamptz_comparison_expBuilder get updated_at =>
      _$this._updated_at ??= new Gtimestamptz_comparison_expBuilder();
  set updated_at(Gtimestamptz_comparison_expBuilder? updated_at) =>
      _$this._updated_at = updated_at;

  Gvote_comment_bool_expBuilder();

  Gvote_comment_bool_expBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _G_and = $v.G_and?.toBuilder();
      _G_not = $v.G_not?.toBuilder();
      _G_or = $v.G_or?.toBuilder();
      _amount = $v.amount?.toBuilder();
      _created_at = $v.created_at?.toBuilder();
      _object = $v.object?.toBuilder();
      _subject = $v.subject?.toBuilder();
      _updated_at = $v.updated_at?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_comment_bool_exp other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_comment_bool_exp;
  }

  @override
  void update(void Function(Gvote_comment_bool_expBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_comment_bool_exp build() => _build();

  _$Gvote_comment_bool_exp _build() {
    _$Gvote_comment_bool_exp _$result;
    try {
      _$result = _$v ??
          new _$Gvote_comment_bool_exp._(
              G_and: _G_and?.build(),
              G_not: _G_not?.build(),
              G_or: _G_or?.build(),
              amount: _amount?.build(),
              created_at: _created_at?.build(),
              object: _object?.build(),
              subject: _subject?.build(),
              updated_at: _updated_at?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'G_and';
        _G_and?.build();
        _$failedField = 'G_not';
        _G_not?.build();
        _$failedField = 'G_or';
        _G_or?.build();
        _$failedField = 'amount';
        _amount?.build();
        _$failedField = 'created_at';
        _created_at?.build();
        _$failedField = 'object';
        _object?.build();
        _$failedField = 'subject';
        _subject?.build();
        _$failedField = 'updated_at';
        _updated_at?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gvote_comment_bool_exp', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_comment_inc_input extends Gvote_comment_inc_input {
  @override
  final int? amount;

  factory _$Gvote_comment_inc_input(
          [void Function(Gvote_comment_inc_inputBuilder)? updates]) =>
      (new Gvote_comment_inc_inputBuilder()..update(updates))._build();

  _$Gvote_comment_inc_input._({this.amount}) : super._();

  @override
  Gvote_comment_inc_input rebuild(
          void Function(Gvote_comment_inc_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_comment_inc_inputBuilder toBuilder() =>
      new Gvote_comment_inc_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_comment_inc_input && amount == other.amount;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, amount.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_comment_inc_input')
          ..add('amount', amount))
        .toString();
  }
}

class Gvote_comment_inc_inputBuilder
    implements
        Builder<Gvote_comment_inc_input, Gvote_comment_inc_inputBuilder> {
  _$Gvote_comment_inc_input? _$v;

  int? _amount;
  int? get amount => _$this._amount;
  set amount(int? amount) => _$this._amount = amount;

  Gvote_comment_inc_inputBuilder();

  Gvote_comment_inc_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _amount = $v.amount;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_comment_inc_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_comment_inc_input;
  }

  @override
  void update(void Function(Gvote_comment_inc_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_comment_inc_input build() => _build();

  _$Gvote_comment_inc_input _build() {
    final _$result = _$v ?? new _$Gvote_comment_inc_input._(amount: amount);
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_comment_insert_input extends Gvote_comment_insert_input {
  @override
  final int? amount;
  @override
  final DateTime? created_at;
  @override
  final String? object;
  @override
  final String? subject;
  @override
  final DateTime? updated_at;

  factory _$Gvote_comment_insert_input(
          [void Function(Gvote_comment_insert_inputBuilder)? updates]) =>
      (new Gvote_comment_insert_inputBuilder()..update(updates))._build();

  _$Gvote_comment_insert_input._(
      {this.amount,
      this.created_at,
      this.object,
      this.subject,
      this.updated_at})
      : super._();

  @override
  Gvote_comment_insert_input rebuild(
          void Function(Gvote_comment_insert_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_comment_insert_inputBuilder toBuilder() =>
      new Gvote_comment_insert_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_comment_insert_input &&
        amount == other.amount &&
        created_at == other.created_at &&
        object == other.object &&
        subject == other.subject &&
        updated_at == other.updated_at;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, amount.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, object.hashCode);
    _$hash = $jc(_$hash, subject.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_comment_insert_input')
          ..add('amount', amount)
          ..add('created_at', created_at)
          ..add('object', object)
          ..add('subject', subject)
          ..add('updated_at', updated_at))
        .toString();
  }
}

class Gvote_comment_insert_inputBuilder
    implements
        Builder<Gvote_comment_insert_input, Gvote_comment_insert_inputBuilder> {
  _$Gvote_comment_insert_input? _$v;

  int? _amount;
  int? get amount => _$this._amount;
  set amount(int? amount) => _$this._amount = amount;

  DateTime? _created_at;
  DateTime? get created_at => _$this._created_at;
  set created_at(DateTime? created_at) => _$this._created_at = created_at;

  String? _object;
  String? get object => _$this._object;
  set object(String? object) => _$this._object = object;

  String? _subject;
  String? get subject => _$this._subject;
  set subject(String? subject) => _$this._subject = subject;

  DateTime? _updated_at;
  DateTime? get updated_at => _$this._updated_at;
  set updated_at(DateTime? updated_at) => _$this._updated_at = updated_at;

  Gvote_comment_insert_inputBuilder();

  Gvote_comment_insert_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _amount = $v.amount;
      _created_at = $v.created_at;
      _object = $v.object;
      _subject = $v.subject;
      _updated_at = $v.updated_at;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_comment_insert_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_comment_insert_input;
  }

  @override
  void update(void Function(Gvote_comment_insert_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_comment_insert_input build() => _build();

  _$Gvote_comment_insert_input _build() {
    final _$result = _$v ??
        new _$Gvote_comment_insert_input._(
            amount: amount,
            created_at: created_at,
            object: object,
            subject: subject,
            updated_at: updated_at);
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_comment_on_conflict extends Gvote_comment_on_conflict {
  @override
  final Gvote_comment_constraint constraint;
  @override
  final BuiltList<Gvote_comment_update_column> update_columns;
  @override
  final Gvote_comment_bool_exp? where;

  factory _$Gvote_comment_on_conflict(
          [void Function(Gvote_comment_on_conflictBuilder)? updates]) =>
      (new Gvote_comment_on_conflictBuilder()..update(updates))._build();

  _$Gvote_comment_on_conflict._(
      {required this.constraint, required this.update_columns, this.where})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        constraint, r'Gvote_comment_on_conflict', 'constraint');
    BuiltValueNullFieldError.checkNotNull(
        update_columns, r'Gvote_comment_on_conflict', 'update_columns');
  }

  @override
  Gvote_comment_on_conflict rebuild(
          void Function(Gvote_comment_on_conflictBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_comment_on_conflictBuilder toBuilder() =>
      new Gvote_comment_on_conflictBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_comment_on_conflict &&
        constraint == other.constraint &&
        update_columns == other.update_columns &&
        where == other.where;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, constraint.hashCode);
    _$hash = $jc(_$hash, update_columns.hashCode);
    _$hash = $jc(_$hash, where.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_comment_on_conflict')
          ..add('constraint', constraint)
          ..add('update_columns', update_columns)
          ..add('where', where))
        .toString();
  }
}

class Gvote_comment_on_conflictBuilder
    implements
        Builder<Gvote_comment_on_conflict, Gvote_comment_on_conflictBuilder> {
  _$Gvote_comment_on_conflict? _$v;

  Gvote_comment_constraint? _constraint;
  Gvote_comment_constraint? get constraint => _$this._constraint;
  set constraint(Gvote_comment_constraint? constraint) =>
      _$this._constraint = constraint;

  ListBuilder<Gvote_comment_update_column>? _update_columns;
  ListBuilder<Gvote_comment_update_column> get update_columns =>
      _$this._update_columns ??= new ListBuilder<Gvote_comment_update_column>();
  set update_columns(
          ListBuilder<Gvote_comment_update_column>? update_columns) =>
      _$this._update_columns = update_columns;

  Gvote_comment_bool_expBuilder? _where;
  Gvote_comment_bool_expBuilder get where =>
      _$this._where ??= new Gvote_comment_bool_expBuilder();
  set where(Gvote_comment_bool_expBuilder? where) => _$this._where = where;

  Gvote_comment_on_conflictBuilder();

  Gvote_comment_on_conflictBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _constraint = $v.constraint;
      _update_columns = $v.update_columns.toBuilder();
      _where = $v.where?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_comment_on_conflict other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_comment_on_conflict;
  }

  @override
  void update(void Function(Gvote_comment_on_conflictBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_comment_on_conflict build() => _build();

  _$Gvote_comment_on_conflict _build() {
    _$Gvote_comment_on_conflict _$result;
    try {
      _$result = _$v ??
          new _$Gvote_comment_on_conflict._(
              constraint: BuiltValueNullFieldError.checkNotNull(
                  constraint, r'Gvote_comment_on_conflict', 'constraint'),
              update_columns: update_columns.build(),
              where: _where?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'update_columns';
        update_columns.build();
        _$failedField = 'where';
        _where?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gvote_comment_on_conflict', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_comment_order_by extends Gvote_comment_order_by {
  @override
  final Gorder_by? amount;
  @override
  final Gorder_by? created_at;
  @override
  final Gorder_by? object;
  @override
  final Gorder_by? subject;
  @override
  final Gorder_by? updated_at;

  factory _$Gvote_comment_order_by(
          [void Function(Gvote_comment_order_byBuilder)? updates]) =>
      (new Gvote_comment_order_byBuilder()..update(updates))._build();

  _$Gvote_comment_order_by._(
      {this.amount,
      this.created_at,
      this.object,
      this.subject,
      this.updated_at})
      : super._();

  @override
  Gvote_comment_order_by rebuild(
          void Function(Gvote_comment_order_byBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_comment_order_byBuilder toBuilder() =>
      new Gvote_comment_order_byBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_comment_order_by &&
        amount == other.amount &&
        created_at == other.created_at &&
        object == other.object &&
        subject == other.subject &&
        updated_at == other.updated_at;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, amount.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, object.hashCode);
    _$hash = $jc(_$hash, subject.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_comment_order_by')
          ..add('amount', amount)
          ..add('created_at', created_at)
          ..add('object', object)
          ..add('subject', subject)
          ..add('updated_at', updated_at))
        .toString();
  }
}

class Gvote_comment_order_byBuilder
    implements Builder<Gvote_comment_order_by, Gvote_comment_order_byBuilder> {
  _$Gvote_comment_order_by? _$v;

  Gorder_by? _amount;
  Gorder_by? get amount => _$this._amount;
  set amount(Gorder_by? amount) => _$this._amount = amount;

  Gorder_by? _created_at;
  Gorder_by? get created_at => _$this._created_at;
  set created_at(Gorder_by? created_at) => _$this._created_at = created_at;

  Gorder_by? _object;
  Gorder_by? get object => _$this._object;
  set object(Gorder_by? object) => _$this._object = object;

  Gorder_by? _subject;
  Gorder_by? get subject => _$this._subject;
  set subject(Gorder_by? subject) => _$this._subject = subject;

  Gorder_by? _updated_at;
  Gorder_by? get updated_at => _$this._updated_at;
  set updated_at(Gorder_by? updated_at) => _$this._updated_at = updated_at;

  Gvote_comment_order_byBuilder();

  Gvote_comment_order_byBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _amount = $v.amount;
      _created_at = $v.created_at;
      _object = $v.object;
      _subject = $v.subject;
      _updated_at = $v.updated_at;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_comment_order_by other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_comment_order_by;
  }

  @override
  void update(void Function(Gvote_comment_order_byBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_comment_order_by build() => _build();

  _$Gvote_comment_order_by _build() {
    final _$result = _$v ??
        new _$Gvote_comment_order_by._(
            amount: amount,
            created_at: created_at,
            object: object,
            subject: subject,
            updated_at: updated_at);
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_comment_pk_columns_input extends Gvote_comment_pk_columns_input {
  @override
  final String object;
  @override
  final String subject;

  factory _$Gvote_comment_pk_columns_input(
          [void Function(Gvote_comment_pk_columns_inputBuilder)? updates]) =>
      (new Gvote_comment_pk_columns_inputBuilder()..update(updates))._build();

  _$Gvote_comment_pk_columns_input._(
      {required this.object, required this.subject})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        object, r'Gvote_comment_pk_columns_input', 'object');
    BuiltValueNullFieldError.checkNotNull(
        subject, r'Gvote_comment_pk_columns_input', 'subject');
  }

  @override
  Gvote_comment_pk_columns_input rebuild(
          void Function(Gvote_comment_pk_columns_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_comment_pk_columns_inputBuilder toBuilder() =>
      new Gvote_comment_pk_columns_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_comment_pk_columns_input &&
        object == other.object &&
        subject == other.subject;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, object.hashCode);
    _$hash = $jc(_$hash, subject.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_comment_pk_columns_input')
          ..add('object', object)
          ..add('subject', subject))
        .toString();
  }
}

class Gvote_comment_pk_columns_inputBuilder
    implements
        Builder<Gvote_comment_pk_columns_input,
            Gvote_comment_pk_columns_inputBuilder> {
  _$Gvote_comment_pk_columns_input? _$v;

  String? _object;
  String? get object => _$this._object;
  set object(String? object) => _$this._object = object;

  String? _subject;
  String? get subject => _$this._subject;
  set subject(String? subject) => _$this._subject = subject;

  Gvote_comment_pk_columns_inputBuilder();

  Gvote_comment_pk_columns_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _object = $v.object;
      _subject = $v.subject;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_comment_pk_columns_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_comment_pk_columns_input;
  }

  @override
  void update(void Function(Gvote_comment_pk_columns_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_comment_pk_columns_input build() => _build();

  _$Gvote_comment_pk_columns_input _build() {
    final _$result = _$v ??
        new _$Gvote_comment_pk_columns_input._(
            object: BuiltValueNullFieldError.checkNotNull(
                object, r'Gvote_comment_pk_columns_input', 'object'),
            subject: BuiltValueNullFieldError.checkNotNull(
                subject, r'Gvote_comment_pk_columns_input', 'subject'));
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_comment_set_input extends Gvote_comment_set_input {
  @override
  final int? amount;
  @override
  final DateTime? created_at;
  @override
  final String? object;
  @override
  final String? subject;
  @override
  final DateTime? updated_at;

  factory _$Gvote_comment_set_input(
          [void Function(Gvote_comment_set_inputBuilder)? updates]) =>
      (new Gvote_comment_set_inputBuilder()..update(updates))._build();

  _$Gvote_comment_set_input._(
      {this.amount,
      this.created_at,
      this.object,
      this.subject,
      this.updated_at})
      : super._();

  @override
  Gvote_comment_set_input rebuild(
          void Function(Gvote_comment_set_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_comment_set_inputBuilder toBuilder() =>
      new Gvote_comment_set_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_comment_set_input &&
        amount == other.amount &&
        created_at == other.created_at &&
        object == other.object &&
        subject == other.subject &&
        updated_at == other.updated_at;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, amount.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, object.hashCode);
    _$hash = $jc(_$hash, subject.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_comment_set_input')
          ..add('amount', amount)
          ..add('created_at', created_at)
          ..add('object', object)
          ..add('subject', subject)
          ..add('updated_at', updated_at))
        .toString();
  }
}

class Gvote_comment_set_inputBuilder
    implements
        Builder<Gvote_comment_set_input, Gvote_comment_set_inputBuilder> {
  _$Gvote_comment_set_input? _$v;

  int? _amount;
  int? get amount => _$this._amount;
  set amount(int? amount) => _$this._amount = amount;

  DateTime? _created_at;
  DateTime? get created_at => _$this._created_at;
  set created_at(DateTime? created_at) => _$this._created_at = created_at;

  String? _object;
  String? get object => _$this._object;
  set object(String? object) => _$this._object = object;

  String? _subject;
  String? get subject => _$this._subject;
  set subject(String? subject) => _$this._subject = subject;

  DateTime? _updated_at;
  DateTime? get updated_at => _$this._updated_at;
  set updated_at(DateTime? updated_at) => _$this._updated_at = updated_at;

  Gvote_comment_set_inputBuilder();

  Gvote_comment_set_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _amount = $v.amount;
      _created_at = $v.created_at;
      _object = $v.object;
      _subject = $v.subject;
      _updated_at = $v.updated_at;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_comment_set_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_comment_set_input;
  }

  @override
  void update(void Function(Gvote_comment_set_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_comment_set_input build() => _build();

  _$Gvote_comment_set_input _build() {
    final _$result = _$v ??
        new _$Gvote_comment_set_input._(
            amount: amount,
            created_at: created_at,
            object: object,
            subject: subject,
            updated_at: updated_at);
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_comment_stream_cursor_input
    extends Gvote_comment_stream_cursor_input {
  @override
  final Gvote_comment_stream_cursor_value_input initial_value;
  @override
  final Gcursor_ordering? ordering;

  factory _$Gvote_comment_stream_cursor_input(
          [void Function(Gvote_comment_stream_cursor_inputBuilder)? updates]) =>
      (new Gvote_comment_stream_cursor_inputBuilder()..update(updates))
          ._build();

  _$Gvote_comment_stream_cursor_input._(
      {required this.initial_value, this.ordering})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        initial_value, r'Gvote_comment_stream_cursor_input', 'initial_value');
  }

  @override
  Gvote_comment_stream_cursor_input rebuild(
          void Function(Gvote_comment_stream_cursor_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_comment_stream_cursor_inputBuilder toBuilder() =>
      new Gvote_comment_stream_cursor_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_comment_stream_cursor_input &&
        initial_value == other.initial_value &&
        ordering == other.ordering;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, initial_value.hashCode);
    _$hash = $jc(_$hash, ordering.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_comment_stream_cursor_input')
          ..add('initial_value', initial_value)
          ..add('ordering', ordering))
        .toString();
  }
}

class Gvote_comment_stream_cursor_inputBuilder
    implements
        Builder<Gvote_comment_stream_cursor_input,
            Gvote_comment_stream_cursor_inputBuilder> {
  _$Gvote_comment_stream_cursor_input? _$v;

  Gvote_comment_stream_cursor_value_inputBuilder? _initial_value;
  Gvote_comment_stream_cursor_value_inputBuilder get initial_value =>
      _$this._initial_value ??=
          new Gvote_comment_stream_cursor_value_inputBuilder();
  set initial_value(
          Gvote_comment_stream_cursor_value_inputBuilder? initial_value) =>
      _$this._initial_value = initial_value;

  Gcursor_ordering? _ordering;
  Gcursor_ordering? get ordering => _$this._ordering;
  set ordering(Gcursor_ordering? ordering) => _$this._ordering = ordering;

  Gvote_comment_stream_cursor_inputBuilder();

  Gvote_comment_stream_cursor_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _initial_value = $v.initial_value.toBuilder();
      _ordering = $v.ordering;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_comment_stream_cursor_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_comment_stream_cursor_input;
  }

  @override
  void update(
      void Function(Gvote_comment_stream_cursor_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_comment_stream_cursor_input build() => _build();

  _$Gvote_comment_stream_cursor_input _build() {
    _$Gvote_comment_stream_cursor_input _$result;
    try {
      _$result = _$v ??
          new _$Gvote_comment_stream_cursor_input._(
              initial_value: initial_value.build(), ordering: ordering);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'initial_value';
        initial_value.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gvote_comment_stream_cursor_input', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_comment_stream_cursor_value_input
    extends Gvote_comment_stream_cursor_value_input {
  @override
  final int? amount;
  @override
  final DateTime? created_at;
  @override
  final String? object;
  @override
  final String? subject;
  @override
  final DateTime? updated_at;

  factory _$Gvote_comment_stream_cursor_value_input(
          [void Function(Gvote_comment_stream_cursor_value_inputBuilder)?
              updates]) =>
      (new Gvote_comment_stream_cursor_value_inputBuilder()..update(updates))
          ._build();

  _$Gvote_comment_stream_cursor_value_input._(
      {this.amount,
      this.created_at,
      this.object,
      this.subject,
      this.updated_at})
      : super._();

  @override
  Gvote_comment_stream_cursor_value_input rebuild(
          void Function(Gvote_comment_stream_cursor_value_inputBuilder)
              updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_comment_stream_cursor_value_inputBuilder toBuilder() =>
      new Gvote_comment_stream_cursor_value_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_comment_stream_cursor_value_input &&
        amount == other.amount &&
        created_at == other.created_at &&
        object == other.object &&
        subject == other.subject &&
        updated_at == other.updated_at;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, amount.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, object.hashCode);
    _$hash = $jc(_$hash, subject.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(
            r'Gvote_comment_stream_cursor_value_input')
          ..add('amount', amount)
          ..add('created_at', created_at)
          ..add('object', object)
          ..add('subject', subject)
          ..add('updated_at', updated_at))
        .toString();
  }
}

class Gvote_comment_stream_cursor_value_inputBuilder
    implements
        Builder<Gvote_comment_stream_cursor_value_input,
            Gvote_comment_stream_cursor_value_inputBuilder> {
  _$Gvote_comment_stream_cursor_value_input? _$v;

  int? _amount;
  int? get amount => _$this._amount;
  set amount(int? amount) => _$this._amount = amount;

  DateTime? _created_at;
  DateTime? get created_at => _$this._created_at;
  set created_at(DateTime? created_at) => _$this._created_at = created_at;

  String? _object;
  String? get object => _$this._object;
  set object(String? object) => _$this._object = object;

  String? _subject;
  String? get subject => _$this._subject;
  set subject(String? subject) => _$this._subject = subject;

  DateTime? _updated_at;
  DateTime? get updated_at => _$this._updated_at;
  set updated_at(DateTime? updated_at) => _$this._updated_at = updated_at;

  Gvote_comment_stream_cursor_value_inputBuilder();

  Gvote_comment_stream_cursor_value_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _amount = $v.amount;
      _created_at = $v.created_at;
      _object = $v.object;
      _subject = $v.subject;
      _updated_at = $v.updated_at;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_comment_stream_cursor_value_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_comment_stream_cursor_value_input;
  }

  @override
  void update(
      void Function(Gvote_comment_stream_cursor_value_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_comment_stream_cursor_value_input build() => _build();

  _$Gvote_comment_stream_cursor_value_input _build() {
    final _$result = _$v ??
        new _$Gvote_comment_stream_cursor_value_input._(
            amount: amount,
            created_at: created_at,
            object: object,
            subject: subject,
            updated_at: updated_at);
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_comment_updates extends Gvote_comment_updates {
  @override
  final Gvote_comment_inc_input? G_inc;
  @override
  final Gvote_comment_set_input? G_set;
  @override
  final Gvote_comment_bool_exp where;

  factory _$Gvote_comment_updates(
          [void Function(Gvote_comment_updatesBuilder)? updates]) =>
      (new Gvote_comment_updatesBuilder()..update(updates))._build();

  _$Gvote_comment_updates._({this.G_inc, this.G_set, required this.where})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        where, r'Gvote_comment_updates', 'where');
  }

  @override
  Gvote_comment_updates rebuild(
          void Function(Gvote_comment_updatesBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_comment_updatesBuilder toBuilder() =>
      new Gvote_comment_updatesBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_comment_updates &&
        G_inc == other.G_inc &&
        G_set == other.G_set &&
        where == other.where;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, G_inc.hashCode);
    _$hash = $jc(_$hash, G_set.hashCode);
    _$hash = $jc(_$hash, where.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_comment_updates')
          ..add('G_inc', G_inc)
          ..add('G_set', G_set)
          ..add('where', where))
        .toString();
  }
}

class Gvote_comment_updatesBuilder
    implements Builder<Gvote_comment_updates, Gvote_comment_updatesBuilder> {
  _$Gvote_comment_updates? _$v;

  Gvote_comment_inc_inputBuilder? _G_inc;
  Gvote_comment_inc_inputBuilder get G_inc =>
      _$this._G_inc ??= new Gvote_comment_inc_inputBuilder();
  set G_inc(Gvote_comment_inc_inputBuilder? G_inc) => _$this._G_inc = G_inc;

  Gvote_comment_set_inputBuilder? _G_set;
  Gvote_comment_set_inputBuilder get G_set =>
      _$this._G_set ??= new Gvote_comment_set_inputBuilder();
  set G_set(Gvote_comment_set_inputBuilder? G_set) => _$this._G_set = G_set;

  Gvote_comment_bool_expBuilder? _where;
  Gvote_comment_bool_expBuilder get where =>
      _$this._where ??= new Gvote_comment_bool_expBuilder();
  set where(Gvote_comment_bool_expBuilder? where) => _$this._where = where;

  Gvote_comment_updatesBuilder();

  Gvote_comment_updatesBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _G_inc = $v.G_inc?.toBuilder();
      _G_set = $v.G_set?.toBuilder();
      _where = $v.where.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_comment_updates other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_comment_updates;
  }

  @override
  void update(void Function(Gvote_comment_updatesBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_comment_updates build() => _build();

  _$Gvote_comment_updates _build() {
    _$Gvote_comment_updates _$result;
    try {
      _$result = _$v ??
          new _$Gvote_comment_updates._(
              G_inc: _G_inc?.build(),
              G_set: _G_set?.build(),
              where: where.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'G_inc';
        _G_inc?.build();
        _$failedField = 'G_set';
        _G_set?.build();
        _$failedField = 'where';
        where.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gvote_comment_updates', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_user_bool_exp extends Gvote_user_bool_exp {
  @override
  final BuiltList<Gvote_user_bool_exp>? G_and;
  @override
  final Gvote_user_bool_exp? G_not;
  @override
  final BuiltList<Gvote_user_bool_exp>? G_or;
  @override
  final GInt_comparison_exp? amount;
  @override
  final Gtimestamptz_comparison_exp? created_at;
  @override
  final GString_comparison_exp? object;
  @override
  final GString_comparison_exp? subject;
  @override
  final Gtimestamptz_comparison_exp? updated_at;

  factory _$Gvote_user_bool_exp(
          [void Function(Gvote_user_bool_expBuilder)? updates]) =>
      (new Gvote_user_bool_expBuilder()..update(updates))._build();

  _$Gvote_user_bool_exp._(
      {this.G_and,
      this.G_not,
      this.G_or,
      this.amount,
      this.created_at,
      this.object,
      this.subject,
      this.updated_at})
      : super._();

  @override
  Gvote_user_bool_exp rebuild(
          void Function(Gvote_user_bool_expBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_user_bool_expBuilder toBuilder() =>
      new Gvote_user_bool_expBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_user_bool_exp &&
        G_and == other.G_and &&
        G_not == other.G_not &&
        G_or == other.G_or &&
        amount == other.amount &&
        created_at == other.created_at &&
        object == other.object &&
        subject == other.subject &&
        updated_at == other.updated_at;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, G_and.hashCode);
    _$hash = $jc(_$hash, G_not.hashCode);
    _$hash = $jc(_$hash, G_or.hashCode);
    _$hash = $jc(_$hash, amount.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, object.hashCode);
    _$hash = $jc(_$hash, subject.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_user_bool_exp')
          ..add('G_and', G_and)
          ..add('G_not', G_not)
          ..add('G_or', G_or)
          ..add('amount', amount)
          ..add('created_at', created_at)
          ..add('object', object)
          ..add('subject', subject)
          ..add('updated_at', updated_at))
        .toString();
  }
}

class Gvote_user_bool_expBuilder
    implements Builder<Gvote_user_bool_exp, Gvote_user_bool_expBuilder> {
  _$Gvote_user_bool_exp? _$v;

  ListBuilder<Gvote_user_bool_exp>? _G_and;
  ListBuilder<Gvote_user_bool_exp> get G_and =>
      _$this._G_and ??= new ListBuilder<Gvote_user_bool_exp>();
  set G_and(ListBuilder<Gvote_user_bool_exp>? G_and) => _$this._G_and = G_and;

  Gvote_user_bool_expBuilder? _G_not;
  Gvote_user_bool_expBuilder get G_not =>
      _$this._G_not ??= new Gvote_user_bool_expBuilder();
  set G_not(Gvote_user_bool_expBuilder? G_not) => _$this._G_not = G_not;

  ListBuilder<Gvote_user_bool_exp>? _G_or;
  ListBuilder<Gvote_user_bool_exp> get G_or =>
      _$this._G_or ??= new ListBuilder<Gvote_user_bool_exp>();
  set G_or(ListBuilder<Gvote_user_bool_exp>? G_or) => _$this._G_or = G_or;

  GInt_comparison_expBuilder? _amount;
  GInt_comparison_expBuilder get amount =>
      _$this._amount ??= new GInt_comparison_expBuilder();
  set amount(GInt_comparison_expBuilder? amount) => _$this._amount = amount;

  Gtimestamptz_comparison_expBuilder? _created_at;
  Gtimestamptz_comparison_expBuilder get created_at =>
      _$this._created_at ??= new Gtimestamptz_comparison_expBuilder();
  set created_at(Gtimestamptz_comparison_expBuilder? created_at) =>
      _$this._created_at = created_at;

  GString_comparison_expBuilder? _object;
  GString_comparison_expBuilder get object =>
      _$this._object ??= new GString_comparison_expBuilder();
  set object(GString_comparison_expBuilder? object) => _$this._object = object;

  GString_comparison_expBuilder? _subject;
  GString_comparison_expBuilder get subject =>
      _$this._subject ??= new GString_comparison_expBuilder();
  set subject(GString_comparison_expBuilder? subject) =>
      _$this._subject = subject;

  Gtimestamptz_comparison_expBuilder? _updated_at;
  Gtimestamptz_comparison_expBuilder get updated_at =>
      _$this._updated_at ??= new Gtimestamptz_comparison_expBuilder();
  set updated_at(Gtimestamptz_comparison_expBuilder? updated_at) =>
      _$this._updated_at = updated_at;

  Gvote_user_bool_expBuilder();

  Gvote_user_bool_expBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _G_and = $v.G_and?.toBuilder();
      _G_not = $v.G_not?.toBuilder();
      _G_or = $v.G_or?.toBuilder();
      _amount = $v.amount?.toBuilder();
      _created_at = $v.created_at?.toBuilder();
      _object = $v.object?.toBuilder();
      _subject = $v.subject?.toBuilder();
      _updated_at = $v.updated_at?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_user_bool_exp other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_user_bool_exp;
  }

  @override
  void update(void Function(Gvote_user_bool_expBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_user_bool_exp build() => _build();

  _$Gvote_user_bool_exp _build() {
    _$Gvote_user_bool_exp _$result;
    try {
      _$result = _$v ??
          new _$Gvote_user_bool_exp._(
              G_and: _G_and?.build(),
              G_not: _G_not?.build(),
              G_or: _G_or?.build(),
              amount: _amount?.build(),
              created_at: _created_at?.build(),
              object: _object?.build(),
              subject: _subject?.build(),
              updated_at: _updated_at?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'G_and';
        _G_and?.build();
        _$failedField = 'G_not';
        _G_not?.build();
        _$failedField = 'G_or';
        _G_or?.build();
        _$failedField = 'amount';
        _amount?.build();
        _$failedField = 'created_at';
        _created_at?.build();
        _$failedField = 'object';
        _object?.build();
        _$failedField = 'subject';
        _subject?.build();
        _$failedField = 'updated_at';
        _updated_at?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gvote_user_bool_exp', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_user_inc_input extends Gvote_user_inc_input {
  @override
  final int? amount;

  factory _$Gvote_user_inc_input(
          [void Function(Gvote_user_inc_inputBuilder)? updates]) =>
      (new Gvote_user_inc_inputBuilder()..update(updates))._build();

  _$Gvote_user_inc_input._({this.amount}) : super._();

  @override
  Gvote_user_inc_input rebuild(
          void Function(Gvote_user_inc_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_user_inc_inputBuilder toBuilder() =>
      new Gvote_user_inc_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_user_inc_input && amount == other.amount;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, amount.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_user_inc_input')
          ..add('amount', amount))
        .toString();
  }
}

class Gvote_user_inc_inputBuilder
    implements Builder<Gvote_user_inc_input, Gvote_user_inc_inputBuilder> {
  _$Gvote_user_inc_input? _$v;

  int? _amount;
  int? get amount => _$this._amount;
  set amount(int? amount) => _$this._amount = amount;

  Gvote_user_inc_inputBuilder();

  Gvote_user_inc_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _amount = $v.amount;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_user_inc_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_user_inc_input;
  }

  @override
  void update(void Function(Gvote_user_inc_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_user_inc_input build() => _build();

  _$Gvote_user_inc_input _build() {
    final _$result = _$v ?? new _$Gvote_user_inc_input._(amount: amount);
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_user_insert_input extends Gvote_user_insert_input {
  @override
  final int? amount;
  @override
  final DateTime? created_at;
  @override
  final String? object;
  @override
  final String? subject;
  @override
  final DateTime? updated_at;

  factory _$Gvote_user_insert_input(
          [void Function(Gvote_user_insert_inputBuilder)? updates]) =>
      (new Gvote_user_insert_inputBuilder()..update(updates))._build();

  _$Gvote_user_insert_input._(
      {this.amount,
      this.created_at,
      this.object,
      this.subject,
      this.updated_at})
      : super._();

  @override
  Gvote_user_insert_input rebuild(
          void Function(Gvote_user_insert_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_user_insert_inputBuilder toBuilder() =>
      new Gvote_user_insert_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_user_insert_input &&
        amount == other.amount &&
        created_at == other.created_at &&
        object == other.object &&
        subject == other.subject &&
        updated_at == other.updated_at;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, amount.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, object.hashCode);
    _$hash = $jc(_$hash, subject.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_user_insert_input')
          ..add('amount', amount)
          ..add('created_at', created_at)
          ..add('object', object)
          ..add('subject', subject)
          ..add('updated_at', updated_at))
        .toString();
  }
}

class Gvote_user_insert_inputBuilder
    implements
        Builder<Gvote_user_insert_input, Gvote_user_insert_inputBuilder> {
  _$Gvote_user_insert_input? _$v;

  int? _amount;
  int? get amount => _$this._amount;
  set amount(int? amount) => _$this._amount = amount;

  DateTime? _created_at;
  DateTime? get created_at => _$this._created_at;
  set created_at(DateTime? created_at) => _$this._created_at = created_at;

  String? _object;
  String? get object => _$this._object;
  set object(String? object) => _$this._object = object;

  String? _subject;
  String? get subject => _$this._subject;
  set subject(String? subject) => _$this._subject = subject;

  DateTime? _updated_at;
  DateTime? get updated_at => _$this._updated_at;
  set updated_at(DateTime? updated_at) => _$this._updated_at = updated_at;

  Gvote_user_insert_inputBuilder();

  Gvote_user_insert_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _amount = $v.amount;
      _created_at = $v.created_at;
      _object = $v.object;
      _subject = $v.subject;
      _updated_at = $v.updated_at;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_user_insert_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_user_insert_input;
  }

  @override
  void update(void Function(Gvote_user_insert_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_user_insert_input build() => _build();

  _$Gvote_user_insert_input _build() {
    final _$result = _$v ??
        new _$Gvote_user_insert_input._(
            amount: amount,
            created_at: created_at,
            object: object,
            subject: subject,
            updated_at: updated_at);
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_user_on_conflict extends Gvote_user_on_conflict {
  @override
  final Gvote_user_constraint constraint;
  @override
  final BuiltList<Gvote_user_update_column> update_columns;
  @override
  final Gvote_user_bool_exp? where;

  factory _$Gvote_user_on_conflict(
          [void Function(Gvote_user_on_conflictBuilder)? updates]) =>
      (new Gvote_user_on_conflictBuilder()..update(updates))._build();

  _$Gvote_user_on_conflict._(
      {required this.constraint, required this.update_columns, this.where})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        constraint, r'Gvote_user_on_conflict', 'constraint');
    BuiltValueNullFieldError.checkNotNull(
        update_columns, r'Gvote_user_on_conflict', 'update_columns');
  }

  @override
  Gvote_user_on_conflict rebuild(
          void Function(Gvote_user_on_conflictBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_user_on_conflictBuilder toBuilder() =>
      new Gvote_user_on_conflictBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_user_on_conflict &&
        constraint == other.constraint &&
        update_columns == other.update_columns &&
        where == other.where;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, constraint.hashCode);
    _$hash = $jc(_$hash, update_columns.hashCode);
    _$hash = $jc(_$hash, where.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_user_on_conflict')
          ..add('constraint', constraint)
          ..add('update_columns', update_columns)
          ..add('where', where))
        .toString();
  }
}

class Gvote_user_on_conflictBuilder
    implements Builder<Gvote_user_on_conflict, Gvote_user_on_conflictBuilder> {
  _$Gvote_user_on_conflict? _$v;

  Gvote_user_constraint? _constraint;
  Gvote_user_constraint? get constraint => _$this._constraint;
  set constraint(Gvote_user_constraint? constraint) =>
      _$this._constraint = constraint;

  ListBuilder<Gvote_user_update_column>? _update_columns;
  ListBuilder<Gvote_user_update_column> get update_columns =>
      _$this._update_columns ??= new ListBuilder<Gvote_user_update_column>();
  set update_columns(ListBuilder<Gvote_user_update_column>? update_columns) =>
      _$this._update_columns = update_columns;

  Gvote_user_bool_expBuilder? _where;
  Gvote_user_bool_expBuilder get where =>
      _$this._where ??= new Gvote_user_bool_expBuilder();
  set where(Gvote_user_bool_expBuilder? where) => _$this._where = where;

  Gvote_user_on_conflictBuilder();

  Gvote_user_on_conflictBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _constraint = $v.constraint;
      _update_columns = $v.update_columns.toBuilder();
      _where = $v.where?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_user_on_conflict other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_user_on_conflict;
  }

  @override
  void update(void Function(Gvote_user_on_conflictBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_user_on_conflict build() => _build();

  _$Gvote_user_on_conflict _build() {
    _$Gvote_user_on_conflict _$result;
    try {
      _$result = _$v ??
          new _$Gvote_user_on_conflict._(
              constraint: BuiltValueNullFieldError.checkNotNull(
                  constraint, r'Gvote_user_on_conflict', 'constraint'),
              update_columns: update_columns.build(),
              where: _where?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'update_columns';
        update_columns.build();
        _$failedField = 'where';
        _where?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gvote_user_on_conflict', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_user_order_by extends Gvote_user_order_by {
  @override
  final Gorder_by? amount;
  @override
  final Gorder_by? created_at;
  @override
  final Gorder_by? object;
  @override
  final Gorder_by? subject;
  @override
  final Gorder_by? updated_at;

  factory _$Gvote_user_order_by(
          [void Function(Gvote_user_order_byBuilder)? updates]) =>
      (new Gvote_user_order_byBuilder()..update(updates))._build();

  _$Gvote_user_order_by._(
      {this.amount,
      this.created_at,
      this.object,
      this.subject,
      this.updated_at})
      : super._();

  @override
  Gvote_user_order_by rebuild(
          void Function(Gvote_user_order_byBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_user_order_byBuilder toBuilder() =>
      new Gvote_user_order_byBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_user_order_by &&
        amount == other.amount &&
        created_at == other.created_at &&
        object == other.object &&
        subject == other.subject &&
        updated_at == other.updated_at;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, amount.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, object.hashCode);
    _$hash = $jc(_$hash, subject.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_user_order_by')
          ..add('amount', amount)
          ..add('created_at', created_at)
          ..add('object', object)
          ..add('subject', subject)
          ..add('updated_at', updated_at))
        .toString();
  }
}

class Gvote_user_order_byBuilder
    implements Builder<Gvote_user_order_by, Gvote_user_order_byBuilder> {
  _$Gvote_user_order_by? _$v;

  Gorder_by? _amount;
  Gorder_by? get amount => _$this._amount;
  set amount(Gorder_by? amount) => _$this._amount = amount;

  Gorder_by? _created_at;
  Gorder_by? get created_at => _$this._created_at;
  set created_at(Gorder_by? created_at) => _$this._created_at = created_at;

  Gorder_by? _object;
  Gorder_by? get object => _$this._object;
  set object(Gorder_by? object) => _$this._object = object;

  Gorder_by? _subject;
  Gorder_by? get subject => _$this._subject;
  set subject(Gorder_by? subject) => _$this._subject = subject;

  Gorder_by? _updated_at;
  Gorder_by? get updated_at => _$this._updated_at;
  set updated_at(Gorder_by? updated_at) => _$this._updated_at = updated_at;

  Gvote_user_order_byBuilder();

  Gvote_user_order_byBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _amount = $v.amount;
      _created_at = $v.created_at;
      _object = $v.object;
      _subject = $v.subject;
      _updated_at = $v.updated_at;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_user_order_by other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_user_order_by;
  }

  @override
  void update(void Function(Gvote_user_order_byBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_user_order_by build() => _build();

  _$Gvote_user_order_by _build() {
    final _$result = _$v ??
        new _$Gvote_user_order_by._(
            amount: amount,
            created_at: created_at,
            object: object,
            subject: subject,
            updated_at: updated_at);
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_user_pk_columns_input extends Gvote_user_pk_columns_input {
  @override
  final String object;
  @override
  final String subject;

  factory _$Gvote_user_pk_columns_input(
          [void Function(Gvote_user_pk_columns_inputBuilder)? updates]) =>
      (new Gvote_user_pk_columns_inputBuilder()..update(updates))._build();

  _$Gvote_user_pk_columns_input._({required this.object, required this.subject})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        object, r'Gvote_user_pk_columns_input', 'object');
    BuiltValueNullFieldError.checkNotNull(
        subject, r'Gvote_user_pk_columns_input', 'subject');
  }

  @override
  Gvote_user_pk_columns_input rebuild(
          void Function(Gvote_user_pk_columns_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_user_pk_columns_inputBuilder toBuilder() =>
      new Gvote_user_pk_columns_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_user_pk_columns_input &&
        object == other.object &&
        subject == other.subject;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, object.hashCode);
    _$hash = $jc(_$hash, subject.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_user_pk_columns_input')
          ..add('object', object)
          ..add('subject', subject))
        .toString();
  }
}

class Gvote_user_pk_columns_inputBuilder
    implements
        Builder<Gvote_user_pk_columns_input,
            Gvote_user_pk_columns_inputBuilder> {
  _$Gvote_user_pk_columns_input? _$v;

  String? _object;
  String? get object => _$this._object;
  set object(String? object) => _$this._object = object;

  String? _subject;
  String? get subject => _$this._subject;
  set subject(String? subject) => _$this._subject = subject;

  Gvote_user_pk_columns_inputBuilder();

  Gvote_user_pk_columns_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _object = $v.object;
      _subject = $v.subject;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_user_pk_columns_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_user_pk_columns_input;
  }

  @override
  void update(void Function(Gvote_user_pk_columns_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_user_pk_columns_input build() => _build();

  _$Gvote_user_pk_columns_input _build() {
    final _$result = _$v ??
        new _$Gvote_user_pk_columns_input._(
            object: BuiltValueNullFieldError.checkNotNull(
                object, r'Gvote_user_pk_columns_input', 'object'),
            subject: BuiltValueNullFieldError.checkNotNull(
                subject, r'Gvote_user_pk_columns_input', 'subject'));
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_user_set_input extends Gvote_user_set_input {
  @override
  final int? amount;
  @override
  final DateTime? created_at;
  @override
  final String? object;
  @override
  final String? subject;
  @override
  final DateTime? updated_at;

  factory _$Gvote_user_set_input(
          [void Function(Gvote_user_set_inputBuilder)? updates]) =>
      (new Gvote_user_set_inputBuilder()..update(updates))._build();

  _$Gvote_user_set_input._(
      {this.amount,
      this.created_at,
      this.object,
      this.subject,
      this.updated_at})
      : super._();

  @override
  Gvote_user_set_input rebuild(
          void Function(Gvote_user_set_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_user_set_inputBuilder toBuilder() =>
      new Gvote_user_set_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_user_set_input &&
        amount == other.amount &&
        created_at == other.created_at &&
        object == other.object &&
        subject == other.subject &&
        updated_at == other.updated_at;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, amount.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, object.hashCode);
    _$hash = $jc(_$hash, subject.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_user_set_input')
          ..add('amount', amount)
          ..add('created_at', created_at)
          ..add('object', object)
          ..add('subject', subject)
          ..add('updated_at', updated_at))
        .toString();
  }
}

class Gvote_user_set_inputBuilder
    implements Builder<Gvote_user_set_input, Gvote_user_set_inputBuilder> {
  _$Gvote_user_set_input? _$v;

  int? _amount;
  int? get amount => _$this._amount;
  set amount(int? amount) => _$this._amount = amount;

  DateTime? _created_at;
  DateTime? get created_at => _$this._created_at;
  set created_at(DateTime? created_at) => _$this._created_at = created_at;

  String? _object;
  String? get object => _$this._object;
  set object(String? object) => _$this._object = object;

  String? _subject;
  String? get subject => _$this._subject;
  set subject(String? subject) => _$this._subject = subject;

  DateTime? _updated_at;
  DateTime? get updated_at => _$this._updated_at;
  set updated_at(DateTime? updated_at) => _$this._updated_at = updated_at;

  Gvote_user_set_inputBuilder();

  Gvote_user_set_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _amount = $v.amount;
      _created_at = $v.created_at;
      _object = $v.object;
      _subject = $v.subject;
      _updated_at = $v.updated_at;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_user_set_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_user_set_input;
  }

  @override
  void update(void Function(Gvote_user_set_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_user_set_input build() => _build();

  _$Gvote_user_set_input _build() {
    final _$result = _$v ??
        new _$Gvote_user_set_input._(
            amount: amount,
            created_at: created_at,
            object: object,
            subject: subject,
            updated_at: updated_at);
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_user_stream_cursor_input extends Gvote_user_stream_cursor_input {
  @override
  final Gvote_user_stream_cursor_value_input initial_value;
  @override
  final Gcursor_ordering? ordering;

  factory _$Gvote_user_stream_cursor_input(
          [void Function(Gvote_user_stream_cursor_inputBuilder)? updates]) =>
      (new Gvote_user_stream_cursor_inputBuilder()..update(updates))._build();

  _$Gvote_user_stream_cursor_input._(
      {required this.initial_value, this.ordering})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        initial_value, r'Gvote_user_stream_cursor_input', 'initial_value');
  }

  @override
  Gvote_user_stream_cursor_input rebuild(
          void Function(Gvote_user_stream_cursor_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_user_stream_cursor_inputBuilder toBuilder() =>
      new Gvote_user_stream_cursor_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_user_stream_cursor_input &&
        initial_value == other.initial_value &&
        ordering == other.ordering;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, initial_value.hashCode);
    _$hash = $jc(_$hash, ordering.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_user_stream_cursor_input')
          ..add('initial_value', initial_value)
          ..add('ordering', ordering))
        .toString();
  }
}

class Gvote_user_stream_cursor_inputBuilder
    implements
        Builder<Gvote_user_stream_cursor_input,
            Gvote_user_stream_cursor_inputBuilder> {
  _$Gvote_user_stream_cursor_input? _$v;

  Gvote_user_stream_cursor_value_inputBuilder? _initial_value;
  Gvote_user_stream_cursor_value_inputBuilder get initial_value =>
      _$this._initial_value ??=
          new Gvote_user_stream_cursor_value_inputBuilder();
  set initial_value(
          Gvote_user_stream_cursor_value_inputBuilder? initial_value) =>
      _$this._initial_value = initial_value;

  Gcursor_ordering? _ordering;
  Gcursor_ordering? get ordering => _$this._ordering;
  set ordering(Gcursor_ordering? ordering) => _$this._ordering = ordering;

  Gvote_user_stream_cursor_inputBuilder();

  Gvote_user_stream_cursor_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _initial_value = $v.initial_value.toBuilder();
      _ordering = $v.ordering;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_user_stream_cursor_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_user_stream_cursor_input;
  }

  @override
  void update(void Function(Gvote_user_stream_cursor_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_user_stream_cursor_input build() => _build();

  _$Gvote_user_stream_cursor_input _build() {
    _$Gvote_user_stream_cursor_input _$result;
    try {
      _$result = _$v ??
          new _$Gvote_user_stream_cursor_input._(
              initial_value: initial_value.build(), ordering: ordering);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'initial_value';
        initial_value.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gvote_user_stream_cursor_input', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_user_stream_cursor_value_input
    extends Gvote_user_stream_cursor_value_input {
  @override
  final int? amount;
  @override
  final DateTime? created_at;
  @override
  final String? object;
  @override
  final String? subject;
  @override
  final DateTime? updated_at;

  factory _$Gvote_user_stream_cursor_value_input(
          [void Function(Gvote_user_stream_cursor_value_inputBuilder)?
              updates]) =>
      (new Gvote_user_stream_cursor_value_inputBuilder()..update(updates))
          ._build();

  _$Gvote_user_stream_cursor_value_input._(
      {this.amount,
      this.created_at,
      this.object,
      this.subject,
      this.updated_at})
      : super._();

  @override
  Gvote_user_stream_cursor_value_input rebuild(
          void Function(Gvote_user_stream_cursor_value_inputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_user_stream_cursor_value_inputBuilder toBuilder() =>
      new Gvote_user_stream_cursor_value_inputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_user_stream_cursor_value_input &&
        amount == other.amount &&
        created_at == other.created_at &&
        object == other.object &&
        subject == other.subject &&
        updated_at == other.updated_at;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, amount.hashCode);
    _$hash = $jc(_$hash, created_at.hashCode);
    _$hash = $jc(_$hash, object.hashCode);
    _$hash = $jc(_$hash, subject.hashCode);
    _$hash = $jc(_$hash, updated_at.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_user_stream_cursor_value_input')
          ..add('amount', amount)
          ..add('created_at', created_at)
          ..add('object', object)
          ..add('subject', subject)
          ..add('updated_at', updated_at))
        .toString();
  }
}

class Gvote_user_stream_cursor_value_inputBuilder
    implements
        Builder<Gvote_user_stream_cursor_value_input,
            Gvote_user_stream_cursor_value_inputBuilder> {
  _$Gvote_user_stream_cursor_value_input? _$v;

  int? _amount;
  int? get amount => _$this._amount;
  set amount(int? amount) => _$this._amount = amount;

  DateTime? _created_at;
  DateTime? get created_at => _$this._created_at;
  set created_at(DateTime? created_at) => _$this._created_at = created_at;

  String? _object;
  String? get object => _$this._object;
  set object(String? object) => _$this._object = object;

  String? _subject;
  String? get subject => _$this._subject;
  set subject(String? subject) => _$this._subject = subject;

  DateTime? _updated_at;
  DateTime? get updated_at => _$this._updated_at;
  set updated_at(DateTime? updated_at) => _$this._updated_at = updated_at;

  Gvote_user_stream_cursor_value_inputBuilder();

  Gvote_user_stream_cursor_value_inputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _amount = $v.amount;
      _created_at = $v.created_at;
      _object = $v.object;
      _subject = $v.subject;
      _updated_at = $v.updated_at;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_user_stream_cursor_value_input other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_user_stream_cursor_value_input;
  }

  @override
  void update(
      void Function(Gvote_user_stream_cursor_value_inputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_user_stream_cursor_value_input build() => _build();

  _$Gvote_user_stream_cursor_value_input _build() {
    final _$result = _$v ??
        new _$Gvote_user_stream_cursor_value_input._(
            amount: amount,
            created_at: created_at,
            object: object,
            subject: subject,
            updated_at: updated_at);
    replace(_$result);
    return _$result;
  }
}

class _$Gvote_user_updates extends Gvote_user_updates {
  @override
  final Gvote_user_inc_input? G_inc;
  @override
  final Gvote_user_set_input? G_set;
  @override
  final Gvote_user_bool_exp where;

  factory _$Gvote_user_updates(
          [void Function(Gvote_user_updatesBuilder)? updates]) =>
      (new Gvote_user_updatesBuilder()..update(updates))._build();

  _$Gvote_user_updates._({this.G_inc, this.G_set, required this.where})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        where, r'Gvote_user_updates', 'where');
  }

  @override
  Gvote_user_updates rebuild(
          void Function(Gvote_user_updatesBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  Gvote_user_updatesBuilder toBuilder() =>
      new Gvote_user_updatesBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Gvote_user_updates &&
        G_inc == other.G_inc &&
        G_set == other.G_set &&
        where == other.where;
  }

  @override
  int get hashCode {
    var _$hash = 0;
    _$hash = $jc(_$hash, G_inc.hashCode);
    _$hash = $jc(_$hash, G_set.hashCode);
    _$hash = $jc(_$hash, where.hashCode);
    _$hash = $jf(_$hash);
    return _$hash;
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper(r'Gvote_user_updates')
          ..add('G_inc', G_inc)
          ..add('G_set', G_set)
          ..add('where', where))
        .toString();
  }
}

class Gvote_user_updatesBuilder
    implements Builder<Gvote_user_updates, Gvote_user_updatesBuilder> {
  _$Gvote_user_updates? _$v;

  Gvote_user_inc_inputBuilder? _G_inc;
  Gvote_user_inc_inputBuilder get G_inc =>
      _$this._G_inc ??= new Gvote_user_inc_inputBuilder();
  set G_inc(Gvote_user_inc_inputBuilder? G_inc) => _$this._G_inc = G_inc;

  Gvote_user_set_inputBuilder? _G_set;
  Gvote_user_set_inputBuilder get G_set =>
      _$this._G_set ??= new Gvote_user_set_inputBuilder();
  set G_set(Gvote_user_set_inputBuilder? G_set) => _$this._G_set = G_set;

  Gvote_user_bool_expBuilder? _where;
  Gvote_user_bool_expBuilder get where =>
      _$this._where ??= new Gvote_user_bool_expBuilder();
  set where(Gvote_user_bool_expBuilder? where) => _$this._where = where;

  Gvote_user_updatesBuilder();

  Gvote_user_updatesBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _G_inc = $v.G_inc?.toBuilder();
      _G_set = $v.G_set?.toBuilder();
      _where = $v.where.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Gvote_user_updates other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Gvote_user_updates;
  }

  @override
  void update(void Function(Gvote_user_updatesBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  Gvote_user_updates build() => _build();

  _$Gvote_user_updates _build() {
    _$Gvote_user_updates _$result;
    try {
      _$result = _$v ??
          new _$Gvote_user_updates._(
              G_inc: _G_inc?.build(),
              G_set: _G_set?.build(),
              where: where.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'G_inc';
        _G_inc?.build();
        _$failedField = 'G_set';
        _G_set?.build();
        _$failedField = 'where';
        where.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            r'Gvote_user_updates', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

// ignore_for_file: deprecated_member_use_from_same_package,type=lint
